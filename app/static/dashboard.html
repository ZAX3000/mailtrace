<!DOCTYPE html>

<html lang="en">
<head>
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
<meta http-equiv="Pragma" content="no-cache"/>
<meta http-equiv="Expires" content="0"/>

<!-- ASSET VERSION: 2025-09-30 17:01:12  |  Update the ?v= param on CSS/JS when you change files. Example: ?v=YYYYMMDD_HHMMSS -->

<!-- Inline Lsv1 loader -->
<script>

/*! Lsv1 Loader (no listeners, no hooks) */
(function(){
  if (window.MailTraceLoader) return;
  var modal, fill, val, etaEl, scene, scope, chart, style;
  function clamp(n){ return Math.max(0, Math.min(100, Math.round(n))); }
  function setPct(p){ p = clamp(p); if (fill) fill.style.width = p + '%'; if (val) val.textContent = p + '%'; }
  function setETA(sec){
    if (!etaEl) return;
    if (sec == null){ etaEl.innerHTML = '≈ <strong>--:--</strong> left'; return; }
    sec = Math.max(0, Math.round(sec));
    var m = Math.floor(sec/60), s = sec%60;
    etaEl.innerHTML = m>0 ? '≈ <strong>'+m+'m '+s+'s</strong> left' : '≈ <strong>'+s+'s</strong> left';
  }
  function ensureDOM(){
    if (modal) return;
    style = document.createElement('style');
    style.textContent = [
      '@keyframes mt-orbit{0%{--x:120px;--y:94px;}25%{--x:154px;--y:100px;}50%{--x:120px;--y:112px;}75%{--x:86px;--y:100px;}100%{--x:120px;--y:94px;}}',
      '#mailtrace-modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(6,22,39,.52);z-index:2147483000;backdrop-filter:blur(2px)}',
      '#mailtrace-modal .scene{position:relative;width:280px;height:230px;--x:120px;--y:100px;--r:27px;animation:mt-orbit 4.2s ease-in-out infinite}',
      '#mailtrace-modal .scope{position:absolute;width:115px;height:115px;left:0;top:0;pointer-events:none;filter:drop-shadow(0 8px 12px rgba(0,0,0,.35));transform:translate(calc(var(--x) - 57.5px), calc(var(--y) - 57.5px))}',
      '#mailtrace-modal .chart{position:absolute;inset:0;pointer-events:none;clip-path:circle(var(--r) at var(--x) var(--y));-webkit-clip-path:circle(var(--r) at var(--x) var(--y))}'
    ].join('');
    document.head.appendChild(style);

    modal = document.createElement('div');
    modal.id = 'mailtrace-modal';
    modal.innerHTML = ''
      + '<div style="position:relative;width:420px;height:510px;border-radius:28px;background:radial-gradient(120% 120% at 50% 10%,rgba(255,255,255,.07),rgba(255,255,255,.02));box-shadow:0 14px 40px rgba(0,0,0,.45),inset 0 0 0 1px rgba(255,255,255,.08);display:flex;align-items:center;justify-content:center;overflow:hidden">'
      + '  <button aria-label="Close" onclick="MailTraceLoader.hide()" style="position:absolute;top:10px;right:10px;background:transparent;border:none;color:#cbd5e1;font-size:18px;cursor:pointer;padding:6px;border-radius:10px">✕</button>'
      + '  <div class="scene">'
      + '    <svg viewBox="0 0 240 200" width="280" height="230" aria-label="Envelope back">'
      + '      <rect x="20" y="36" rx="14" ry="14" width="200" height="128" fill="#ffffff"/>'
      + '      <rect x="24" y="40" rx="12" ry="12" width="192" height="120" fill="#f5f9fc"/>'
      + '      <path d="M20,52 L120,116 L220,52 L220,36 C220,28.268 213.732,22 206,22 L34,22 C26.268,22 20,28.268 20,36 Z" fill="#dde8f2"/>'
      + '      <path d="M20,52 L120,116 L220,52" fill="none" stroke="#c8d9e7" stroke-width="2"/>'
      + '    </svg>'
      + '    <div class="chart">'
      + '      <svg viewBox="0 0 240 200" width="280" height="230">'
      + '        <defs>'
      + '          <pattern id="gridM" width="20" height="20" patternUnits="userSpaceOnUse"><path d="M20 0 H0 V20" fill="none" stroke="rgba(0,0,0,0.06)" stroke-width="1"/></pattern>'
      + '          <linearGradient id="fillM" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="rgba(110,231,183,0.35)"/><stop offset="100%" stop-color="rgba(110,231,183,0)"/></linearGradient>'
      + '        </defs>'
      + '        <g id="mag"><g transform="translate(0,-12)">'
      + '          <rect x="24" y="40" width="192" height="120" fill="url(#gridM)"/>'
      + '          <path d="M32 150 H208" stroke="rgba(0,0,0,0.12)" stroke-width="1"/>'
      + '          <path d="M32 150 V56" stroke="rgba(0,0,0,0.12)" stroke-width="1"/>'
      + '          <path d="M32 150 L48 138 C56 132,64 126,72 128 S88 138,96 132 S112 108,120 112 S136 140,144 132 S160 98,168 100 S184 126,192 118 L208 118 L208 150 Z" fill="url(#fillM)"/>'
      + '          <path d="M32 150 L48 138 C56 132,64 126,72 128 S88 138,96 132 S112 108,120 112 S136 140,144 132 S160 98,168 100 S184 126,192 118 L208 118" fill="none" stroke="#6ee7b7" stroke-width="3" stroke-linecap="round"/>'
      + '        </g></g>'
      + '      </svg>'
      + '    </div>'
      + '    <svg class="scope" viewBox="0 0 120 120" aria-hidden="true">'
      + '      <defs><linearGradient id="rimM" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" stop-color="#1b6a3a"/><stop offset="100%" stop-color="#1db954"/></linearGradient><linearGradient id="handleM" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" stop-color="#16a34a"/><stop offset="100%" stop-color="#12843e"/></linearGradient></defs>'
      + '      <circle cx="54" cy="52" r="33" fill="none" stroke="url(#rimM)" stroke-width="6"/>'
      + '      <g transform="translate(54,52) rotate(40)"><rect x="31" y="-9" width="10" height="18" rx="5" fill="#0f7a3a"/><rect x="41" y="-7" width="42" height="14" rx="7" fill="url(#handleM)"/><rect x="43" y="-5" width="24" height="10" rx="5" fill="rgba(255,255,255,0.18)"/></g>'
      + '    </svg>'
      + '  </div>'
      + '  <div style="position:absolute;bottom:144px;left:32px;right:32px;color:#e8f1f8;text-align:center;font-weight:600">Analyzing run</div>'
      + '  <div style="position:absolute;bottom:118px;left:32px;right:32px;text-align:center;font-size:14px;color:#a8c3d9"><span>This may take a moment</span></div>'
      + '  <div style="position:absolute;left:32px;right:32px;bottom:48px">'
      + '    <div style="width:100%;height:10px;background:rgba(255,255,255,0.08);border-radius:999px;overflow:hidden;box-shadow:inset 0 0 0 1px rgba(255,255,255,.06)">'
      + '      <div id="mt-progress-fill" style="height:100%;width:0%;background:linear-gradient(90deg,#16a34a,#22c55e);border-radius:999px;transition:width .2s ease"></div>'
      + '    </div>'
      + '    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px;color:#a8c3d9;font-size:12px">'
      + '      <span>Completed</span><span id="mt-progress-value" style="color:#e8f1f8;font-weight:700">0%</span>'
      + '    </div>'
      + '  </div>'
      + '  <div id="mt-eta" style="position:absolute;bottom:20px;left:32px;right:32px;text-align:center;color:#a8c3d9;font-size:12px">≈ <strong>--:--</strong> left</div>'
      + '</div>';
    document.body.appendChild(modal);

    fill  = document.getElementById('mt-progress-fill');
    val   = document.getElementById('mt-progress-value');
    etaEl = document.getElementById('mt-eta');
    scene = modal.querySelector('.scene');
    scope = modal.querySelector('.scope');
    chart = modal.querySelector('.chart');
  }

  window.MailTraceLoader = {
    show: function(opts){
      ensureDOM();
      var o = opts||{};
      setPct(o.progress||0);
      setETA(o.etaSeconds);
      modal.style.display = 'flex';
    },
    hide: function(){
      if (modal) modal.style.display = 'none';
    },
    setProgress: function(n){ ensureDOM(); setPct(n); },
    setETA: function(sec){ ensureDOM(); setETA(sec); }
  };
})();

</script>
<!-- Lsv1 deferral gate v2: paint first, re-fire click, auto-close on network quiet -->
<script>
(function(){
  if (window.__Lsv1GateV2) return; window.__Lsv1GateV2 = true;

  // Yield 2 frames
  const nextPaint = () => new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

  // Session tracker for run
  const Session = {
    active: false,
    fetches: 0,
    xhrs: 0,
    lastSettle: 0,
    startedAt: 0,
    quietTimer: null,
    restore: null,
  };

  function looksLikeRun(el){
    if (!el) return false;
    try{
      const id  = (el.id||'').toLowerCase();
      const cls = (el.className||'').toString().toLowerCase();
      const txt = (el.innerText||el.textContent||'').replace(/\\s+/g,' ').trim().toLowerCase();
      if (id==='runbtn') return true;
      if (/(^|\\s)run[-_\\s]?matching(\\s|$)/.test(id) || /(run[-_\\s]?matching)/.test(cls)) return true;
      if (txt && txt.includes('run') && txt.includes('matching')) return true;
      if (el.hasAttribute && el.hasAttribute('data-run-matching')) return true;
    }catch(e){}
    return false;
  }

  function startSession(){
    if (Session.active) return;
    Session.active = true;
    Session.fetches = 0;
    Session.xhrs = 0;
    Session.lastSettle = performance.now();
    Session.startedAt = performance.now();

    // Show loader and paint
    try { MailTraceLoader.show({progress: 0}); } catch(_){}
    // Force visible style in case CSS is slow
    try { const m = document.getElementById('mailtrace-modal'); if (m) m.style.display = 'block'; } catch(_){}

    // Instrument fetch + XHR
    const origFetch = window.fetch;
    const origOpen = XMLHttpRequest.prototype.open;
    const origSend = XMLHttpRequest.prototype.send;

    window.fetch = function(){
      if (Session.active) Session.fetches++;
      const p = origFetch.apply(this, arguments);
      if (p && typeof p.finally === 'function'){
        p.finally(() => { if (Session.active) { Session.fetches = Math.max(0, Session.fetches-1); Session.lastSettle = performance.now(); } });
      } else {
        // unknown; decrement after a tick
        setTimeout(() => { if (Session.active) { Session.fetches = Math.max(0, Session.fetches-1); Session.lastSettle = performance.now(); }}, 0);
      }
      return p;
    };

    XMLHttpRequest.prototype.open = function(){ this.__mtTracked = true; return origOpen.apply(this, arguments); };
    XMLHttpRequest.prototype.send = function(){
      if (Session.active && this.__mtTracked) Session.xhrs++;
      this.addEventListener('loadend', function(){ if (Session.active && this.__mtTracked) { Session.xhrs = Math.max(0, Session.xhrs-1); Session.lastSettle = performance.now(); } });
      return origSend.apply(this, arguments);
    };

    Session.restore = function(){
      window.fetch = origFetch;
      XMLHttpRequest.prototype.open = origOpen;
      XMLHttpRequest.prototype.send = origSend;
    };

    // Close when network is quiet for 800ms after at least one network call or after minimum duration
    const QUIET_MS = 800;
    const MIN_OPEN_MS = 600; // keep popup at least 0.6s so it's noticeable
    Session.quietTimer = setInterval(() => {
      if (!Session.active) return;
      const now = performance.now();
      const openLongEnough = now - Session.startedAt > MIN_OPEN_MS;
      const quiet = (Session.fetches + Session.xhrs) === 0 && (now - Session.lastSettle) > QUIET_MS;
      if (openLongEnough && quiet){
        stopSession(true);
      }
    }, 200);
  }

  function stopSession(ok){
    if (!Session.active) return;
    Session.active = false;
    if (Session.quietTimer) { clearInterval(Session.quietTimer); Session.quietTimer = null; }
    try { Session.restore && Session.restore(); } catch(_){}
    try { MailTraceLoader.setProgress(100); } catch(_){}
    try { window.onMatchingDone && window.onMatchingDone(); } catch(_){}
    try { MailTraceLoader.hide(); } catch(_){}
  }

  // Manual close API for your app (optional)
  window.matchingDone = function(){ stopSession(true); };
  window.addEventListener('matching:done', function(){ stopSession(true); });

  // Backstop: hard close after 45s
  setInterval(function(){
    if (!Session.active) return;
    const now = performance.now();
    if (now - Session.startedAt > 45000) stopSession(false);
  }, 5000);

  // Deferral gate
  let gateOpen = false;
  document.addEventListener('click', function(ev){
    if (gateOpen) return; // allow synthetic click
    const el = ev.target && ev.target.closest ? ev.target.closest('button, a, [role=\"button\"], [data-run-matching], #runBtn') : null;
    if (!looksLikeRun(el)) return;

    ev.preventDefault();
    ev.stopImmediatePropagation();
    startSession();
    nextPaint().then(() => {
      // Re-fire original click so your handler runs unchanged
      gateOpen = true;
      try {
        el.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true, view: window }));
      } finally {
        setTimeout(() => { gateOpen = false; }, 0);
      }
    });
  }, true);
})();
</script>
<meta charset="utf-8"/>
<title>MailTrace — Modular Dashboard (v19.4)</title>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<style>
    :root{ --bg:#0b1220; --card:#111827; --ink:#e5eef9; --muted:#9fb2c8; --accent:#60a5fa; --line:#233049; 
  --col-mail-addr: 240px;
  --col-mail-unit: 84px;
  --col-crm-addr:  240px;
  --col-crm-unit:  84px;
  --col-city:      160px;
  --col-state:     72px;
  --col-zip:       108px;
  --col-maildates: 260px;
  --col-crmdate:   130px;
  --col-amount:    120px;
  --col-conf:      110px;
  --col-notes:     300px;
}
    *{ box-sizing:border-box }
    body{ margin:0; font-family:system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:var(--bg); color:var(--ink); }
    header{ display:flex; align-items:center; gap:12px; padding:14px 18px; border-bottom:1px solid var(--line); position:sticky; top:0; background:rgba(11,18,32,.9); backdrop-filter: blur(6px); }
    header .brand{ font-weight:600; letter-spacing:.3px }
    .wrap{ max-width:1100px; margin:0 auto; padding:18px }
    .row{ display:flex; gap:16px; flex-wrap:wrap }
    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:14px 16px; }
    .kpi{ min-width:140px; text-align:center }
    .kpi .v{ font-size:22px; font-weight:700; }
    .kpi .l{ font-size:12px; color:var(--muted) }
    .section{ margin-top:18px }
    label.small{ font-size:12px; color:var(--muted) }
    input[type="file"]{ display:block; margin:6px 0 10px 0 }
    select, input[type="checkbox"]{ margin-left:6px }
    button{ background:#2563eb; color:#fff; border:none; padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer }
    button:disabled{ opacity:.5; cursor:not-allowed }
    .err{ display:none; background:#3b0f12; border:1px solid #ef4444; color:#fecaca; padding:8px 10px; border-radius:10px; margin:10px 0 }
    table{ width:100%; border-collapse:collapse; font-size:13px }
    th,td{ border-bottom:1px solid var(--line); padding:8px 6px; text-align:left }
    th{ color:var(--muted); font-weight:600; }
    canvas{ width:100%; height:260px; display:block; }
    .right{ margin-left:auto }
    .muted{ color:var(--muted) }
    .yoy{ display:flex; align-items:center; gap:8px; font-size:12px; color:var(--muted) }
    /* Right-align Amount & Confidence columns in Summary */
    #cmp-summary td:nth-child(10), #cmp-summary th:nth-child(10),
    #cmp-summary td:nth-child(11), #cmp-summary th:nth-child(11) { text-align: right; }

/* Summary column sizing (roomier, horizontal scroll supported) */
#cmp-summary th:nth-child(1), #cmp-summary td:nth-child(1) { min-width: var(--col-mail-addr); }
#cmp-summary th:nth-child(2), #cmp-summary td:nth-child(2) { min-width: var(--col-mail-unit); text-align:center; }
#cmp-summary th:nth-child(3), #cmp-summary td:nth-child(3) { min-width: var(--col-crm-addr); }
#cmp-summary th:nth-child(4), #cmp-summary td:nth-child(4) { min-width: var(--col-crm-unit); text-align:center; }
#cmp-summary th:nth-child(5), #cmp-summary td:nth-child(5) { min-width: var(--col-city); }
#cmp-summary th:nth-child(6), #cmp-summary td:nth-child(6) { min-width: var(--col-state); text-align:center; }
#cmp-summary th:nth-child(7), #cmp-summary td:nth-child(7) { min-width: var(--col-zip); text-align:center; }
#cmp-summary th:nth-child(8), #cmp-summary td:nth-child(8) { min-width: var(--col-maildates); }
#cmp-summary th:nth-child(9), #cmp-summary td:nth-child(9) { min-width: var(--col-crmdate); }
#cmp-summary th:nth-child(10), #cmp-summary td:nth-child(10) { min-width: var(--col-amount); text-align:right; }
#cmp-summary th:nth-child(11), #cmp-summary td:nth-child(11) { min-width: var(--col-conf);   text-align:right; }
#cmp-summary th:nth-child(12), #cmp-summary td:nth-child(12) { min-width: var(--col-notes); }

#cmp-summary .table-wrap { height: 520px; overflow-y: auto; overflow-x: auto; scrollbar-gutter: stable both-edges; -webkit-overflow-scrolling: touch; display:block; position:relative; }
    /* Scrollable Summary + sticky header */
    #cmp-summary thead th { position: sticky; top: 0; background: var(--card); z-index: 3; box-shadow: 0 1px 0 0 var(--line); }
    #cmp-summary table { border-collapse: separate; border-spacing: 0; width: max-content; min-width: 1400px; table-layout: fixed; }
  
/* Top Cities/ZIPs: show top 5, scroll to 10 */
#cmp-top .topwrap { max-height: 170px; overflow-y: auto; overflow-x: hidden; }
#cmp-top thead th { position: sticky; top: 0; background: var(--card); z-index: 1; }
        
/* summary floating head */
#cmp-summary .floating-head { position: sticky; top: 0; left: 0; z-index: 6; background: var(--card); }
#cmp-summary .floating-head thead th { background: var(--card); border-bottom: 1px solid var(--line); }
#cmp-summary .table-wrap { position: relative; } 

/* Ensure floating header table uses fixed layout and matching spacing */
#cmp-summary table.floating-head { 
  table-layout: fixed; 
  border-collapse: separate; 
  border-spacing: 0; 
}



/* Confidence color coding */
:root{
  --conf-green: #16a34a; /* green-600 */
  --conf-yellow: #d97706; /* amber-600 */
  --conf-red: #dc2626; /* red-600 */
}
#cmp-summary td.conf-green, #cmp-summary td.conf.conf-green { color: var(--conf-green) !important; font-weight: 600; }
#cmp-summary td.conf-yellow, #cmp-summary td.conf.conf-yellow { color: var(--conf-yellow) !important; font-weight: 600; }
#cmp-summary td.conf-red, #cmp-summary td.conf.conf-red { color: var(--conf-red) !important; font-weight: 600; }


/* Top lists: column sizing + centered numeric columns */
.topwrap table[data-kind="cities"],
.topwrap table[data-kind="zips"]{ table-layout: fixed; width: 100%; }
.topwrap table[data-kind="cities"] th:first-child,
.topwrap table[data-kind="cities"] td:first-child{ width: 140px; }
.topwrap table[data-kind="zips"] th:first-child,
.topwrap table[data-kind="zips"] td:first-child{ width: 140px; }

</style>
<style id="mt-legend-style">
  .mt-legend{margin-top:6px; display:flex; align-items:center; gap:14px; flex-wrap:wrap; font:12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; color:#cbd5e1}
  .mt-legend .item{display:flex; align-items:center; gap:6px;}
  .mt-legend .swatch{width:14px; height:3px; border-radius:2px; background:#94a3b8}
  .mt-legend .swatch.dash{border-bottom:3px dashed currentColor; background:transparent; height:0; width:18px;}
  .mt-legend .hint{opacity:.8}
</style>
<style>
/* === Column Mapper Modal (scoped) === */
#mtMapperOverlay{position:fixed; inset:0; background:rgba(5,12,20,.55); display:none; align-items:center; justify-content:center; z-index:9999;}
#mtMapperModal{background:#0f172a; color:#e5eef9; border:1px solid rgba(255,255,255,.06); border-radius:16px; width:min(980px, 94vw); max-height:86vh; overflow:auto; box-shadow:0 24px 80px rgba(0,0,0,.4)}
#mtMapperModal header{display:flex; align-items:center; justify-content:space-between; padding:14px 18px; border-bottom:1px solid rgba(255,255,255,.06); position:sticky; top:0; background:#0f172a}
#mtMapperModal header h3{margin:0; font-size:18px}
#mtMapperModal .body{padding:16px 18px}
#mtMapperModal .grid{display:grid; grid-template-columns:1.2fr 1.2fr; gap:14px 20px}
#mtMapperModal .col{background:#0b1220; border:1px solid rgba(255,255,255,.05); border-radius:12px; padding:12px}
#mtMapperModal .col h4{margin:.2rem 0 .6rem; font-size:14px; opacity:.9}
#mtMapperModal .row{display:grid; grid-template-columns:1.1fr 1.6fr; gap:10px; align-items:center; padding:6px 0; border-bottom:1px dashed rgba(255,255,255,.06)}
#mtMapperModal .row:last-child{border-bottom:none}
#mtMapperModal label{font-size:13px; color:#9fb2c8}
#mtMapperModal select{background:#0f172a; color:#e5eef9; border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:8px 10px; font-size:13px}
#mtMapperModal .samples{font-size:12px; opacity:.85; margin-top:6px; line-height:1.2}
#mtMapperModal .req{color:#f4b400; font-size:12px; margin-left:6px}
#mtMapperModal .missing{color:#f87171; font-weight:600}
#mtMapperModal footer{display:flex; gap:10px; justify-content:flex-end; padding:14px 18px; border-top:1px solid rgba(255,255,255,.06); position:sticky; bottom:0; background:#0f172a}
#mtMapperModal .btn{background:#1f2937; color:#e5eef9; border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:.6rem 1rem; font-weight:700; cursor:pointer}
#mtMapperModal .btn.primary{background:#16a34a; border-color:transparent; color:#fff}
#mtMapperModal .btn.ghost{background:transparent; border-color:rgba(255,255,255,.12)}
#mtMapperHelp{font-size:12px; color:#9fb2c8; margin:0 0 10px}
</style>
<style>
/* === Mapping QA UI === */
#mtMapControls{display:flex; gap:.5rem; align-items:center; margin:.5rem 0 0;}
#mtMapControls .linkbtn{background:transparent; border:1px solid rgba(255,255,255,.15); padding:.35rem .6rem; border-radius:10px; cursor:pointer; font-weight:700}
#mtMapControls .linkbtn:hover{background:rgba(255,255,255,.06)}
#mtWarn{display:none; margin:.75rem 0; padding:.75rem 1rem; border-radius:12px; border:1px solid rgba(250,204,21,.2); background:rgba(250,204,21,.08); color:#fde68a}
#mtWarn h4{margin:.2rem 0 .4rem; font-size:14px}
#mtWarn ul{margin:.25rem 0 .6rem 1rem; padding:0}
#mtWarn li{margin:.15rem 0; font-size:13px}
#mtWarn .actions{display:flex; gap:.5rem}
#mtWarn .actions .btn{background:#1f2937; color:#e5eef9; border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:.45rem .8rem; font-weight:700; cursor:pointer}
#mtWarn .actions .btn.primary{background:#16a34a; color:white; border-color:transparent}
</style>
<style>
/* v6: hide legacy Reset Mapping button; consolidated into modal */
#mtMapControls #mtResetMap{ display:none !important; }
</style>
<style>
/* v8: hide legacy Auto‑map button (auto-mapping now runs on open) */
#mtMapperAuto{ display:none !important; }
</style>
<style>
/* v9: prominent popup for missing required mappings */
#mtPopupOverlay{position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:10000;}
#mtPopup{background:#111827; color:#f9fafb; border:1px solid rgba(255,255,255,.12); border-radius:16px; width:min(620px, 92vw); box-shadow:0 20px 70px rgba(0,0,0,.45)}
#mtPopup header{display:flex; align-items:center; justify-content:space-between; padding:14px 18px; border-bottom:1px solid rgba(255,255,255,.08)}
#mtPopup header h3{margin:0; font-size:18px}
#mtPopup .body{padding:16px 18px}
#mtPopup .body ul{margin:.25rem 0 .5rem 1rem; padding:0}
#mtPopup .body li{margin:.25rem 0; font-size:14px}
#mtPopup footer{display:flex; gap:10px; justify-content:flex-end; padding:14px 18px; border-top:1px solid rgba(255,255,255,.08)}
#mtPopup .btn{background:#1f2937; color:#e5eef9; border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:.55rem 1rem; font-weight:700; cursor:pointer}
#mtPopup .btn.primary{background:#dc2626; border-color:transparent; color:#fff}
/* highlight missing selects */
.mt-missing { outline:2px solid #dc2626 !important; box-shadow:0 0 0 3px rgba(220,38,38,.3); }
@keyframes mt-shake { 10%, 90% { transform: translateX(-1px);} 20%, 80% { transform: translateX(2px);} 30%, 50%, 70% { transform: translateX(-4px);} 40%, 60% { transform: translateX(4px);} }
.mt-shake { animation: mt-shake .45s ease-in-out both; }
</style>
<style id="mtMapper_v11_fix">
/* Ensure sticky header/footer always sit above content and samples don't bleed over */
#mtMapperModal header{position:sticky; top:0; background:#0f172a; z-index:10;
  box-shadow:0 1px 0 rgba(255,255,255,.06), 0 8px 18px rgba(0,0,0,.35);}
#mtMapperModal footer{position:sticky; bottom:0; background:#0f172a; z-index:10;
  box-shadow:0 -1px 0 rgba(255,255,255,.06), 0 -8px 18px rgba(0,0,0,.35);}
/* When scrolling to a select, keep it clear of the sticky header */
#mtMapperModal .row select{scroll-margin-top:76px;}
/* Slight extra body padding to avoid tight edges under sticky areas */
#mtMapperModal .body{padding-top:18px; padding-bottom:18px;}
</style>
<!-- Minimal center patch: centers modal after it is shown (no other changes) -->
<script>
(function(){
  if (window.__MT_CenterPatch) return; window.__MT_CenterPatch = true;

  function centerModal(){
    try {
      var m = document.getElementById('mailtrace-modal');
      if (!m) return;
      m.style.position = 'fixed';
      m.style.left = '0';
      m.style.top = '0';
      m.style.right = '0';
      m.style.bottom = '0';
      m.style.display = 'flex';
      m.style.alignItems = 'center';
      m.style.justifyContent = 'center';
      m.style.margin = '0';
      if (!m.style.transform) m.style.transform = 'none';
    } catch(e){}
  }

  function install(){
    try {
      if (window.MailTraceLoader && typeof MailTraceLoader.show === 'function' && !MailTraceLoader.show.__mtCenterWrapped){
        var _show = MailTraceLoader.show.bind(MailTraceLoader);
        MailTraceLoader.show = function(opts){
          var r = _show(opts||{});
          requestAnimationFrame(centerModal);
          return r;
        };
        MailTraceLoader.show.__mtCenterWrapped = true;
      } else {
        setTimeout(install, 100);
      }
    } catch(e){}
  }
  install();
})();
</script>
<style id="v47-final-force">
/* V47 FINAL: force light background + tokens last */
:root{
  --blue:#0d2c54;
  --green:#4caf6d;
  --bg:#f3f7fb;
  --ink:#0b1d36;
  --muted:#5a6a82;
  --line:#e6edf5;
}
html, body{
  background:#f3f7fb !important;
  color:var(--blue) !important;
}
main, .container, .content, .dashboard, #app, .app, .page, .wrapper {
  background: transparent !important;
  box-shadow: none !important;
}
.section, .panel, .card, .table-wrap, .box, .cardlike {
  background:#ffffff !important;
  border:1px solid var(--line) !important;
  border-radius: 12px !important;
  box-shadow: 0 8px 20px rgba(13,44,84,.06) !important;
}
button, .btn, input[type="submit"] {
  background: var(--green) !important;
  color: #fff !important;
  border: 0 !important;
  border-radius: 8px !important;
  font-weight: 700 !important;
  padding: .55rem 1rem !important;
}
input[type="text"], input[type="email"], input[type="number"], input[type="file"],
select, textarea {
  background:#fff !important;
  color: var(--blue) !important;
  border:1px solid var(--line) !important;
  border-radius:6px !important;
  padding:.5rem .6rem !important;
}
table { border-collapse: collapse !important; width:100% !important; background:#fff !important; }
th, td { border-bottom:1px solid var(--line) !important; padding:.6rem .5rem !important; text-align:left !important; }
th { color:var(--blue) !important; font-weight:700 !important; }
td { color: var(--ink) !important; }
tr:nth-child(even) { background: #f8fbfe !important; }
#mailtrace-modal .mt-bar { background: rgba(76,175,109,.14) !important; }
#mailtrace-modal .mt-bar-fill { background: var(--green) !important; }
#mailtrace-modal .mt-label, #mailtrace-modal .mt-eta { color: var(--blue) !important; }
</style>
<script>
document.addEventListener('DOMContentLoaded', function(){
  document.documentElement.classList.remove('dark');
  document.body.classList.remove('dark');
  document.documentElement.removeAttribute('data-theme');
  document.body.removeAttribute('data-theme');
});
</script>
<style id="v47-headers-fix">
/* === V47 table header contrast fix === */
table thead, table thead tr, table thead th,
th[role="columnheader"], [role="columnheader"] {
  background: #ffffff !important;
  color: var(--blue) !important;
}
table thead th, th[role="columnheader"] {
  border-bottom: 1px solid var(--line) !important;
  font-weight: 700 !important;
}
/* Kill stray inline dark backgrounds on TH */
th[style*="background"], th[style*="background-color"] {
  background: #ffffff !important;
  color: var(--blue) !important;
}
/* Sticky header rows should stay light */
thead tr[style*="position: sticky"], thead th[style*="position: sticky"] {
  background: #ffffff !important;
}
/* Common data grid headers */
.ag-header, .ag-header-row, .ag-header-cell,
.dataTables_scrollHead, .dataTables_scrollHeadInner,
.grid-header, .table-header {
  background: #ffffff !important;
  color: var(--blue) !important;
  border-bottom: 1px solid var(--line) !important;
}
</style><style id="v47-topbar-fix">
/* === V47 topbar / toolbar contrast fix === */
header, .header, .topbar, .toolbar, .titlebar, .header-bar, .control-bar, .page-header, .section-header {
  background: transparent !important;
  color: var(--blue) !important;
  box-shadow: none !important;
  border: 0 !important;
}
/* Titles in these bars */
header h1, header h2, header h3,
.header h1, .header h2, .header h3,
.topbar h1, .topbar h2, .topbar h3,
.titlebar h1, .titlebar h2, .titlebar h3,
.header-bar h1, .header-bar h2, .header-bar h3,
.control-bar h1, .control-bar h2, .control-bar h3,
.page-header h1, .page-header h2, .page-header h3,
.section-header h1, .section-header h2, .section-header h3 {
  color: var(--blue) !important;
}

/* Any inline dark backgrounds on bars/titles */
header[style*="background"], .header[style*="background"],
.topbar[style*="background"], .toolbar[style*="background"],
.titlebar[style*="background"], .header-bar[style*="background"],
.control-bar[style*="background"], .page-header[style*="background"],
.section-header[style*="background"],
h1[style*="background"], h2[style*="background"], h3[style*="background"] {
  background: transparent !important;
  color: var(--blue) !important;
}

/* Action area (e.g., "Show YoY overlay" toggle) */
.header .actions, .topbar .actions, .toolbar .actions, .titlebar .actions,
.header-bar .actions, .control-bar .actions, .page-header .actions {
  background: transparent !important;
  color: var(--blue) !important;
}
/* Labels, switches, checkboxes in the bar */
.header label, .topbar label, .toolbar label, .titlebar label,
.header-bar label, .control-bar label, .page-header label, .section-header label {
  color: var(--blue) !important;
  background: transparent !important;
  font-weight: 600;
}
/* Secondary buttons in bar */
.header .btn.secondary, .topbar .btn.secondary, .toolbar .btn.secondary,
.titlebar .btn.secondary, .header-bar .btn.secondary, .control-bar .btn.secondary,
.page-header .btn.secondary {
  background: #eef5ef !important;
  color: var(--green) !important;
  border: 1px solid var(--green) !important;
}
/* Plain buttons/links */
.header .btn, .topbar .btn, .toolbar .btn, .titlebar .btn,
.header-bar .btn, .control-bar .btn, .page-header .btn,
.header a, .topbar a, .toolbar a, .titlebar a,
.header-bar a, .control-bar a, .page-header a {
  color: var(--blue) !important;
}

/* Sticky bars should inherit the light page bg if needed */
header[style*="position: sticky"], .topbar[style*="position: sticky"],
.toolbar[style*="position: sticky"], .titlebar[style*="position: sticky"],
.header-bar[style*="position: sticky"], .control-bar[style*="position: sticky"],
.page-header[style*="position: sticky"] {
  background: #f3f7fb !important;
}

/* Edge case: random spans/divs with inline dark bg in the title block */
.section-header [style*="background"], .page-header [style*="background"],
.titlebar [style*="background"], .toolbar [style*="background"] {
  background: transparent !important;
  color: var(--blue) !important;
}
</style><style id="v47-kpi-fix">
/* === V47 KPI tile contrast + typography fix === */
#cmp-kpis { background:#ffffff !important; }
#cmp-kpis .kpi { background: transparent !important; }
#cmp-kpis .l {
  color: var(--blue) !important;
  background: transparent !important;
  font-weight: 700 !important;
  font-size: .95rem !important;
  letter-spacing: .1px !important;
  opacity: .9 !important;
  margin-top: .25rem !important;
}
#cmp-kpis .v {
  color: var(--ink) !important;
  font-weight: 800 !important;
  font-size: 1.35rem !important;
}

/* If any inline dark background sneaks in on .l or ancestors, nuke it */
#cmp-kpis [style*="background"] { background: transparent !important; }
</style><style id="v47-advbtn-scope">
/* === Advanced KPIs button visibility (scoped to KPI card) === */
#cmp-kpis .mt-advbtn {
  appearance: none;
  display: inline-flex;
  align-items: center;
  gap: .4rem;
  background: var(--green) !important;
  color: #fff !important;
  border: 1px solid var(--green) !important;
  border-radius: 8px !important;
  padding: .55rem 1rem !important;
  font-weight: 700 !important;
  line-height: 1 !important;
  text-decoration: none !important;
  box-shadow: 0 8px 20px rgba(13,44,84,.06) !important;
}
#cmp-kpis .mt-advbtn svg, 
#cmp-kpis .mt-advbtn [class*="icon"] {
  fill: #fff !important;
  stroke: #fff !important;
  color: #fff !important;
}
#cmp-kpis .mt-advbtn:hover { filter: brightness(0.97); }
#cmp-kpis .mt-advbtn:active { transform: translateY(1px); }
#cmp-kpis .mt-advbtn:focus-visible { outline: 2px solid #0d2c54; outline-offset: 2px; }
</style><style id="v47-green-3d-buttons">
/* === MailTrace 3D Green Buttons (inspired by Lsv1 magnifying glass) === */
:root{
  /* add a slightly brighter & deeper green for gradient stops if not present */
  --green-hi: #6fd18a; /* highlight */
  --green:    #4caf6d; /* base */
  --green-de: #3c9e5d; /* deep */
  --green-lo: #2e8e51; /* shadow */
}

/* Target current green buttons across the app */
.btn-demo,
.formgrid button,
.mt-btn-advanced,
.btn.primary,
button.btn-primary,
.btn.green,
button[data-variant="primary"],
a[data-variant="primary"] {
  position: relative;
  color: #fff !important;
  border: 1px solid var(--green-de) !important;
  border-radius: 10px !important;
  font-weight: 800 !important;
  letter-spacing: .2px;
  text-decoration: none !important;
  /* layered gradient for subtle 3D */
  background:
    radial-gradient(120% 100% at 50% 0%, rgba(255,255,255,.22), rgba(255,255,255,0) 55%) no-repeat,
    linear-gradient(180deg, var(--green-hi) 0%, var(--green) 45%, var(--green-de) 100%) !important;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.35),
    inset 0 -1px 0 rgba(0,0,0,.08),
    0 6px 14px rgba(13,44,84,.10),
    0 2px 6px rgba(13,44,84,.10);
  transition: transform .05s ease, filter .15s ease, box-shadow .15s ease;
}

.btn-demo:hover,
.formgrid button:hover,
.mt-btn-advanced:hover,
.btn.primary:hover,
button.btn-primary:hover,
.btn.green:hover,
button[data-variant="primary"]:hover,
a[data-variant="primary"]:hover {
  filter: brightness(1.02);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.38),
    inset 0 -1px 0 rgba(0,0,0,.10),
    0 10px 18px rgba(13,44,84,.12),
    0 3px 8px rgba(13,44,84,.12);
}

.btn-demo:active,
.formgrid button:active,
.mt-btn-advanced:active,
.btn.primary:active,
button.btn-primary:active,
.btn.green:active,
button[data-variant="primary"]:active,
a[data-variant="primary"]:active {
  transform: translateY(1px);
  background:
    radial-gradient(120% 100% at 50% 0%, rgba(255,255,255,.18), rgba(255,255,255,0) 55%) no-repeat,
    linear-gradient(180deg, var(--green) 0%, var(--green-de) 55%, var(--green-lo) 100%) !important;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.25),
    inset 0 -1px 0 rgba(0,0,0,.12),
    0 4px 10px rgba(13,44,84,.10),
    0 1px 4px rgba(13,44,84,.10);
}

.btn-demo:disabled,
.formgrid button:disabled,
.mt-btn-advanced:disabled,
.btn.primary:disabled,
button.btn-primary:disabled,
.btn.green:disabled,
button[data-variant="primary"][disabled],
a[data-variant="primary"].disabled {
  opacity: .65 !important;
  cursor: not-allowed !important;
  filter: grayscale(.1);
}

/* Ensure icons inside stay white */
.btn-demo svg, .btn-demo [class*="icon"],
.formgrid button svg, .formgrid button [class*="icon"],
.mt-btn-advanced svg, .mt-btn-advanced [class*="icon"],
.btn.primary svg, .btn.primary [class*="icon"],
button.btn-primary svg, button.btn-primary [class*="icon"],
.btn.green svg, .btn.green [class*="icon"],
button[data-variant="primary"] svg, button[data-variant="primary"] [class*="icon"] {
  color: #fff !important; fill: #fff !important; stroke: #fff !important;
}
</style><style id="v47-cta-3d-style">
/* === 3D gradient for main CTAs (Run Matching, Edit Mapping, Show Advanced KPIs) === */
.mt-cta-3d {
  position: relative;
  color: #fff !important;
  border: 1px solid var(--green-de) !important;
  border-radius: 10px !important;
  font-weight: 800 !important;
  letter-spacing: .2px;
  text-decoration: none !important;
  background:
    radial-gradient(120% 100% at 50% 0%, rgba(255,255,255,.22), rgba(255,255,255,0) 55%) no-repeat,
    linear-gradient(180deg, var(--green-hi) 0%, var(--green) 45%, var(--green-de) 100%) !important;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.35),
    inset 0 -1px 0 rgba(0,0,0,.08),
    0 6px 14px rgba(13,44,84,.10),
    0 2px 6px rgba(13,44,84,.10);
  transition: transform .05s ease, filter .15s ease, box-shadow .15s ease;
}
.mt-cta-3d:hover {
  filter: brightness(1.02);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.38),
    inset 0 -1px 0 rgba(0,0,0,.10),
    0 10px 18px rgba(13,44,84,.12),
    0 3px 8px rgba(13,44,84,.12);
}
.mt-cta-3d:active { transform: translateY(1px); }
.mt-cta-3d:disabled, .mt-cta-3d[disabled] {
  opacity: .65 !important;
  cursor: not-allowed !important;
}
.mt-cta-3d svg, .mt-cta-3d [class*="icon"] { color:#fff !important; fill:#fff !important; stroke:#fff !important; }

/* Make sure inputs can show the gradient correctly */
input[type="button"].mt-cta-3d,
input[type="submit"].mt-cta-3d {
  -webkit-appearance: none;
  appearance: none;
}

/* Secondary/outline style for less-prominent actions (Edit mapping) */
.mt-cta-secondary {
  position: relative;
  background: #fff !important;
  color: var(--blue) !important;            /* #0d2c54 */
  border: 1px solid var(--line) !important; /* #e6edf5 */
  border-radius: 10px !important;
  font-weight: 700 !important;
  letter-spacing: .2px;
  text-decoration: none !important;
  box-shadow:
    0 2px 6px rgba(13,44,84,.06),
    inset 0 1px 0 rgba(255,255,255,.6);
  transition: transform .05s ease, filter .15s ease, box-shadow .15s ease, border-color .15s ease;
}
.mt-cta-secondary:hover {
  border-color: var(--green);
  box-shadow:
    0 4px 10px rgba(13,44,84,.08),
    inset 0 1px 0 rgba(255,255,255,.7);
}
.mt-cta-secondary:active { transform: translateY(1px); }
.mt-cta-secondary:disabled, .mt-cta-secondary[disabled] {
  opacity: .65 !important;
  cursor: not-allowed !important;
}
/* ensure icons in secondary adopt navy */
.mt-cta-secondary svg, .mt-cta-secondary [class*="icon"] { color: var(--blue) !important; fill: var(--blue) !important; stroke: var(--blue) !important; }

/* Inputs can show gradient correctly */
input[type="button"].mt-cta-3d,
input[type="submit"].mt-cta-3d {
  -webkit-appearance: none;
  appearance: none;
}
</style><style id="v47-modal-css">
/* === MailTrace Error Modal (brand) === */
#mt-modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(13,44,84,0.35);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
}
#mt-modal {
  width: min(520px, 92vw);
  background: #fff;
  color: var(--blue);
  border: 1px solid var(--line);
  border-radius: 14px;
  box-shadow: 0 24px 60px rgba(13,44,84,.18);
  transform: translateY(8px) scale(.98);
  opacity: 0;
  transition: transform .15s ease, opacity .15s ease;
}
#mt-modal.open {
  transform: translateY(0) scale(1);
  opacity: 1;
}
#mt-modal header {
  display: flex;
  align-items: center;
  gap: .6rem;
  padding: 14px 16px 8px;
  border-bottom: 1px solid var(--line);
}
#mt-modal header .dot {
  width: 12px; height: 12px; border-radius: 999px;
  background: linear-gradient(180deg, #6fd18a 0%, #4caf6d 55%, #3c9e5d 100%);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.6), 0 0 0 2px rgba(76,175,109,.15);
}
#mt-modal header h3 {
  margin: 0;
  font-size: 1.05rem;
  color: #0d2c54;
}
#mt-modal .content {
  padding: 14px 16px;
  font-size: .98rem;
  line-height: 1.45;
}
#mt-modal .content p { margin: .35rem 0; }
#mt-modal footer {
  display: flex;
  gap: .5rem;
  justify-content: flex-end;
  padding: 12px 16px 16px;
  border-top: 1px solid var(--line);
}
#mt-modal .btn {
  appearance: none;
  border-radius: 10px;
  border: 1px solid var(--line);
  padding: .55rem 1rem;
  font-weight: 700;
  cursor: pointer;
}
#mt-modal .btn-primary {
  color: #fff;
  border-color: #3c9e5d;
  background: linear-gradient(180deg, #6fd18a 0%, #4caf6d 45%, #3c9e5d 100%);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.35), 0 6px 14px rgba(13,44,84,.10);
}
#mt-modal .btn-primary:active { transform: translateY(1px); }
#mt-modal .btn-outline { color: #0d2c54; background:#fff; }
#mt-modal .hint {
  margin-top: .4rem;
  font-size: .9rem;
  color: #5a6a82;
}
#mt-modal-backdrop.show { display: flex; }
</style><link href="assets_v47_fix/v47-theme-force.css?v=20250930_170112" rel="stylesheet"/><script defer="True" src="assets_v47_fix/v47-theme-force.js?v=20250930_170112"></script><link href="assets/lsv1-loader.css?v=20250930_170112" rel="stylesheet"/><style>
.yoy-btn{position:absolute;right:12px;top:12px;padding:6px 10px;border:1px solid #e5e7eb;border-radius:10px;background:#fff;cursor:pointer;font-size:12px;color:#334155}
#panel-graph,.graph-card{position:relative}
</style>
<style>/* hide-strictness */ .strictness, #strictness, [data-section='strictness']{display:none!important}</style><style>
/* --- MailTrace Navbar (light) --- */
.mt-nav { position: sticky; top: 0; z-index: 40; background: #fff; border-bottom: 1px solid #ececec; }
.mt-nav .wrap { max-width: 1200px; margin: 0 auto; padding: 10px 16px;
  display: flex; align-items: center; justify-content: space-between; gap: 12px; }
.mt-nav .left { display: flex; align-items: center; gap: 12px; }
.mt-nav .right { display: flex; align-items: center; gap: 18px; }
.mt-nav a { text-decoration: none; color: #111; font-weight: 500; font-size: 14px; }
.mt-nav a.active { color: #0a66ff; }
.mt-nav .logo { display:flex; align-items:center; gap:10px; }
.mt-nav .logo img { height: 56px !important; max-height: 56px !important; width: auto; }
.mt-nav .hist { position: relative; }
.mt-nav .hist-btn { cursor: pointer; }
.mt-nav .hist-panel { position: absolute; right: 0; top: 28px; width: 320px; max-height: 360px; overflow:auto;
  background:#fff; border:1px solid #e5e5e5; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,0.08); padding:8px; display:none; }
.mt-nav .hist.open .hist-panel { display:block; }
.mt-nav .hist-item { padding:8px 10px; border-radius:6px; display:flex; justify-content:space-between; gap:10px; font-size:13px; }
.mt-nav .hist-item:hover { background:#f6f7f9; }
.mt-nav .hist-empty { padding:10px; color:#777; font-size:13px; }
</style>
<style>
.mt-nav .logo img { height: 64px !important; max-height: 64px !important; width: auto; }
.mt-nav .wrap { padding: 6px 16px !important; }
</style>
</head>
<body>
<nav class="mt-nav">
  <div class="wrap">
    <div class="left logo">
      <a href="/dashboard">
        <img src="/static/img/logo.png" alt="MailTrace logo" />
      </a>
    </div>
    <div class="right">
      <a href="/dashboard" id="mt-link-dash">Dashboard</a>
      <a href="/static/map.html" id="mt-link-map">Map</a>
      <div class="hist" id="mt-hist">
        <a class="hist-btn">History ▾</a>
        <div class="hist-panel">
          <div class="hist-empty" id="mt-hist-empty">Loading…</div>
          <div id="mt-hist-list"></div>
        </div>
      </div>
    </div>
  </div>
</nav>

<header>
<div class="brand">mailtrace • modular dashboard <span style="font-size:12px;color:#9fb2c8">v19.4</span></div>
<div class="right yoy">
<label><input checked="" id="yoyToggle" type="checkbox"/> Show YoY overlay</label>
</div>
</header>
<div class="wrap">
<div class="err" id="err"><b>JavaScript error:</b> <span id="errmsg"></span></div>
<div class="row">
<div class="card" style="flex:1 1 380px; min-width:340px">
<label class="small">Mail CSV</label>
<input accept=".csv" id="mailCsv" type="file"/>
<label class="small">CRM CSV</label>
<input accept=".csv" id="crmCsv" type="file"/>
<button id="runBtn">Run matching</button>


</div>
<div class="card row" id="cmp-kpis" style="flex:3 1 520px; min-width:320px; align-items:center; justify-content:space-around">
<div class="kpi"><div class="v" data-kpi="mail"></div><div class="l">Total Mail</div></div>
<div class="kpi"><div class="v" data-kpi="uniqmail"></div><div class="l">Unique Mail Addresses</div></div>
<div class="kpi"><div class="v" data-kpi="crm"></div><div class="l">Total Jobs</div></div>
<div class="kpi"><div class="v" data-kpi="matches"></div><div class="l">Matches</div></div>
<div class="kpi"><div class="v" data-kpi="rate"></div><div class="l">Match Rate</div></div>
<div class="kpi"><div class="v" data-kpi="revenue"></div><div class="l">Match Revenue</div></div>
</div>
</div>
<div class="section card" id="cmp-graph">
<canvas height="260" id="chart" width="1000"></canvas>
</div>
<div class="row section" id="cmp-top">
<div class="card" style="flex:1 1 360px">
<div style="font-weight:600;margin-bottom:8px">Top Cities</div>
<div class="table-wrap topwrap"><table data-kind="cities"><thead><tr><th>City</th><th style="text-align:center">Total Matches</th><th style="text-align:center">Match Rate</th></tr></thead><tbody data-top="cities"></tbody></table></div>
</div>
<div class="card" style="flex:1 1 360px">
<div style="font-weight:600;margin-bottom:8px">Top ZIPs</div>
<div class="table-wrap topwrap"><table data-kind="zips"><thead><tr><th>ZIP</th><th style="text-align:center">Total Matches</th><th style="text-align:center">Match Rate</th></tr></thead><tbody data-top="zips"></tbody></table></div>
</div>
</div>
<div class="section card" id="cmp-summary">
<div style="font-weight:600;margin-bottom:8px">Summary</div>
<div class="table-wrap"><table><colgroup id="sum-cols"></colgroup><thead><tr>
<th>Mail Address 1</th><th>Mail Unit</th><th>CRM Address 1</th><th>CRM Unit</th>
<th>City</th><th>State</th><th>ZIP</th><th>Mail Dates</th><th>CRM Date</th><th>Amount</th><th>Confidence</th><th>Notes</th>
</tr></thead><tbody data-summary="rows"></tbody></table></div>
</div>
</div>
<script>
function showError(msg){ const b=document.getElementById('err'); const m=document.getElementById('errmsg'); b.style.display='block'; m.textContent = msg; }
function parseCSV(text){
  const rows = []; let i=0, field='', row=[], inQ=false;
  while(i<text.length){
    const c = text[i];
    if(inQ){
      if(c==='"' && text[i+1]==='"'){ field+='"'; i+=2; continue; }
      if(c==='"'){ inQ=false; i++; continue; }
      field+=c; i++; continue;
    }else{
      if(c==='"'){ inQ=true; i++; continue; }
      if(c===','){ row.push(field); field=''; i++; continue; }
      if(c==='\n'){ row.push(field); rows.push(row); row=[]; field=''; i++; continue; }
      if(c==='\r'){ i++; continue; }
      field+=c; i++; continue;
    }
  }
  row.push(field); rows.push(row);
  const header = rows.shift().map(h=>h.trim());
  const out = rows.filter(r=>r.some(x=>x && x.trim()!=='')).map(r=>{ const o={}; for(let j=0;j<header.length;j++){ o[header[j]]=(r[j]??'').trim(); } return o; });
  return {header, rows: out};
}
function nz(x){ return (x||'').trim(); }
function stripUnit(addr){ return (nz(addr)).replace(/\b(?:unit|apt|apartment|suite|ste|#)\s*[A-Za-z0-9\-]+\b/ig,''); }
const DIRS={"north":"n","south":"s","east":"e","west":"w","northeast":"ne","northwest":"nw","southeast":"se","southwest":"sw"};
const SUF ={"street":"st","st.":"st","avenue":"ave","ave.":"ave","road":"rd","rd.":"rd","boulevard":"blvd","blvd.":"blvd",
            "parkway":"pkwy","pkwy.":"pkwy","place":"pl","pl.":"pl","lane":"ln","ln.":"ln","drive":"dr","dr.":"dr",
            "court":"ct","ct.":"ct","highway":"hwy","hwy.":"hwy","circle":"cir","cir.":"cir","terrace":"ter","ter.":"ter","park":"park"};
function normStreet(a1,a2){
  let s=(nz(a1)+' '+nz(a2)).trim();
  s=stripUnit(s); s=s.replace(/\./g,' ').replace(/[^A-Za-z0-9\s\-]/g,' ').replace(/\s+/g,' ').trim().toLowerCase();
  return s.split(' ').filter(Boolean).map(t=>SUF[DIRS[t]||t]||(DIRS[t]||t)).join(' ');
}
function normStreetCollapsed(a1,a2){ return normStreet(a1,a2).replace(/\s+/g,''); }
function normCity(c){ return nz(c).replace(/\s+/g,' ').trim().replace(/\b\w/g, ch=>ch.toUpperCase()); }
function zip5(z){ return (nz(z).match(/\d/g)||[]).join('').slice(0,5); }
function extractUnit(a1,a2){ const s=(nz(a1)+' '+nz(a2)).trim(); const m=s.match(/\b(?:unit|apt|apartment|suite|ste|#)\s*([A-Za-z0-9\-]+)\b/i); return m? m[1].toUpperCase() : ''; }
function normKey(a1,a2,city,state,zip){ return [normStreet(a1,a2), normCity(city), nz(state).toUpperCase(), zip5(zip)].join('|'); }
function normKeyCollapsed(a1,a2,city,state,zip){ return [normStreetCollapsed(a1,a2), normCity(city), nz(state).toUpperCase(), zip5(zip)].join('|'); }

// Month and Date helpers
function monthKey(s){
  s=nz(s);
  let m = s.match(/^(\d{2})-(\d{2})-(\d{2,4})$/);
  if(m){ const mm=m[1], yy=(m[3].length===2? '20'+m[3]: m[3]); return `${yy}-${mm}`; }
  m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if(m){ return `${m[1]}-${m[2]}`; }
  return null;
}
function dateKey(s){
  s = (s||"").trim();
  let m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{2,4})$/);
  if(m){
    let mm = parseInt(m[1],10), dd = parseInt(m[2],10), yy = parseInt(m[3],10);
    if(yy < 100) yy = 2000 + yy;
    return yy*10000 + mm*100 + dd;
  }
  m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/);
  if(m){ return parseInt(m[1],10)*10000 + parseInt(m[2],10)*100 + parseInt(m[3],10); }
  const t = Date.parse(s);
  if(!isNaN(t)){ const d = new Date(t); return d.getFullYear()*10000 + (d.getMonth()+1)*100 + d.getDate(); }
  return Number.MAX_SAFE_INTEGER;
}

// Display helpers
function pad2(n){ return String(n).padStart(2,'0'); }
function parseDateParts(s){
  s = (s||"").trim();
  let m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{2,4})$/);
  if(m){ let mm=parseInt(m[1],10), dd=parseInt(m[2],10), yy=parseInt(m[3],10); if(yy<100) yy=2000+yy; return {y:yy,m:mm,d:dd}; }
  m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/]?(\d{1,2})$/);
  if(m){ return {y:parseInt(m[1],10), m:parseInt(m[2],10), d:parseInt(m[3],10)}; }
  const t = Date.parse(s);
  if(!isNaN(t)){ const d=new Date(t); return {y:d.getFullYear(), m:d.getMonth()+1, d:d.getDate()}; }
  return null;
}
function fmtDate(s){ const p=parseDateParts(s); return p? `${pad2(p.m)}-${pad2(p.d)}-${p.y}` : (s||"—"); }
function fmtDates(arr){ if(!arr||!arr.length) return "—"; return arr.map(fmtDate).join(", "); }
function fmtAmount(s){
  const t = (s||"").replace(/[^0-9.\-]/g,""); if(!t) return "—";
  const v = Number(t); if(!isFinite(v)) return s;
  try{ return new Intl.NumberFormat('en-US', {style:'currency', currency:'USD', maximumFractionDigits:2}).format(v); }
  catch(e){ return "$" + v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ","); }
}

// Fuzzy helpers + config (toggle/strictness controls)
function houseNumberFrom(normStreetStr){ const toks=(normStreetStr||"").trim().split(/\s+/); const first=toks[0]||""; return /^\d+$/.test(first) ? first : ""; }
function streetNameOnly(normStreetStr){ const toks=(normStreetStr||"").trim().split(/\s+/); if(toks.length && /^\d+$/.test(toks[0])) toks.shift(); return toks.join(" "); }
function collapseLetters(s){ return (s||"").replace(/\s+/g,""); }
function editDistance(a,b){ a=String(a||""); b=String(b||""); const n=a.length, m=b.length; if(!n) return m; if(!m) return n;
  const dp = new Array(n+1); for(let i=0;i<=n;i++){ dp[i]=new Array(m+1); dp[i][0]=i; } for(let j=0;j<=m;j++){ dp[0][j]=j; }
  for(let i=1;i<=n;i++){ const ai=a.charCodeAt(i-1); for(let j=1;j<=m;j++){ const cost=(ai===b.charCodeAt(j-1))?0:1; dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost); } } return dp[n][m];
}
function simRatio(a,b){ const d=editDistance(a,b); const L=Math.max(a.length,b.length)||1; return 1 - d/L; }
function getFuzzyConfig(){
  const enabled = document.getElementById('fuzzyToggle')?.checked;
  const mode = document.getElementById('fuzzyMode')?.value || 'standard';
  let maxEdits=2, minSim=0.85, base=95, perEdit=4, floor=60;
  if(mode==='strict'){ maxEdits=1; minSim=0.90; base=96; perEdit=5; floor=70; }
  else if(mode==='loose'){ maxEdits=3; minSim=0.80; base=94; perEdit=3; floor=55; }
  return { enabled, maxEdits, minSim, base, perEdit, floor };
}

// ========================= State computation =========================
function computeState(mailText, crmText){
  const mail = parseCSV(mailText);
  const crm  = parseCSV(crmText);
  const SYN = {
    address1: ["address 1","address1","street","street address","addr1"],
    address2: ["address 2","address2","apt","unit","suite","addr2"],
    city:     ["city","town"],
    state:    ["state","province","st"],
    zip:      ["zip","zipcode","postal_code","postcode","zip code"],
    mail_date:["mail date","sent_date","date sent","date"],
    crm_date: ["job date","crm date","date"],
    amount:   ["job value","amount","crm amount","value","invoice amount"]
  };
  const pick=(cols,...keys)=>{ const lower=cols.map(c=>c.toLowerCase()); for(const k of keys){ const i=lower.indexOf(k); if(i!==-1)return cols[i]; } return null; };

  
  const mapping = arguments[2] || (function(){ try{ return JSON.parse(localStorage.getItem("mt_column_mapping_v1")||"{}"); }catch{ return {}; } })();

  function pickMap(side, key, autoPick){
    const v = (mapping?.[side]?.[key]) || "";
    return v && (side==="mail" ? mail.header.includes(v) : crm.header.includes(v)) ? v : autoPick;
  }

  const M_ADDR1 = pickMap('mail','address1', pick(mail.header, ...SYN.address1));
  const M_ADDR2 = pickMap('mail','address2', pick(mail.header, ...SYN.address2));
  const M_CITY  = pickMap('mail','city',     pick(mail.header, ...SYN.city));
  const M_STATE = pickMap('mail','state',    pick(mail.header, ...SYN.state));
  const M_ZIP   = pickMap('mail','zip',      pick(mail.header, ...SYN.zip));
  const M_DATE  = pickMap('mail','mail_date',pick(mail.header, ...SYN.mail_date));

  const C_ADDR1 = pickMap('crm','address1',  pick(crm.header, ...SYN.address1));
  const C_ADDR2 = pickMap('crm','address2',  pick(crm.header, ...SYN.address2));
  const C_CITY  = pickMap('crm','city',      pick(crm.header, ...SYN.city));
  const C_STATE = pickMap('crm','state',     pick(crm.header, ...SYN.state));
  const C_ZIP   = pickMap('crm','zip',       pick(crm.header, ...SYN.zip));
  const C_DATE  = pickMap('crm','crm_date',  pick(crm.header, ...SYN.crm_date));
  const C_AMT   = pickMap('crm','amount',    pick(crm.header, ...SYN.amount));

  if(!M_ADDR1 || !C_ADDR1){
    const payload = {
      mailHeaders: mail.header,
      crmHeaders: crm.header,
      mailRows: mail.rows.slice(0, 200),
      crmRows: crm.rows.slice(0, 200),
      SYN,
      auto: {
        mail: { address1:M_ADDR1, address2:M_ADDR2, city:M_CITY, state:M_STATE, zip:M_ZIP, mail_date:M_DATE },
        crm:  { address1:C_ADDR1, address2:C_ADDR2, city:C_CITY, state:C_STATE, zip:C_ZIP, crm_date:C_DATE, amount:C_AMT }
      }
    };
    throw new ColumnMappingError(payload);
  }


  const mailExt = mail.rows.map(r=>({ ...r, _key:normKey(r[M_ADDR1], r[M_ADDR2], r[M_CITY], r[M_STATE], r[M_ZIP]), _unit:extractUnit(r[M_ADDR1], r[M_ADDR2]) }));
  const crmExt  = crm.rows.map(r =>({ ...r, _key:normKey(r[C_ADDR1], r[C_ADDR2], r[C_CITY], r[C_STATE], r[C_ZIP]), _unit:extractUnit(r[C_ADDR1], r[C_ADDR2]) }));

  const byKey = {}; const byKeyCollapsed = {}; const byZipState = {};
  for(const r of mailExt){
    (byKey[r._key] ||= []).push(r);
    const ck = normKeyCollapsed(r[M_ADDR1], r[M_ADDR2], r[M_CITY], r[M_STATE], r[M_ZIP]);
    (byKeyCollapsed[ck] ||= []).push(r);
    const zsk = zip5(r[M_ZIP])+"|"+nz(r[M_STATE]).toUpperCase();
    (byZipState[zsk] ||= []).push(r);
  }

  const md = {}; if(M_DATE){ for(const r of mailExt){ const d=nz(r[M_DATE]); if(!d) continue; (md[r._key] ||= new Set()).add(d); } }

  function streetTokenDiffs(crmA1, mailA1){
const ctoks = nz(crmA1).split(/\s+/), mtoks = nz(mailA1).split(/\s+/);
  const n = Math.min(ctoks.length, mtoks.length);
  const seen = new Set(); const diffs=[];
  function tokKind(tok){
    const t = (tok||'').replace(/\W+/g,'').toLowerCase();
    if(/^\d+$/.test(t)) return ["num", t];
    const dirMap = {"n":["n","north"],"s":["s","south"],"e":["e","east"],"w":["w","west"],"ne":["ne","northeast"],"nw":["nw","northwest"],"se":["se","southeast"],"sw":["sw","southwest"]};
    const sufMap = {"st":["st","street"],"ave":["ave","avenue"],"rd":["rd","road"],"blvd":["blvd","boulevard"],"pkwy":["pkwy","parkway"],"pl":["pl","place"],"ln":["ln","lane"],"dr":["dr","drive"],"ct":["ct","court"],"hwy":["hwy","highway"],"cir":["cir","circle"],"ter":["ter","terrace"]};
    for(const k in dirMap){ if(dirMap[k].includes(t)) return ["dir", k]; }
    for(const k in sufMap){ if(sufMap[k].includes(t)) return ["suf", k]; }
    return ["txt", t];
  }
  function ed(a,b){ a=String(a||""); b=String(b||""); const n=a.length, m=b.length; if(!n) return m; if(!m) return n;
    const dp=new Array(n+1); for(let i=0;i<=n;i++){ dp[i]=new Array(m+1); dp[i][0]=i; } for(let j=0;j<=m;j++){ dp[0][j]=j; }
    for(let i=1;i<=n;i++){ for(let j=1;j<=m;j++){ const cost=(a.charCodeAt(i-1)===b.charCodeAt(j-1))?0:1;
      dp[i][j]=Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost); } } return dp[n][m];
  }
  for(let i=0;i<n;i++){
    const c=ctoks[i], m=mtoks[i]; if(!c||!m || c.toLowerCase()===m.toLowerCase()) continue;
    const [ck,cn] = tokKind(c), [mk,mn] = tokKind(m);
    // Case A: Same canonical kind+value (e.g., "Street" vs "St.")
    if(ck===mk && cn===mn && ck!=="num"){
      const note = (c.length<=m.length? c:m) + " vs " + (c.length<=m.length? m:c);
      const key = note.toLowerCase(); if(!seen.has(key)){ seen.add(key); diffs.push(note); }
      continue;
    }
    // Case B: Slight spelling mismatch on word tokens (exclude nums/dirs/suffixes)
    if(ck==="txt" && mk==="txt"){
      const d = ed(cn, mn), L = Math.max(cn.length, mn.length)||1;
      const near = (L>=4 && d<=2) || (L<=3 && d<=1);
      if(near){
        const note = (c.length<=m.length? c:m) + " vs " + (c.length<=m.length? m:c);
        const key = note.toLowerCase(); if(!seen.has(key)){ seen.add(key); diffs.push(note); }
      }
    }
  }
  return diffs.slice(0,2);
}

  const matches = [];
  const FZ = getFuzzyConfig();

  for(const cr of crmExt){
    const key = cr._key;
    const cu = nz(cr._unit);
    const key2 = normKeyCollapsed(cr[C_ADDR1], cr[C_ADDR2], cr[C_CITY], cr[C_STATE], cr[C_ZIP]);
    let mrows = Array.from(new Set([...(byKey[key]||[]), ...(byKeyCollapsed[key2]||[])]));
    if(!mrows.length && FZ.enabled){ // fuzzy fallback
      const zsk = zip5(cr[C_ZIP])+"|"+nz(cr[C_STATE]).toUpperCase();
      const cand = (byZipState[zsk]||[]);
      if(cand.length){
        const crmNS = normStreet(cr[C_ADDR1], cr[C_ADDR2]);
        const crmNum = houseNumberFrom(crmNS);
        const crmName = collapseLetters(streetNameOnly(crmNS));
        let bestRow=null, bestDist=1e9, bestSim=0;
        for(const r of cand){
          const rNS = normStreet(r[M_ADDR1], r[M_ADDR2]);
          if(houseNumberFrom(rNS)!==crmNum) continue;
          const rName = collapseLetters(streetNameOnly(rNS));
          const d = editDistance(crmName, rName);
          const sim = simRatio(crmName, rName);
          if(d<=FZ.maxEdits || sim>=FZ.minSim){ if(d<bestDist){ bestDist=d; bestSim=sim; bestRow=r; } }
        }
        if(bestRow) mrows = [bestRow];
      }
    }
    if(!mrows.length) continue;

    let mr=null, unit_case="none", fuzzyUsed=false;
    if(mrows.length===1 && mrows[0]._key!==key && mrows[0]._key!==key2){ fuzzyUsed=true; }
    const exact = cu ? mrows.filter(r=> nz(r._unit)===cu) : [];
    if(cu && exact.length){ mr=exact[0]; unit_case="exact"; }
    else{
      const bothUnitsDiff = mrows.filter(r=> nz(r._unit) && cu && nz(r._unit)!==cu);
      if(bothUnitsDiff.length){ continue; }
      mr = mrows[0]; unit_case = (!!nz(mr._unit) ^ !!cu) ? "one_sided" : "none";
    }
    




const streetDiffs = streetTokenDiffs(cr[C_ADDR1], mr[M_ADDR1]);
const cityDiffs   = streetTokenDiffs(cr[C_CITY],  mr[M_CITY]);
const stateDiffs  = streetTokenDiffs(cr[C_STATE], mr[M_STATE]);
const zipDiffs    = streetTokenDiffs(String(cr[C_ZIP]||'').slice(0,5), String(mr[M_ZIP]||'').slice(0,5));

// Merge & dedupe while preserving order; cap to 4 items to keep Notes readable
const diffs = Array.from(new Set([...streetDiffs, ...cityDiffs, ...stateDiffs, ...zipDiffs])).slice(0,4);

// Raw City strings (to surface spacing/punctuation-only differences)
const rawCityCRM  = String(cr[C_CITY]||'');
const rawCityMail = String(mr[M_CITY]||'');
const rawCityDiff = (cityDiffs.length===0 && rawCityCRM.trim().toLowerCase() !== rawCityMail.trim().toLowerCase());

// ---------- Diff classification helpers (local to this block) ----------
function splitPair(s){ const i = s.toLowerCase().indexOf(' vs '); if(i<0) return [s,'']; return [s.slice(0,i).trim(), s.slice(i+4).trim()]; }
function normLetters(s){ return String(s||'').toLowerCase().replace(/[^a-z0-9]/g,''); }
function hasOnlyPunctSpaceDiff(a,b){ return normLetters(a)===normLetters(b) && a.toLowerCase()!==b.toLowerCase(); }

const ABBREV = new Map([
  ['st','street'],['st.','street'],['ave','avenue'],['ave.','avenue'],['av','avenue'],['av.','avenue'],
  ['blvd','boulevard'],['blvd.','boulevard'],['rd','road'],['rd.','road'],['dr','drive'],['dr.','drive'],
  ['ln','lane'],['ln.','lane'],['ct','court'],['ct.','court'],['cir','circle'],['cir.','circle'],
  ['trl','trail'],['trl.','trail'],['pkwy','parkway'],['pkwy.','parkway'],['hwy','highway'],['hwy.','highway'],
  ['pl','place'],['pl.','place'],['mt','mount'],['ft','fort'],
  ['n','north'],['n.','north'],['s','south'],['s.','south'],['e','east'],['e.','east'],['w','west'],['w.','west'],
  ['saint','st'],['st','saint'] // city variant both ways
]);
function isAbbrevOrDirectional(a,b){
  const A = a.toLowerCase(), B = b.toLowerCase();
  const aStripped = A.replace(/\./g,''), bStripped = B.replace(/\./g,'');
  // Exact mapped pairs either way
  if(ABBREV.get(aStripped) === bStripped) return true;
  if(ABBREV.get(bStripped) === aStripped) return true;
  // One is prefix of the other with dot removed (e.g., blvd. vs boulevard)
  if(aStripped && bStripped && (aStripped===bStripped.slice(0,aStripped.length) || bStripped===aStripped.slice(0,bStripped.length))) return true;
  return false;
}
function levenshtein(a,b){
  a = String(a||'').toLowerCase(); b = String(b||'').toLowerCase();
  const m=a.length, n=b.length; if(m===0) return n; if(n===0) return m;
  const dp = Array(n+1); for(let j=0;j<=n;j++) dp[j]=j;
  for(let i=1;i<=m;i++){
    let prev=dp[0]; dp[0]=i;
    for(let j=1;j<=n;j++){
      const temp=dp[j];
      dp[j] = Math.min(
        dp[j]+1,           // deletion
        dp[j-1]+1,         // insertion
        prev + (a[i-1]===b[j-1]?0:1) // substitution
      );
      prev=temp;
    }
  }
  return dp[n];
}
function classifyDiff(s){
  const [a,b] = splitPair(s);
  if(hasOnlyPunctSpaceDiff(a,b)) return 'punct';
  if(isAbbrevOrDirectional(a,b)) return 'abbrev';
  const ed = levenshtein(a,b);
  if(ed>0 && ed<=2) return 'typo';
  return 'other';
}

// Build Notes content
const notesPieces = [...diffs];
if(rawCityDiff){ notesPieces.push(`${rawCityMail} vs ${rawCityCRM}`); }

let conf = 100;

// Type-weighted penalty
let nTypo=0, nAbbrev=0, nPunct=0, nOther=0;
for(const s of notesPieces){
  const c = classifyDiff(s);
  if(c==='typo') nTypo++; else if(c==='abbrev') nAbbrev++; else if(c==='punct') nPunct++; else nOther++;
}
// Base penalties
let diffPenalty = nTypo*3 + nOther*2 + (nAbbrev+nPunct)*1;
// Multi-typo escalation: extra -1% per typo beyond the first
if(nTypo>=2){ diffPenalty += (nTypo-1); }
// Cap total diff penalty at 12%
diffPenalty = Math.min(diffPenalty, 12);
conf -= diffPenalty;

// One-sided unit mismatch penalty (-8%), additive
if(unit_case==="one_sided") conf -= 8;

// Apply fuzzy cap/floor if fuzzy was used
if(fuzzyUsed && FZ.enabled){ conf = Math.min(conf, FZ.base); conf = Math.max(FZ.floor, conf); }
// If only benign diffs (abbrev/punct) and no 'other' or 'typo', bypass fuzzy cap
if(fuzzyUsed && nTypo===0 && nOther===0){
  const unitPenalty = (unit_case==="one_sided") ? 8 : 0;
  const recompute = 100 - diffPenalty - unitPenalty;
  if(recompute > conf) conf = recompute;
}

// If no diffs (including raw city) and no one-sided unit, clamp back to 100
if(notesPieces.length===0 && unit_case!=="one_sided"){ conf = 100; }

let notesText = '';
if(Math.round(conf) === 100){
  notesText = 'perfect match';
}else{
  notesText = notesPieces.join('; ');
  if(!notesText) notesText = 'difference detected';
}

const allMailDates = Array.from(md[mr._key]||[]);



    const cdk = dateKey(cr[C_DATE]);
    const filtered = allMailDates.filter(d => dateKey(d) <= cdk).sort((a,b)=>dateKey(a)-dateKey(b));

    matches.push({
      "Mail Address 1": nz(mr[M_ADDR1]), "Mail Unit": nz(mr._unit),
      "CRM Address 1": nz(cr[C_ADDR1]), "CRM Unit": cu,
      "City": nz(cr[C_CITY]), "State": nz(cr[C_STATE]), "ZIP": zip5(cr[C_ZIP]), "Mail City": nz(mr[M_CITY]), "Mail ZIP": zip5(mr[M_ZIP]),
      "Mail Dates": fmtDates(filtered),
      "CRM Date": fmtDate(nz(cr[C_DATE])), "Amount": fmtAmount(nz(cr[C_AMT])),
      "Confidence": (Math.round(conf) + "%"),
      "Notes": notesText
    });
  }

  // Top lists
  const cCity = new Map(), cZip=new Map();
  // Mail totals by City/ZIP (all mail rows)
  const mailCityTotals = new Map(), mailZipTotals = new Map();
  for(const r of mail.rows){ const city = nz(r[M_CITY]); if(city) mailCityTotals.set(city, (mailCityTotals.get(city)||0)+1);
    const zp = zip5(r[M_ZIP]); if(zp) mailZipTotals.set(zp, (mailZipTotals.get(zp)||0)+1); }
  for (const m of matches) { const mc=m["Mail City"], mz=m["Mail ZIP"]; if(mc) cCity.set(mc,(cCity.get(mc)||0)+1); if(mz) cZip.set(mz,(cZip.get(mz)||0)+1); }
  const topCities = Array.from(cCity.entries()).sort((a,b)=>b[1]-a[1]).slice(0,10).map(([City,Count])=>({City,Count}));
  const topZips   = Array.from(cZip.entries()).sort((a,b)=>b[1]-a[1]).slice(0,10).map(([ZIP,Count])=>({ZIP,Count}));

  // Time series
  const monthsSet = new Set(); const mMonths=[], cMonths=[], mtMonths=[];
  for(const k in md){ for(const d of md[k]||[]){ const mk=monthKey(d); if(mk){ mMonths.push(mk); monthsSet.add(mk); } } }
  for(const r of crmExt){ const mk=monthKey(r[C_DATE]); if(mk){ cMonths.push(mk); monthsSet.add(mk); } }
  for(const m of matches){ const mk=monthKey(m["CRM Date"]); if(mk){ mtMonths.push(mk); monthsSet.add(mk); } }
  const xLabs = Array.from(monthsSet).sort();
  function countSeries(list){ const map=new Map(); for(const k of list){ map.set(k,(map.get(k)||0)+1); } return xLabs.map(k=>map.get(k)||0); }
  const mSeries = countSeries(mMonths), cSeries = countSeries(cMonths), mtSeries = countSeries(mtMonths);
  function prevMonthKey(ym){ const [y,m]=ym.split('-').map(Number); return `${y-1}-${String(m).padStart(2,'0')}`; }
  const mSeriesY = xLabs.map(k=> mMonths.filter(x=>x===prevMonthKey(k)).length);
  const cSeriesY = xLabs.map(k=> cMonths.filter(x=>x===prevMonthKey(k)).length);
  const mtSeriesY= xLabs.map(k=> mtMonths.filter(x=>x===prevMonthKey(k)).length);

  
  const __uniqMailCount = Object.keys(byKey).length;
return { uniqueMailAddrs: __uniqMailCount,  mailRows: mail.rows, crmRows: crm.rows, matches, mailCityTotals, mailZipTotals, topCities, topZips, xLabs, mSeries, cSeries, mtSeries, mSeriesY, cSeriesY, mtSeriesY };
}


function renderSummary(state){
  try{
    const tbody = document.querySelector('[data-summary="rows"]');
    if(!tbody) return;
    const esc = (v)=> String(v==null? "": v).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
    const rows = state.matches || [];
    tbody.innerHTML = rows.slice().sort((a,b)=> parseCRMDate(b["CRM Date"]) - parseCRMDate(a["CRM Date"])).map(m => (
      `<tr>
        <td>${esc(m["Mail Address 1"])}</td>
        <td>${esc(m["Mail Unit"])}</td>
        <td>${esc(m["CRM Address 1"])}</td>
        <td>${esc(m["CRM Unit"])}</td>
        <td>${esc(m["City"])}</td>
        <td>${esc(m["State"])}</td>
        <td>${esc(m["ZIP"])}</td>
        <td>${esc(m["Mail Dates"])}</td>
        <td>${esc(m["CRM Date"])}</td>
        <td>${esc(m["Amount"])}</td>
        <td class="conf" style="text-align:right">${esc(m["Confidence"])}</td>
        <td>${esc(m["Notes"])}</td>
      </tr>`
    )).join("");
    colorizeConfidence();
// Rebuild sticky header clone/alignment after render
    if (typeof setupSummarySticky === "function"){
      try { setupSummarySticky(); } catch(e){ console.warn("[MailTrace] sticky skip", e); }
    }
  }catch(e){
    console.error("[MailTrace] renderSummary failed:", e);
  }
}

// ---------- Renderers ----------
function renderKPIs(state){
  try{
    const mailCount = state.mailRows.length;
    const crmCount  = state.crmRows.length;
    const matchCount = state.matches.length;
    // Fill counts
    const q = sel => document.querySelector(sel);
    if(q('[data-kpi="mail"]')) q('[data-kpi="mail"]').textContent = String(mailCount);
    if(q('[data-kpi="crm"]'))  q('[data-kpi="crm"]').textContent  = String(crmCount);
    if(q('[data-kpi="matches"]')) q('[data-kpi="matches"]').textContent = String(matchCount);
    // Match Rate = matches / total mailers sent
    const rate = mailCount ? ((matchCount / mailCount) * 100).toFixed(1) + '%' : '0%';
    if(q('[data-kpi="rate"]')) q('[data-kpi="rate"]').textContent = rate;
    // Revenue from matches = sum of Amount on matched rows
    const revenueNum = (state.matches||[]).reduce((sum,m)=>{
      const raw = (m && m['Amount']) ? String(m['Amount']) : '0';
      const val = parseFloat(raw.replace(/[^0-9.-]/g,'')) || 0;
      return sum + val;
    }, 0);
    const fmt = new Intl.NumberFormat('en-US', { style:'currency', currency:'USD' });
    if(q('[data-kpi="revenue"]')) q('[data-kpi="revenue"]').textContent = fmt.format(revenueNum);
  }catch(e){ console.error('[MailTrace] renderKPIs failed:', e); }

    
    // --- Expanded KPIs: RPM, Avg Ticket, Median Days, 30/60/90 ---
    try{
      const q = (sel)=> document.querySelector(sel);

      // Ensure tiles exist (or adjust existing ones)
      (function ensureTiles(){
        const host = document.getElementById('cmp-kpis');
        if(!host) return;

        // Helper to ensure a KPI tile exists
        const ensureTile = (key, label) => {
          let v = q('[data-kpi="'+key+'"]');
          if(!v){
            const tile = document.createElement('div');
            tile.className = 'kpi';
            tile.innerHTML = '<div class="v" data-kpi="'+key+'">–</div><div class="l">'+label+'</div>';
            host.appendChild(tile);
          }else{
            // refresh label in case we’re repurposing a previous tile
            const l = v.parentElement.querySelector('.l');
            if(l) l.textContent = label;
          }
        };

        // If an old Avg Days tile exists, repurpose to "Median Days to Convert"
        const oldAvg = q('[data-kpi="avgdays"]');
        if(oldAvg){
          oldAvg.setAttribute('data-kpi','meddays');
          const l = oldAvg.parentElement.querySelector('.l');
          if(l) l.textContent = 'Median Days to Convert';
        }

        ensureTile('rpm',       'Revenue per Mailer');
        ensureTile('avgticket', 'Avg Ticket (per Match)');
        ensureTile('meddays',   'Median Days to Convert');
        ensureTile('d30',       'Converted ≤30 Days');
        ensureTile('d60',       'Converted ≤60 Days');
        ensureTile('d90',       'Converted ≤90 Days');
        ensureTile('uniqmail',  'Unique Mail Addresses');
        })();

      
        
    // --- Advanced KPIs: collapse/expand UI and placement (inline in KPI box) ---
    (function ensureAdvancedKPIsUI(){
      const host = document.getElementById('cmp-kpis');
      if(!host) return;

      // Toggle button INSIDE the KPI grid, full-width row
      let toggle = document.getElementById('kpi-adv-toggle');
      if(!toggle){
        toggle = document.createElement('button');
        toggle.id = 'kpi-adv-toggle';
        toggle.type = 'button';
        toggle.textContent = 'Show advanced KPIs';
        toggle.style.marginTop = '8px';
        toggle.style.background = 'transparent';
        toggle.style.border = '1px solid #e2e2e2';
        toggle.style.borderRadius = '8px';
        toggle.style.padding = '6px 10px';
        toggle.style.fontSize = '12px';
        toggle.style.cursor = 'pointer';
        toggle.style.display = 'block';
        toggle.style.width = '100%';
        toggle.style.gridColumn = '1 / -1';
        host.appendChild(toggle);
      }

      // Advanced container INSIDE the KPI grid, hidden by default; spans all columns
      let adv = document.getElementById('cmp-kpis-advanced');
      if(!adv){
        adv = document.createElement('div');
        adv.id = 'cmp-kpis-advanced';
        adv.className = 'kpis kpis-advanced';
        adv.style.display = 'none';
        adv.style.marginTop = '8px';
        adv.style.borderTop = '1px dashed #e5e5e5';
        adv.style.paddingTop = '8px';
        adv.style.gridColumn = '1 / -1';
        // Force 3-across layout; copy gaps from base if available
        const cs = getComputedStyle(host);
        adv.style.display = 'none';
        adv.style.gap = cs.gap || (cs.columnGap || '12px');
        adv.style.columnGap = cs.columnGap || cs.gap || '12px';
        adv.style.rowGap = cs.rowGap || cs.gap || '12px';
        adv.style.gridTemplateColumns = 'repeat(3, minmax(0, 1fr))';
        host.appendChild(adv);
      }

      // Move advanced tiles into the advanced container
      const advKeys = ['rpm','avgticket','meddays','d30','d60','d90'];
      advKeys.forEach(k => {
        const v = document.querySelector('[data-kpi=\"'+k+'\"]');
        if (v) {
          const tile = v.parentElement;
          if (tile && tile.parentElement !== adv) adv.appendChild(tile);
        }
      });

      // Attach toggle behavior (idempotent)
      if(!toggle._bound){
        toggle._bound = true;
        toggle.addEventListener('click', () => {
          const cs = getComputedStyle(host);
          const show = adv.style.display === 'none';
          adv.style.display = show ? 'grid' : 'none';
          // keep 3-across and spacing consistent every toggle
          adv.style.gridTemplateColumns = 'repeat(3, minmax(0, 1fr))';
          adv.style.gap = cs.gap || (cs.columnGap || '12px');
          adv.style.columnGap = cs.columnGap || cs.gap || '12px';
          adv.style.rowGap = cs.rowGap || cs.gap || '12px';
          toggle.textContent = show ? 'Hide advanced KPIs' : 'Show advanced KPIs';
        });
      }
    })();
    // --- end Advanced KPIs UI ---
// Rename labels for base KPIs
        (function renameBaseKPIlabels(){
          const host = document.getElementById('cmp-kpis');
          if(!host) return;
          const crmV  = host.querySelector('[data-kpi="crm"]');
          if (crmV) {
            const l = crmV.parentElement.querySelector('.l');
            if (l) l.textContent = 'Total Jobs';
          }
          const uniqV = host.querySelector('[data-kpi="uniqmail"]');
          if (uniqV) {
            const l2 = uniqV.parentElement.querySelector('.l');
            if (l2) l2.textContent = 'Unique Mail Addresses';
          }
        })();

        // Reposition: place Unique Mail Addresses immediately after Total Mail
        (function placeUniqAfterMail(){
          const host = document.getElementById('cmp-kpis');
          if(!host) return;
          const mailV = host.querySelector('[data-kpi="mail"]');
          const uniqV = host.querySelector('[data-kpi="uniqmail"]');
          if (host && mailV && uniqV) {
            const mailTile = mailV.parentElement;
            const uniqTile = uniqV.parentElement;
            const next = mailTile.nextSibling;
            if (next !== uniqTile) {
              host.insertBefore(uniqTile, next);
            }
          }
        })();
// Parse MM-DD-YYYY (e.g., 01-31-2024)
      const parseMDY = (s) => {
        if (!s) return null;
        s = String(s).trim();
        if (s === '—' || s === '-' || s.toLowerCase() === 'na') return null;
        const parts = s.split('-').map(x => parseInt(x,10));
        if (parts.length !== 3 || parts.some(isNaN)) return null;
        const [mm, dd, yyyy] = parts;
        const d = new Date(yyyy, mm-1, dd);
        return isNaN(d.getTime()) ? null : d;
      };

      // Collect day diffs per match + revenue
      let dayDiffs = [];
      let c30 = 0, c60 = 0, c90 = 0;
      let validCount = 0;

      // Revenue recompute (in case not available as a variable here)
      let revenueNum = 0;
      for (const m of (state.matches || [])) {
        const raw = (m && m['Amount']) ? String(m['Amount']) : '0';
        const val = parseFloat(raw.replace(/[^0-9.-]/g,'')) || 0;
        revenueNum += val;
      }

      for (const row of (state.matches || [])) {
        const mailStr = String(row['Mail Dates'] || '').trim();
        const crmStr  = String(row['CRM Date']  || '').trim();
        if (!mailStr || !crmStr || mailStr === '—' || crmStr === '—') continue;

        const parts = mailStr.split(/,\s*/).map(s => s.trim()).filter(Boolean);
        let earliest = null;
        for (const ds of parts) {
          const d = parseMDY(ds);
          if (d && (!earliest || d < earliest)) earliest = d;
        }
        const crmD = parseMDY(crmStr);
        if (earliest && crmD) {
          const diff = Math.round((crmD - earliest) / (1000*60*60*24));
          if (Number.isFinite(diff)) {
            dayDiffs.push(diff);
            validCount++;
            if (diff <= 30) c30++;
            if (diff <= 60) c60++;
            if (diff <= 90) c90++;
          }
        }
      }

      // Median days
      let med = 0;
      if (dayDiffs.length){
        dayDiffs.sort((a,b)=>a-b);
        const mid = Math.floor(dayDiffs.length/2);
        med = (dayDiffs.length % 2 === 0) ? Math.round((dayDiffs[mid-1] + dayDiffs[mid]) / 2) : dayDiffs[mid];
      }

      // RPM & Avg Ticket
      const fmtC = new Intl.NumberFormat('en-US', { style:'currency', currency:'USD' });
      const mailCount  = (state.mailRows||[]).length;
      const matchCount = (state.matches||[]).length;
      const rpm        = mailCount ? revenueNum / mailCount : 0;
      const avgTicket  = matchCount ? revenueNum / matchCount : 0;

      // Fill tiles
      const setText = (k, v) => { const n = document.querySelector('[data-kpi="'+k+'"]'); if(n) n.textContent = v; };
      setText('rpm', fmtC.format(rpm));
      setText('avgticket', fmtC.format(avgTicket));
      setText('meddays', String(med));

      const pct = (num, den) => (den ? Math.round((num/den)*100) : 0) + '%';
      setText('d30', pct(c30, validCount));
      setText('d60', pct(c60, validCount));
      setText('d90', pct(c90, validCount));
    }catch(e){ console.error('Expanded KPI block failed:', e); }
    // --- end expanded KPIs ---

    (function(){ const n=document.querySelector('[data-kpi="uniqmail"]'); if(n) n.textContent = String(state.uniqueMailAddrs||0); })();
}

function renderTop(state){ const cBody = document.querySelector('[data-top="cities"]'); const zBody = document.querySelector('[data-top="zips"]');
  cBody.innerHTML = state.topCities.map(r=>{ const denom = state.mailCityTotals.get(r.City)||0; const rate = denom? (Math.round(100*r.Count/denom)+"%") : "–"; return `<tr><td>${r.City}</td><td style="text-align:center">${r.Count}</td><td style="text-align:center">${rate}</td></tr>`; }).join("");
  zBody.innerHTML = state.topZips.map(r=>{ const denom = state.mailZipTotals.get(r.ZIP)||0; const rate = denom? (Math.round(100*r.Count/denom)+"%") : "–"; return `<tr><td>${r.ZIP}</td><td style="text-align:center">${r.Count}</td><td style="text-align:center">${rate}</td></tr>`; }).join(""); }
function lineChart(canvas, labels, series, overlay){
  const ctx = canvas.getContext('2d'); const W=canvas.width, H=canvas.height, pad=30; ctx.clearRect(0,0,W,H);
  const all = [...series.flatMap(s=>s.data), ...(overlay||[]).flatMap(s=>s.data)];
  const min = 0, max = Math.max(1, Math.max(...all));
  const xFor = i => pad + i*(W-2*pad)/Math.max(1, labels.length-1);
  const yFor = v => H-pad - ( (v-min)/(max-min) )*(H-2*pad);
  ctx.strokeStyle = "#233049"; ctx.lineWidth=1; ctx.beginPath(); for(let i=0;i<labels.length;i++){ const x=xFor(i); ctx.moveTo(x, H-pad); ctx.lineTo(x, pad); } ctx.stroke();
  ctx.strokeStyle = "#2f3b57"; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(pad, pad); ctx.lineTo(pad, H-pad); ctx.lineTo(W-pad, H-pad); ctx.stroke();
  const colors = ["#60a5fa","#34d399","#f59e0b","#f472b6","#a78bfa"];
  series.forEach((s,si)=>{ const col = colors[si%colors.length]; ctx.strokeStyle = col; ctx.lineWidth = 2; ctx.beginPath(); s.data.forEach((v,i)=>{ const x=xFor(i), y=yFor(v); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }); ctx.stroke(); });
  if(overlay && overlay.length){ overlay.forEach((s,si)=>{ const col = colors[si%colors.length]; ctx.save(); ctx.setLineDash([5,4]); ctx.strokeStyle = col; ctx.globalAlpha=0.6;
    ctx.beginPath(); s.data.forEach((v,i)=>{ const x=xFor(i), y=yFor(v); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }); ctx.stroke(); ctx.restore(); }); }
  ctx.fillStyle="#9fb2c8"; ctx.font="11px system-ui"; const tickStep = Math.max(1, Math.ceil(labels.length/12));
  labels.forEach((lab,i)=>{ if(i%tickStep!==0) return; const x=pad + i*(W-2*pad)/Math.max(1, labels.length-1); ctx.fillText(lab, x-14, H-pad+14); });
}
function renderGraph(state){
  const canvas = document.getElementById("chart");
  const overlayOn = document.getElementById("yoyToggle").checked;
  const overlay = overlayOn ? [ {label:"Mail (YoY)", data: state.mSeriesY}, {label:"CRM (YoY)", data: state.cSeriesY}, {label:"Matches (YoY)", data: state.mtSeriesY} ] : [];
  lineChart(canvas, state.xLabs, [ {label:"Mail volume", data: state.mSeries}, {label:"CRM jobs", data: state.cSeries}, {label:"Matches", data: state.mtSeries} ], overlay);
}

function setupSummarySticky(){
  try{
    const wrap = document.querySelector('#cmp-summary .table-wrap');
    if(!wrap) return;
    const table = wrap.querySelector('table');
    if(!table) return;
    const thead = table.querySelector('thead');
    const tbody = table.querySelector('tbody');
    if(!thead || !tbody) return;

    // Remove previous floating head
    const prev = wrap.querySelector('.floating-head');
    if(prev) prev.remove();

    // Ensure a <colgroup id="sum-cols"> exists on main table with correct number of cols
    const thCount = thead.querySelectorAll('th').length;
    let cgMain = table.querySelector('colgroup#sum-cols');
    if(!cgMain){
      cgMain = document.createElement('colgroup');
      cgMain.id = 'sum-cols';
      table.insertBefore(cgMain, thead);
    }
    if(cgMain.children.length !== thCount){
      cgMain.innerHTML = new Array(thCount).fill('<col>').join('');
    }

    // Build floating head table with its own colgroup
    const clone = document.createElement('table');
    clone.className = 'floating-head';
    clone.setAttribute('aria-hidden','true');
    const cgClone = document.createElement('colgroup');
    cgClone.id = 'sum-cols-clone';
    cgClone.innerHTML = new Array(thCount).fill('<col>').join('');
    clone.appendChild(cgClone);
    const theadClone = thead.cloneNode(true);
    clone.appendChild(theadClone);
    wrap.prepend(clone);

    // Sync widths from first body row cells to both colgroups
    function syncCols(){
      const row = tbody.querySelector('tr');
      const cells = row ? row.children : thead.querySelectorAll('th');
      const n = Math.min(cells.length, thCount);
      const mainCols = cgMain.querySelectorAll('col');
      const cloneCols = cgClone.querySelectorAll('col');
      for(let i=0;i<n;i++){
        const w = cells[i].getBoundingClientRect().width || cells[i].offsetWidth || 0;
        mainCols[i].style.width = w + 'px';
        cloneCols[i].style.width = w + 'px';
      }
      clone.style.width = table.scrollWidth + 'px';
      }

    // Initial sync (twice to catch fonts/layout)
    syncCols();
    setTimeout(syncCols, 0);
    setTimeout(syncCols, 250);

    // Hide native thead (clone will be visible)
    thead.style.visibility = 'hidden';

    // Keep clone aligned on scroll/resize
    window.addEventListener('resize', syncCols);
  }catch(e){
    console.warn('[MailTrace] sticky header colgroup sync skipped:', e);
  }
}


setupSummarySticky();

window.MailTraceUI = {
  state: null,
  computeState,
  render: {
    kpis: ()=> renderKPIs(window.MailTraceUI.state),
    top: ()=> renderTop(window.MailTraceUI.state),
    graph: ()=> renderGraph(window.MailTraceUI.state),
    summary: ()=> renderSummary(window.MailTraceUI.state),
    all: ()=>{ const S=window.MailTraceUI.state; renderKPIs(S); renderTop(S); renderGraph(S); renderSummary(S); }
  }
};

document.getElementById("yoyToggle").addEventListener("change", ()=> MailTraceUI.render.graph());
document.getElementById("runBtn").addEventListener("click", async ()=>{
  try{
    const mf = document.getElementById("mailCsv").files[0];
    const cf = document.getElementById("crmCsv").files[0];
    if(!mf || !cf) return showError("Please pick both CSV files first.");
    const mailText = await mf.text();
    const crmText  = await cf.text();
    try{
      window.MailTraceUI.state = computeState(mailText, crmText);
      window.MailTraceUI.render.all();
    }catch(e){
      if(e && e.__isMappingError){
        const mapping = await openColumnMapper(e.payload);
        if(mapping){
          window.MailTraceUI.state = computeState(mailText, crmText, mapping);
          window.MailTraceUI.render.all();
        }else{
          return;
        }
      }else{
        throw e;
      }
    }
  }catch(e){ console.error(e); showError(e.stack||String(e)); }
});



function colorizeConfidence(){
  const tds = document.querySelectorAll('[data-summary="rows"] td.conf');
  for(const td of tds){
    td.classList.remove('conf-green','conf-yellow','conf-red');
    const n = parseInt(String(td.textContent||'').replace(/[^0-9]/g,''),10) || 0;
    if(n > 95) td.classList.add('conf-green');
    else if(n <= 85) td.classList.add('conf-red');
    else td.classList.add('conf-yellow');
  }
}



window.addEventListener('load', colorizeConfidence);

function parseCRMDate(v){
  if(!v) return 0;
  const s = String(v).trim();
  const m = s.match(/^(\d{1,2})[\/-](\d{1,2})[\/-](\d{2,4})$/);
  if(!m) return Date.parse(s) || 0;
  let mm = parseInt(m[1],10), dd = parseInt(m[2],10), yy = parseInt(m[3],10);
  if(yy < 100) yy += 2000;
  return Date.UTC(yy, Math.max(0,mm-1), dd);
}
</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  try{
    var toggle = document.getElementById('fuzzyToggle');
    var mode   = document.getElementById('fuzzyMode');
    if (mode)   mode.value = 'loose';   // keep Loose selected
    if (toggle) toggle.checked = true;  // keep fuzzy ON
    // Hide the control row that contains both controls
    if (toggle && toggle.parentElement && toggle.parentElement.parentElement){
      var row = toggle.parentElement.parentElement; // the <div style="margin-top:10px; ...">
      row.style.display = 'none';
      // Hide the trailing "Stays in-browser" line, if present
      var sib = row.nextElementSibling;
      if (sib && sib.classList && sib.classList.contains('muted')){
        sib.style.display = 'none';
      }
    }
  }catch(_){}
});
</script>
<script id="mt-legend-and-mmyy-fillText">
(function(){
  function ensureLegendNear(canvas, series, overlay){
    if(!canvas) return;
    var wrap = canvas.parentElement || canvas;
    var legend = wrap.querySelector('.mt-legend');
    if(!legend){
      legend = document.createElement('div');
      legend.className = 'mt-legend';
      wrap.appendChild(legend);
    }
    var colors = ["#60a5fa","#34d399","#f59e0b","#f472b6","#a78bfa"];
    function labelOf(s, i){ return (s && (s.label || s.name || s.title)) || ('Series ' + (i+1)); }
    var html = '';
    if (Array.isArray(series)){
      series.forEach(function(s, i){
        html += '<span class="item"><span class="swatch" style="background:'+colors[i%colors.length]+'; color:'+colors[i%colors.length]+'"></span>'+labelOf(s,i)+'</span>';
      });
    }
    if (overlay && overlay.length){
      html += '<span class="item hint"><span class="swatch dash" style="color:#94a3b8"></span>Dashed = Previous Year</span>';
    }
    legend.innerHTML = html;
  }

  if (typeof window.lineChart === 'function' && !window.__mmyy_hook__){
    var origLine = window.lineChart;
    window.lineChart = function(canvas, labels, series, overlay){
      // Intercept only visible tick labels, keep data alignment intact
      var proto = CanvasRenderingContext2D && CanvasRenderingContext2D.prototype;
      var saved = proto && proto.fillText;
      if (saved){
        proto.fillText = function(text, x, y, maxWidth){
          try{
            if (typeof text === 'string' && /^\d{4}-\d{2}$/.test(text)){
              text = text.slice(5) + '-' + text.slice(2,4); // MM-YY
            }
          }catch(e){}
          return saved.call(this, text, x, y, maxWidth);
        };
      }
      try{
        var res = origLine(canvas, labels, series, overlay);
        try{ ensureLegendNear(canvas, series, overlay); }catch(e){}
        return res;
      } finally {
        if (saved) proto.fillText = saved;
      }
    };
    window.__mmyy_hook__ = true;
  }
})();
</script>
<div aria-hidden="true" id="mtMapperOverlay">
<div aria-labelledby="mtMapperTitle" aria-modal="true" id="mtMapperModal" role="dialog">
<header>
<h3 id="mtMapperTitle">Map your columns</h3>
<button class="btn ghost" id="mtMapperClose">Close</button>
</header>
<div class="body">
<p id="mtMapperHelp">We couldn't automatically detect some columns. Map the fields below and we'll remember them for next time.</p>
<div class="grid">
<div class="col" id="mtMapMail">
<h4>Mail CSV</h4>
<div class="rows"></div>
</div>
<div class="col" id="mtMapCRM">
<h4>CRM CSV</h4>
<div class="rows"></div>
</div>
</div>
</div>
<footer>
<button class="btn ghost" id="mtMapperAuto">Auto‑map</button>
<div style="flex:1"></div>
<button class="btn" id="mtMapperCancel">Cancel</button>
<button class="btn primary" id="mtMapperApply">Use mapping</button>
</footer>
</div>
</div>
<script>
class ColumnMappingError extends Error{
  constructor(payload){
    super("Column mapping required");
    this.name = "ColumnMappingError";
    this.payload = payload;
    this.__isMappingError = true;
  }
}

function uniqueSamples(rows, col, limit=5){
  if(!col) return [];
  const seen = new Set(), out = [];
  for(const r of rows){
    const v = (r[col] ?? "").toString().trim();
    if(!v) continue;
    if(!seen.has(v)){ seen.add(v); out.push(v); if(out.length>=limit) break; }
  }
  return out;
}

function readMappingFromStorage(){
  try{ return JSON.parse(localStorage.getItem("mt_column_mapping_v1")||"{}"); }catch{ return {}; }
}
function saveMappingToStorage(map){ try{ localStorage.setItem("mt_column_mapping_v1", JSON.stringify(map||{})); }catch{} }

function suggestedAutoMapping(headers, SYN){
  const low = headers.map(h=>h.toLowerCase());
  const pick=(keys)=>{ for(const k of keys){ const i=low.indexOf(k); if(i!==-1) return headers[i]; } return ""; };
  return {
    address1: pick(SYN.address1||[]),
    address2: pick(SYN.address2||[]),
    city:     pick(SYN.city||[]),
    state:    pick(SYN.state||[]),
    zip:      pick(SYN.zip||[]),
    mail_date:pick(SYN.mail_date||[]),
    crm_date: pick(SYN.crm_date||[]),
    amount:   pick(SYN.amount||[]),
  };
}

async function openColumnMapper(payload){
  return new Promise(resolve => {
    const overlay = document.getElementById("mtMapperOverlay");
    const $mail = document.querySelector("#mtMapMail .rows");
    const $crm  = document.querySelector("#mtMapCRM .rows");
    $mail.innerHTML = ""; $crm.innerHTML = "";
    const state = { map:{ mail:{}, crm:{} } };
    const reqMail = ["address1"];
    const reqCRM  = ["address1"];

    const SYN = payload.SYN || {address1:[],address2:[],city:[],state:[],zip:[],mail_date:[],crm_date:[],amount:[]};

    function makeRow(side, key, label){
      const headers = side==="mail" ? payload.mailHeaders : payload.crmHeaders;
      const rows    = side==="mail" ? payload.mailRows : payload.crmRows;
      const wrap = document.createElement("div"); wrap.className="row";
      const lab = document.createElement("label");
      lab.textContent = label;
      if((side==="mail" && reqMail.includes(key)) || (side==="crm" && reqCRM.includes(key))){
        const badge = document.createElement("span"); badge.className="req"; badge.textContent="required"; lab.appendChild(badge);
      }
      const sel = document.createElement("select");
      sel.innerHTML = `<option value="">— Select column —</option>` + headers.map(h=>`<option value="${h}">${h}</option>`).join("");
      const storage = readMappingFromStorage();
      const stored = storage?.[side]?.[key] || "";
      const auto   = (payload.auto?.[side]?.[key]) || (suggestedAutoMapping(headers, SYN)[key]) || "";
      const pre = stored || auto || "";
      if(pre && headers.includes(pre)) sel.value = pre;
      const samples = document.createElement("div"); samples.className="samples";
      function updateSamples(){
        const col = sel.value;
        if(!col){ samples.innerHTML = ""; return; }
        const vals = uniqueSamples(rows, col, 4);
        samples.innerHTML = vals.length? ("e.g. " + vals.join(" · ")) : "";
      }
      sel.addEventListener("change", updateSamples);
      updateSamples();
      wrap.appendChild(lab); wrap.appendChild(sel); wrap.appendChild(samples);
      (side==="mail" ? $mail : $crm).appendChild(wrap);
      state.map[side][key] = sel;
    }

    makeRow("mail","address1","Address 1");
    makeRow("mail","address2","Address 2 (optional)");
    makeRow("mail","city","City (optional)");
    makeRow("mail","state","State (optional)");
    makeRow("mail","zip","ZIP (optional)");
    makeRow("mail","mail_date","Mail Date (optional)");

    makeRow("crm","address1","Address 1");
    makeRow("crm","address2","Address 2 (optional)");
    makeRow("crm","city","City (optional)");
    makeRow("crm","state","State (optional)");
    makeRow("crm","zip","ZIP (optional)");
    makeRow("crm","crm_date","CRM Date (optional)");
    makeRow("crm","amount","Amount (optional)");

    function collect(){
      const map = { mail:{}, crm:{} };
      for(const side of ["mail","crm"]){
        for(const key of Object.keys(state.map[side])){
          const sel = state.map[side][key];
          if(sel && sel.value) map[side][key] = sel.value;
        }
      }
      return map;
    }

    function validate(map){
      const miss = [];
      if(!map.mail.address1) miss.push("Mail: Address 1");
      if(!map.crm.address1) miss.push("CRM: Address 1");
      return miss;
    }

    function close(){ overlay.style.display="none"; overlay.setAttribute("aria-hidden","true"); }

    document.getElementById("mtMapperClose").onclick = ()=>{ close(); resolve(null); };
    document.getElementById("mtMapperCancel").onclick = ()=>{ close(); resolve(null); };
    document.getElementById("mtMapperAuto").onclick = ()=>{
      const mailAuto = suggestedAutoMapping(payload.mailHeaders, SYN);
      const crmAuto  = suggestedAutoMapping(payload.crmHeaders,  SYN);
      const ap = { mail:mailAuto, crm:crmAuto };
      for(const side of ["mail","crm"]){
        for(const [k,v] of Object.entries(ap[side])){
          const sel = state.map[side][k];
          if(sel && v){ sel.value = v; sel.dispatchEvent(new Event("change")); }
        }
      }
    };
    document.getElementById("mtMapperApply").onclick = ()=>{
      const map = collect();
      const miss = validate(map);
      if(miss.length){
        document.getElementById("mtMapperHelp").innerHTML = 'Missing required mappings: <span class="missing">'+miss.join(", ")+'</span>';
        return;
      }
      saveMappingToStorage(map);
      close();
      resolve(map);
    };

    overlay.style.display="flex"; overlay.setAttribute("aria-hidden","false");
  });
}
</script>
<script id="mtMapper_v2">
(function(){
  // If our v2 is already present, do nothing
  if(window.__mtMapperV2Installed) return;
  window.__mtMapperV2Installed = true;

  // Override suggestedAutoMapping and openColumnMapper if they exist
  const oldOpen = typeof openColumnMapper==="function" ? openColumnMapper : null;

  function suggestedAutoMapping(headers, SYN){
    const low = headers.map(h=>h.toLowerCase());
    const pick=(keys)=>{ for(const k of (keys||[])){ const i=low.indexOf(k); if(i!==-1) return headers[i]; } return ""; };
    return {
      first_name: pick(SYN.first_name),
      last_name:  pick(SYN.last_name),
      address1:   pick(SYN.address1),
      address2:   pick(SYN.address2),
      city:       pick(SYN.city),
      state:      pick(SYN.state),
      zip:        pick(SYN.zip),
      mail_date:  pick(SYN.mail_date),
      crm_date:   pick(SYN.crm_date),
      amount:     pick(SYN.amount),
    };
  }

  // Rebuild openColumnMapper UI with first/last and all-other-required
  window.openColumnMapper = async function(payload){
    return new Promise(resolve => {
      const overlay = document.getElementById("mtMapperOverlay");
      if(!overlay){ alert("Mapping UI not loaded yet."); return resolve(null); }
      const $mail = document.querySelector("#mtMapMail .rows");
      const $crm  = document.querySelector("#mtMapCRM .rows");
      $mail.innerHTML = ""; $crm.innerHTML = "";

      const reqMail = ["address1","address2","city","state","zip","mail_date"];
      const reqCRM  = ["address1","address2","city","state","zip","crm_date","amount"];

      const baseSYN = payload.SYN || {};
      const SYN = Object.assign({
        first_name: ["first name","firstname","fname","given name","givenname","first"],
        last_name:  ["last name","lastname","lname","surname","family name","familyname","last"],
        address1:   [], address2: [], city: [], state: [], zip: [], mail_date: [], crm_date: [], amount: []
      }, baseSYN);

      const state = { map:{ mail:{}, crm:{} } };

      function uniqueSamples(rows, col, limit=4){
        if(!col) return [];
        const seen = new Set(), out = [];
        for(const r of rows){
          const v = (r[col] ?? "").toString().trim();
          if(!v) continue;
          if(!seen.has(v)){ seen.add(v); out.push(v); if(out.length>=limit) break; }
        }
        return out;
      }
      function readMapping(){ try{ return JSON.parse(localStorage.getItem("mt_column_mapping_v1")||"{}"); }catch{ return {}; } }
      function saveMapping(map){ try{ localStorage.setItem("mt_column_mapping_v1", JSON.stringify(map||{})); }catch{} }

      function makeRow(side, key, label, optional=false){
        const headers = side==="mail" ? payload.mailHeaders : payload.crmHeaders;
        const rows    = side==="mail" ? payload.mailRows : payload.crmRows;
        const wrap = document.createElement("div"); wrap.className="row";
        const lab = document.createElement("label");
        lab.textContent = label;
        if(!optional){
          const badge = document.createElement("span"); badge.className="req"; badge.textContent="required"; lab.appendChild(badge);
        }
        const sel = document.createElement("select");
        sel.innerHTML = `<option value="">— Select column —</option>` + headers.map(h=>`<option value="${h}">${h}</option>`).join("");

        const storage = readMapping();
        const stored = storage?.[side]?.[key] || "";
        const auto   = (payload.auto?.[side]?.[key]) || (suggestedAutoMapping(headers, SYN)[key]) || "";
        const pre = stored || auto || "";
        if(pre && headers.includes(pre)) sel.value = pre;

        const samples = document.createElement("div"); samples.className="samples";
        function updateSamples(){
          const col = sel.value;
          if(!col){ samples.innerHTML = ""; return; }
          const vals = uniqueSamples(rows, col, 4);
          samples.innerHTML = vals.length? ("e.g. " + vals.join(" · ")) : "";
        }
        sel.addEventListener("change", updateSamples);
        updateSamples();

        wrap.appendChild(lab); wrap.appendChild(sel); wrap.appendChild(samples);
        (side==="mail" ? $mail : $crm).appendChild(wrap);
        state.map[side][key] = sel;
      }

      // Build rows — First/Last optional, others required
      // Mail
      makeRow("mail","first_name","First Name (optional)", true);
      makeRow("mail","last_name","Last Name (optional)", true);
      makeRow("mail","address1","Address 1");
      makeRow("mail","address2","Address 2");
      makeRow("mail","city","City");
      makeRow("mail","state","State");
      makeRow("mail","zip","ZIP");
      makeRow("mail","mail_date","Mail Date");

      // CRM
      makeRow("crm","first_name","First Name (optional)", true);
      makeRow("crm","last_name","Last Name (optional)", true);
      makeRow("crm","address1","Address 1");
      makeRow("crm","address2","Address 2");
      makeRow("crm","city","City");
      makeRow("crm","state","State");
      makeRow("crm","zip","ZIP");
      makeRow("crm","crm_date","CRM Date");
      makeRow("crm","amount","Amount");

      function collect(){
        const map = { mail:{}, crm:{} };
        for(const side of ["mail","crm"]){
          for(const key of Object.keys(state.map[side])){
            const sel = state.map[side][key];
            if(sel && sel.value) map[side][key] = sel.value;
          }
        }
        return map;
      }

      function validate(map){
        const miss = [];
        const label = s => s.replace("_"," ").replace(/\b\w/g, c => c.toUpperCase());
        for(const k of reqMail){ if(!map.mail[k]) miss.push("Mail: " + label(k)); }
        for(const k of reqCRM){ if(!map.crm[k]) miss.push("CRM: " + label(k)); }
        return miss;
      }

      function close(){ overlay.style.display="none"; overlay.setAttribute("aria-hidden","true"); }

      document.getElementById("mtMapperClose").onclick = ()=>{ close(); resolve(null); };
      document.getElementById("mtMapperCancel").onclick = ()=>{ close(); resolve(null); };
      document.getElementById("mtMapperAuto").onclick = ()=>{
        const mailAuto = suggestedAutoMapping(payload.mailHeaders, SYN);
        const crmAuto  = suggestedAutoMapping(payload.crmHeaders,  SYN);
        const ap = { mail:mailAuto, crm:crmAuto };
        for(const side of ["mail","crm"]){
          for(const [k,v] of Object.entries(ap[side])){
            const sel = state.map[side][k];
            if(sel && v){ sel.value = v; sel.dispatchEvent(new Event("change")); }
          }
        }
      };
      document.getElementById("mtMapperApply").onclick = ()=>{
        const map = collect();
        const miss = validate(map);
        if(miss.length){
          document.getElementById("mtMapperHelp").innerHTML = 'Missing required mappings: <span class="missing">'+miss.join(", ")+'</span>';
          return;
        }
        try{ localStorage.setItem("mt_column_mapping_v1", JSON.stringify(map)); }catch{}
        close();
        resolve(map);
      };

      overlay.style.display="flex"; overlay.setAttribute("aria-hidden","false");
    });
  };
})();
</script>
<script id="mtValidator">
(function(){
  const US_STATES = new Set(["AL","AK","AZ","AR","CA","CO","CT","DC","DE","FL","GA","HI","IA","ID","IL","IN","KS","KY","LA","MA","MD","ME","MI","MN","MO","MS","MT","NC","ND","NE","NH","NJ","NM","NV","NY","OH","OK","OR","PA","PR","RI","SC","SD","TN","TX","UT","VA","VI","VT","WA","WI","WV","WY"]);
  const DATE_MIN = new Date(2000,0,1).getTime();
  const DATE_MAX = new Date(2100,0,1).getTime();

  function pct(n,d){ return d? Math.round(100*n/d):0; }
  function isName(s){ return /^[A-Za-z .'\-]{2,}$/.test(s); }
  function isAddress1(s){
    if(!s || s.length<5) return false;
    const hasNum = /\d/.test(s);
    const hasWord = /[A-Za-z]/.test(s);
    return hasNum && hasWord;
  }
  function isAddress2(s){
    if(!s) return false;
    const k = /apt|unit|ste|suite|#|fl|floor|bldg|building|lot|trlr|trailer|rm|room/i;
    return k.test(s) || s.length>=2;
  }
  function isCity(s){ return /^[A-Za-z .'\-]{2,}$/.test(s); }
  function isState(s){
    if(typeof s!=="string") return false;
    const t = s.trim();
    return US_STATES.has(t.toUpperCase()) || /^[A-Za-z .'\-]{3,}$/.test(t);
  }
  function isZip(s){ return /^\d{5}(-\d{4})?$/.test(String(s).trim()); }
  function parseDateSafe(s){
    const t = Date.parse(s);
    if(Number.isNaN(t)) return NaN;
    if(t<DATE_MIN || t>DATE_MAX) return NaN;
    return t;
  }
  function isDate(s){ return !Number.isNaN(parseDateSafe(s)); }
  function isAmount(s){
    if(s===null || s===undefined) return false;
    const t = String(s).replace(/[$,]/g,"").trim();
    if(!t) return false;
    const n = Number(t);
    return Number.isFinite(n);
  }

  function scoreColumn(rows, col, checker){
    let ok=0, total=0;
    for(const r of rows){
      const v = (r[col] ?? "").toString().trim();
      if(v==="") continue;
      total++;
      try{ if(checker(v)) ok++; }catch{}
      if(total>=200) break;
    }
    return {ok,total,ratio: total? ok/total : 0};
  }

  function validateMappingOnData(side, rows, map){
    const checks = {
      first_name: isName,
      last_name:  isName,
      address1:   isAddress1,
      address2:   isAddress2,
      city:       isCity,
      state:      isState,
      zip:        isZip,
      mail_date:  isDate,
      crm_date:   isDate,
      amount:     isAmount,
    };
    const labels = {
      first_name:"First Name", last_name:"Last Name", address1:"Address 1", address2:"Address 2",
      city:"City", state:"State", zip:"ZIP", mail_date:"Mail Date", crm_date:"CRM Date", amount:"Amount"
    };
    const warnings = [];
    for(const [key, checker] of Object.entries(checks)){
      const col = map?.[key];
      if(!col) continue;
      const sc = scoreColumn(rows, col, checker);
      const pctOk = pct(sc.ok, sc.total);
      const thresh = (key==="address2") ? 40 : (key==="amount" ? 60 : 70);
      if(sc.total>=6 && pctOk < thresh){
        warnings.push(`${side.toUpperCase()} → ${labels[key]} looks off: only ${pctOk}% of sampled values match the expected format (column “${col}”).`);
      }
    }
    if(map?.state && map?.zip){
      const z = rows.map(r=>String(r[map.zip]??"")).find(v=>v && /^\d/.test(v));
      const st = rows.map(r=>String(r[map.state]??"")).find(Boolean);
      if(z && !/^\d{5}(-\d{4})?$/.test(z)) warnings.push(`${side.toUpperCase()} → ZIP values not in ZIP format.`);
      if(st && !isState(st)) warnings.push(`${side.toUpperCase()} → State values not recognized.`);
    }
    return warnings;
  }

  function getStorageMap(){
    try{ return JSON.parse(localStorage.getItem("mt_column_mapping_v1")||"{}"); }catch{ return {}; }
  }
  function setStorageMap(m){
    try{ localStorage.setItem("mt_column_mapping_v1", JSON.stringify(m||{})); }catch{}
  }

  function ensureWarnHost(){
    let host = document.getElementById("mtWarn");
    if(!host){
      host = document.createElement("div"); host.id="mtWarn";
      const parent = document.getElementById("runBtn")?.parentElement || document.body;
      parent.insertBefore(host, document.getElementById("runBtn"));
    }
    return host;
  }
  function showWarnings(list){
    const host = ensureWarnHost();
    if(!list || !list.length){ host.style.display="none"; host.innerHTML=""; return; }
    host.style.display="block";
    host.innerHTML = `<h4>Heads up: your mapping may be off</h4>
      <ul>${list.map(x=>`<li>${x}</li>`).join("")}</ul>
      <div class="actions">
        <button class="btn primary" id="mtWarnRemap">Review mapping</button>
        <button class="btn" id="mtWarnDismiss">Dismiss</button>
      </div>`;
    document.getElementById("mtWarnRemap").onclick = ()=>{ window.MailTraceUI?.actions?.openMapper && window.MailTraceUI.actions.openMapper(); };
    document.getElementById("mtWarnDismiss").onclick = ()=>{ showWarnings([]); };
  }

  function mountMapControls(){
    if(document.getElementById("mtMapControls")) return;
    const mail = document.getElementById("mailCsv");
    const crm  = document.getElementById("crmCsv");
    if(!mail || !crm) return;
    const host = document.createElement("div"); host.id="mtMapControls";
    host.innerHTML = `<button class="linkbtn" id="mtEditMap">Edit mapping</button>
                      <button class="linkbtn" id="mtResetMap" title="Clear saved mapping">Reset mapping</button>`;
    crm.parentElement.appendChild(host);
    document.getElementById("mtEditMap").onclick = ()=>{ window.MailTraceUI?.actions?.openMapper && window.MailTraceUI.actions.openMapper(); };
    document.getElementById("mtResetMap").onclick = ()=>{ setStorageMap({}); showWarnings([]); alert("Saved mapping cleared."); };
  }
  document.addEventListener("DOMContentLoaded", mountMapControls);
  setTimeout(mountMapControls, 1200);

  // After each run, compute warnings from data + mapping
  document.addEventListener("click", async (ev)=>{
    const btn = ev.target.closest && ev.target.closest("#runBtn");
    if(!btn) return;
    setTimeout(async ()=>{
      try{
        const st = window.MailTraceUI?.state;
        if(!st || !st.mail || !st.crm) return;
        const map = getStorageMap();
        const warn = [].concat(
          validateMappingOnData("mail", st.mail.rows, map.mail||{}),
          validateMappingOnData("crm",  st.crm.rows,  map.crm||{})
        );
        showWarnings(warn);
      }catch(err){ console.error(err); }
    }, 50);
  }, true);
})(); 
</script>
<script id="mtValidatorFix">
(function(){
  window.MailTraceUI = window.MailTraceUI || {actions:{}, flags:{}};
  if(!window.MailTraceUI.flags) window.MailTraceUI.flags = {};
  function bindMapControls(){
    const edit = document.getElementById("mtEditMap");
    const reset = document.getElementById("mtResetMap");
    if(edit){
      edit.onclick = async ()=>{
        if(!(window.MailTraceUI && window.MailTraceUI.actions && window.MailTraceUI.actions.openMapper)){
          alert("Mapper not ready yet. Try again after the page finishes loading.");
          return;
        }
        await window.MailTraceUI.actions.openMapper();
      };
    }
    if(reset){
      reset.onclick = ()=>{
        try{ localStorage.setItem("mt_column_mapping_v1","{}"); }catch{}
        window.MailTraceUI.flags.forceRemap = true;
        alert("Saved mapping cleared. You'll be prompted to remap on the next Run.");
      };
    }
  }
  document.addEventListener("DOMContentLoaded", bindMapControls);
  setTimeout(bindMapControls, 1000);

  const runBtn = document.getElementById("runBtn");
  if(runBtn){
    runBtn.addEventListener("click", async (ev)=>{
      if(window.MailTraceUI && window.MailTraceUI.flags && window.MailTraceUI.flags.forceRemap){
        ev.preventDefault(); ev.stopPropagation();
        try{
          if(!(window.MailTraceUI.actions && window.MailTraceUI.actions.openMapper)){
            throw new Error("Mapper not available yet.");
          }
          await window.MailTraceUI.actions.openMapper();
          window.MailTraceUI.flags.forceRemap = false;
        }catch(err){
          console.error(err);
          return;
        }
      }
    }, true);
  }
})();
</script>
<script id="mtMapperAssist">
(function(){
  function ensureModal(){
    if(document.getElementById("mtMapperOverlay")) return;
    const head = document.head || document.getElementsByTagName('head')[0];
    if(!document.querySelector('style[data-mtmodal]')){
      const st = document.createElement('style'); st.setAttribute('data-mtmodal','1');
      st.textContent = `
/* === Column Mapper Modal (scoped, ensured) === */
#mtMapperOverlay{position:fixed; inset:0; background:rgba(5,12,20,.55); display:none; align-items:center; justify-content:center; z-index:9999;}
#mtMapperModal{background:#0f172a; color:#e5eef9; border:1px solid rgba(255,255,255,.06); border-radius:16px; width:min(980px, 94vw); max-height:86vh; overflow:auto; box-shadow:0 24px 80px rgba(0,0,0,.4)}
#mtMapperModal header{display:flex; align-items:center; justify-content:space-between; padding:14px 18px; border-bottom:1px solid rgba(255,255,255,.06); position:sticky; top:0; background:#0f172a}
#mtMapperModal header h3{margin:0; font-size:18px}
#mtMapperModal .body{padding:16px 18px}
#mtMapperModal .grid{display:grid; grid-template-columns:1.2fr 1.2fr; gap:14px 20px}
#mtMapperModal .col{background:#0b1220; border:1px solid rgba(255,255,255,.05); border-radius:12px; padding:12px}
#mtMapperModal .col h4{margin:.2rem 0 .6rem; font-size:14px; opacity:.9}
#mtMapperModal .row{display:grid; grid-template-columns:1.1fr 1.6fr; gap:10px; align-items:center; padding:6px 0; border-bottom:1px dashed rgba(255,255,255,.06)}
#mtMapperModal .row:last-child{border-bottom:none}
#mtMapperModal label{font-size:13px; color:#9fb2c8}
#mtMapperModal select{background:#0f172a; color:#e5eef9; border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:8px 10px; font-size:13px}
#mtMapperModal .samples{font-size:12px; opacity:.85; margin-top:6px; line-height:1.2}
#mtMapperModal .req{color:#f4b400; font-size:12px; margin-left:6px}
#mtMapperModal .missing{color:#f87171; font-weight:600}
#mtMapperModal footer{display:flex; gap:10px; justify-content:flex-end; padding:14px 18px; border-top:1px solid rgba(255,255,255,.06); position:sticky; bottom:0; background:#0f172a}
#mtMapperModal .btn{background:#1f2937; color:#e5eef9; border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:.6rem 1rem; font-weight:700; cursor:pointer}
#mtMapperModal .btn.primary{background:#16a34a; border-color:transparent; color:#fff}
#mtMapperModal .btn.ghost{background:transparent; border-color:rgba(255,255,255,.12)}
#mtMapperHelp{font-size:12px; color:#9fb2c8; margin:0 0 10px}
`;
      head.appendChild(st);
    }
    const div = document.createElement('div');
    div.innerHTML = `
<!-- Ensured Column Mapper Modal -->
<div id="mtMapperOverlay" aria-hidden="true">
  <div id="mtMapperModal" role="dialog" aria-modal="true" aria-labelledby="mtMapperTitle">
    <header>
      <h3 id="mtMapperTitle">Map your columns</h3>
      <button class="btn ghost" id="mtMapperClose">Close</button>
    </header>
    <div class="body">
      <p id="mtMapperHelp">We couldn't automatically detect some columns. Map the fields below and we'll remember them for next time.</p>
      <div class="grid">
        <div class="col" id="mtMapMail">
          <h4>Mail CSV</h4>
          <div class="rows"></div>
        </div>
        <div class="col" id="mtMapCRM">
          <h4>CRM CSV</h4>
          <div class="rows"></div>
        </div>
      </div>
    </div>
    <footer>
      <button class="btn ghost" id="mtMapperAuto">Auto‑map</button>
      <div style="flex:1"></div>
      <button class="btn" id="mtMapperCancel">Cancel</button>
      <button class="btn primary" id="mtMapperApply">Use mapping</button>
    </footer>
  </div>
</div>
`;
    document.body.appendChild(div.firstElementChild);
  }

  async function openMapperFlow(){
    ensureModal();
    if(typeof openColumnMapper !== "function"){
      alert("Mapping UI hasn't initialized yet. Please try again in a second.");
      return;
    }
    const mf = document.getElementById("mailCsv")?.files?.[0];
    const cf = document.getElementById("crmCsv")?.files?.[0];
    if(!mf || !cf){ alert("Please choose both CSV files first."); return; }
    const [mailText, crmText] = await Promise.all([mf.text(), cf.text()]);
    try{
      const st = computeState(mailText, crmText);
      const payload = {
        mailHeaders: st.mail.header, crmHeaders: st.crm.header,
        mailRows: st.mail.rows.slice(0,200), crmRows: st.crm.rows.slice(0,200),
        SYN: st.SYN, auto: {}
      };
      const mapping = await openColumnMapper(payload);
      if(mapping){
        const newState = computeState(mailText, crmText, mapping);
        window.MailTraceUI = window.MailTraceUI || {};
        window.MailTraceUI.state = newState;
        window.MailTraceUI.render?.all && window.MailTraceUI.render.all();
      }
    }catch(e){
      if(e && e.__isMappingError){
        const mapping = await openColumnMapper(e.payload);
        if(mapping){
          const newState = computeState(mailText, crmText, mapping);
          window.MailTraceUI = window.MailTraceUI || {};
          window.MailTraceUI.state = newState;
          window.MailTraceUI.render?.all && window.MailTraceUI.render.all();
        }
      }else{
        console.error(e); (window.showError||alert)(e.stack||String(e));
      }
    }
  }

  function bind(){
    const edit = document.getElementById("mtEditMap");
    const reset = document.getElementById("mtResetMap");
    if(edit){ edit.onclick = ()=>openMapperFlow(); }
    if(reset){ reset.onclick = ()=>{ try{ localStorage.setItem("mt_column_mapping_v1","{}"); }catch{}; openMapperFlow(); }; }
  }
  document.addEventListener("DOMContentLoaded", bind);
  setTimeout(bind, 1000);
})();
</script>
<script id="mtMapper_v6_clear">
(function(){
  function ensureClearButton(){
    const overlay = document.getElementById("mtMapperOverlay");
    const footer = overlay && overlay.querySelector("footer");
    if(!footer) return;
    if(document.getElementById("mtMapperClear")) return;
    const clearBtn = document.createElement("button");
    clearBtn.id = "mtMapperClear";
    clearBtn.className = "btn ghost";
    clearBtn.textContent = "Clear saved mapping";
    footer.insertBefore(clearBtn, footer.firstElementChild); // place left of Auto-map
    clearBtn.onclick = ()=>{
      try{ localStorage.setItem("mt_column_mapping_v1","{}"); }catch{}
      // Empty all selects in the modal and refresh samples/help
      document.querySelectorAll("#mtMapperModal select").forEach(sel=>{
        sel.value = ""; sel.dispatchEvent(new Event("change"));
      });
      const help = document.getElementById("mtMapperHelp");
      if(help) help.textContent = "Cleared saved mapping — please map required fields.";
    };
  }
  // Re-ensure the button whenever overlay is shown
  const obs = new MutationObserver(()=>{
    const ov = document.getElementById("mtMapperOverlay");
    if(ov && ov.style.display !== "none") ensureClearButton();
  });
  document.addEventListener("DOMContentLoaded", ()=>{
    try{
      const ov = document.getElementById("mtMapperOverlay");
      if(ov) obs.observe(ov, {attributes:true, attributeFilter:["style"]});
    }catch{}
    // one-time ensure in case modal is already open
    setTimeout(ensureClearButton, 800);
  });
})();
</script>
<script id="mtMapperAssist_v7">
(function(){
  // Minimal CSV parser with quote handling; autodetects delimiter (comma, semicolon, or tab)
  function detectDelim(line){
    const counts = {",": (line.match(/,/g)||[]).length, ";": (line.match(/;/g)||[]).length, "\t": (line.match(/\t/g)||[]).length};
    let best = ","; let max = -1;
    for(const [k,v] of Object.entries(counts)){ if(v>max){ max=v; best=k; } }
    return (max>0)? best : ",";
  }
  function parseCSV(text, limitRows=200){
    const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
    if(!lines.length) return {header:[], rows:[]};
    const delim = detectDelim(lines[0]);
    function splitLine(s){
      const out=[]; let cur=""; let q=false; for(let i=0;i<s.length;i++){
        const c=s[i];
        if(c==='\"'){
          if(q && s[i+1]==='\"'){ cur+='\"'; i++; } else { q=!q; }
        }else if(c===delim && !q){ out.push(cur); cur=""; }
        else { cur+=c; }
      }
      out.push(cur);
      return out.map(t=>t.trim());
    }
    const header = splitLine(lines[0]).map(h=>h || "");
    const rows=[];
    for(let li=1; li<lines.length && rows.length<limitRows; li++){
      if(lines[li].trim()==="") continue;
      const cells = splitLine(lines[li]);
      const obj={};
      for(let i=0;i<header.length;i++){ obj[header[i]||`col${i+1}`] = (cells[i]!==undefined? cells[i]: ""); }
      rows.push(obj);
    }
    return {header, rows};
  }

  async function openMapperFromCSVs(){
    // Ensure modal exists
    if(!document.getElementById("mtMapperOverlay")){
      // If prior ensure script added modal CSS/HTML, rely on it; if not, warn
      if(!document.getElementById("mtMapperModal")){
        alert("Mapping UI not ready. Please reload the page.");
        return;
      }
    }

    const mf = document.getElementById("mailCsv")?.files?.[0];
    const cf = document.getElementById("crmCsv")?.files?.[0];
    if(!mf || !cf){ alert("Please choose both CSV files first."); return; }

    const [mailText, crmText] = await Promise.all([mf.text(), cf.text()]);
    const mail = parseCSV(mailText, 200);
    const crm  = parseCSV(crmText, 200);

    const payload = {
      mailHeaders: mail.header, crmHeaders: crm.header,
      mailRows: mail.rows, crmRows: crm.rows,
      SYN: {
        first_name: ["first name","firstname","fname","given name","givenname","first"],
        last_name:  ["last name","lastname","lname","surname","family name","familyname","last"],
        address1:   ["address 1","address1","addr1","street","street address","primarylocation","linea","line 1","address line 1"],
        address2:   ["address 2","address2","addr2","line2","secondarylocation","apartment","apt","unit","suite","ste","#"],
        city:       ["city","cityname","town","locality"],
        state:      ["state","stateprov","region","province","st","state code"],
        zip:        ["zip","zipcode","postal","postalcode"],
        mail_date:  ["mailed","maileddate","mailedon","mail date","mailed on"],
        crm_date:   ["crmdate","date","created","updated","last activity","activity date"],
        amount:     ["amount","amountusd","value","total","sum","revenue","donation","paid"]
      },
      auto: {}
    };

    try{
      const mapping = await openColumnMapper(payload);
      if(mapping){
        // If computeState is available, recompute state and render; otherwise we stop here
        try{
          if(typeof computeState === "function"){
            const newState = computeState(mailText, crmText, mapping);
            window.MailTraceUI = window.MailTraceUI || {};
            window.MailTraceUI.state = newState;
            window.MailTraceUI.render?.all && window.MailTraceUI.render.all();
          }
        }catch(e){
          console.error("computeState post-map failed:", e);
          (window.showError||alert)("Mapped columns saved, but rendering failed. Try Run again.");
        }
      }
    }catch(e){
      console.error("openColumnMapper failed:", e);
      (window.showError||alert)(e.stack||String(e));
    }
  }

  function bind(){
    const edit = document.getElementById("mtEditMap");
    if(edit){ edit.onclick = ()=>openMapperFromCSVs(); }
    // Keep Reset hidden if present; modal has its own "Clear saved mapping" anyway
    const reset = document.getElementById("mtResetMap");
    if(reset){ reset.style.display = "none"; reset.onclick = ()=>openMapperFromCSVs(); }
  }
  document.addEventListener("DOMContentLoaded", bind);
  setTimeout(bind, 1000);
})();
</script>
<script id="mtMapper_v8_smart">
(function(){
  // Checkers (same logic as validator)
  const US_STATES = new Set(["AL","AK","AZ","AR","CA","CO","CT","DC","DE","FL","GA","HI","IA","ID","IL","IN","KS","KY","LA","MA","MD","ME","MI","MN","MO","MS","MT","NC","ND","NE","NH","NJ","NM","NV","NY","OH","OK","OR","PA","PR","RI","SC","SD","TN","TX","UT","VA","VI","VT","WA","WI","WV","WY"]);
  const DATE_MIN = new Date(2000,0,1).getTime();
  const DATE_MAX = new Date(2100,0,1).getTime();
  const isName    = s => /^[A-Za-z .'\-]{2,}$/.test(s||"");
  const isAddress1= s => !!s && s.length>=5 && /\d/.test(s) && /[A-Za-z]/.test(s);
  const isAddress2= s => !!s && (/apt|unit|ste|suite|#|fl|floor|bldg|building|lot|trlr|trailer|rm|room/i.test(s) || s.length>=2);
  const isCity    = s => /^[A-Za-z .'\-]{2,}$/.test(s||"");
  const isState   = s => { const t=(s||"").trim(); return US_STATES.has(t.toUpperCase()) || /^[A-Za-z .'\-]{3,}$/.test(t); };
  const isZip     = s => /^\d{5}(-\d{4})?$/.test(String(s||"").trim());
  const isDate    = s => { const t=Date.parse(s); return !Number.isNaN(t) && t>=DATE_MIN && t<=DATE_MAX; };
  const isAmount  = s => { const t=String(s??"").replace(/[$,]/g,"").trim(); if(!t) return false; const n=Number(t); return Number.isFinite(n); };

  function sampleScore(rows, col, check, cap=200){
    let ok=0, tot=0;
    for(const r of rows){
      const v = (r[col] ?? "").toString().trim();
      if(v==="") continue;
      tot++; if(check(v)) ok++;
      if(tot>=cap) break;
    }
    return tot ? (ok/tot) : 0;
  }

  function normalize(s){ return (s||"").toLowerCase().replace(/[\s_\-]/g,""); }
  function containsToken(name, tokens){
    const low = (name||"").toLowerCase();
    return tokens.some(t => low.includes(t));
  }

  const LABELS = {
    first_name:"First Name", last_name:"Last Name", address1:"Address 1", address2:"Address 2",
    city:"City", state:"State", zip:"ZIP", mail_date:"Mail Date", crm_date:"CRM Date", amount:"Amount"
  };
  const CHECKERS = {
    first_name: isName, last_name: isName, address1: isAddress1, address2: isAddress2,
    city: isCity, state: isState, zip: isZip, mail_date: isDate, crm_date: isDate, amount: isAmount
  };
  const REQ_MAIL = ["address1","address2","city","state","zip","mail_date"];
  const REQ_CRM  = ["address1","address2","city","state","zip","crm_date","amount"];

  function smartSuggest(headers, rows, SYN){
    const picks = {};
    const used = new Set();
    const normalizedSyn = {};
    for(const [k, arr] of Object.entries(SYN)){
      normalizedSyn[k] = (arr||[]).map(a=>normalize(a));
    }

    for(const key of Object.keys(CHECKERS)){
      const checker = CHECKERS[key];
      let best = {col:"", score:-1};
      for(const col of headers){
        if(used.has(col)) continue;
        const colNorm = normalize(col);
        const syns = normalizedSyn[key] || [];
        const exact = syns.includes(colNorm) ? 1 : 0;
        const partial = (!exact && containsToken(col, syns)) ? 1 : 0;
        // Header score: weigh exact match higher than partial
        const headerScore = exact ? 0.7 : (partial ? 0.35 : 0);

        // Data score
        const dataScore = sampleScore(rows, col, checker);

        // Total weighted score
        const total = headerScore + (0.8 * dataScore);

        // Prefer columns that at least have some non-empty data
        if(total > best.score && (dataScore > 0.05 || headerScore > 0)){
          best = {col, score: total, dataScore, headerScore};
        }
      }
      // Thresholds: be looser for address2, stricter for others
      const minData = (key==="address2") ? 0.15 : (key==="amount" ? 0.35 : 0.4);
      if(best.col && (best.dataScore >= minData || best.headerScore >= 0.7)){
        picks[key] = best.col;
        used.add(best.col);
      }
    }
    return picks;
  }

  async function openColumnMapperSmart(payload){
    return new Promise(resolve => {
      const overlay = document.getElementById("mtMapperOverlay");
      if(!overlay){ alert("Mapping UI not loaded yet."); return resolve(null); }
      const $mail = document.querySelector("#mtMapMail .rows");
      const $crm  = document.querySelector("#mtMapCRM .rows");
      $mail.innerHTML = ""; $crm.innerHTML = "";

      const state = { map:{ mail:{}, crm:{} } };

      function uniqueSamples(rows, col, limit=4){
        if(!col) return [];
        const seen = new Set(), out = [];
        for(const r of rows){
          const v = (r[col] ?? "").toString().trim();
          if(!v) continue;
          if(!seen.has(v)){ seen.add(v); out.push(v); if(out.length>=limit) break; }
        }
        return out;
      }
      function readMapping(){ try{ return JSON.parse(localStorage.getItem("mt_column_mapping_v1")||"{}"); }catch{ return {}; } }
      function saveMapping(map){ try{ localStorage.setItem("mt_column_mapping_v1", JSON.stringify(map||{})); }catch{} }

      function makeRow(side, key, label, optional=false){
        const headers = side==="mail" ? payload.mailHeaders : payload.crmHeaders;
        const rows    = side==="mail" ? payload.mailRows : payload.crmRows;
        const wrap = document.createElement("div"); wrap.className="row";
        const lab = document.createElement("label");
        lab.textContent = label;
        if(!optional){
          const badge = document.createElement("span"); badge.className="req"; badge.textContent="required"; lab.appendChild(badge);
        }
        const sel = document.createElement("select");
        sel.innerHTML = `<option value="">— Select column —</option>` + headers.map(h=>`<option value="${h}">${h}</option>`).join("");

        const samples = document.createElement("div"); samples.className="samples";
        function updateSamples(){
          const col = sel.value;
          if(!col){ samples.innerHTML = ""; return; }
          const vals = uniqueSamples(rows, col, 4);
          samples.innerHTML = vals.length? ("e.g. " + vals.join(" · ")) : "";
        }
        sel.addEventListener("change", updateSamples);
        wrap.appendChild(lab); wrap.appendChild(sel); wrap.appendChild(samples);
        (side==="mail" ? $mail : $crm).appendChild(wrap);
        state.map[side][key] = sel;
      }

      // Build rows (First/Last optional; others required)
      const fieldsMail = [
        ["first_name","First Name (optional)", true],
        ["last_name","Last Name (optional)", true],
        ["address1","Address 1", false],
        ["address2","Address 2", false],
        ["city","City", false],
        ["state","State", false],
        ["zip","ZIP", false],
        ["mail_date","Mail Date", false],
      ];
      const fieldsCRM = [
        ["first_name","First Name (optional)", true],
        ["last_name","Last Name (optional)", true],
        ["address1","Address 1", false],
        ["address2","Address 2", false],
        ["city","City", false],
        ["state","State", false],
        ["zip","ZIP", false],
        ["crm_date","CRM Date", false],
        ["amount","Amount", false],
      ];
      for(const [k,lbl,opt] of fieldsMail) makeRow("mail",k,lbl,opt);
      for(const [k,lbl,opt] of fieldsCRM) makeRow("crm",k,lbl,opt);

      // Hide Auto‑map button (legacy)
      const autoBtn = document.getElementById("mtMapperAuto");
      if(autoBtn) autoBtn.style.display = "none";

      // Compose synonyms (payload.SYN may include more)
      const SYN = Object.assign({
        first_name: ["first name","firstname","fname","given name","givenname","first"],
        last_name:  ["last name","lastname","lname","surname","family name","familyname","last"],
        address1:   ["address 1","address1","addr1","street","street address","primarylocation","linea","line 1","address line 1"],
        address2:   ["address 2","address2","addr2","line2","secondarylocation","apartment","apt","unit","suite","ste","#"],
        city:       ["city","cityname","town","locality"],
        state:      ["state","stateprov","region","province","st","state code"],
        zip:        ["zip","zipcode","postal","postalcode"],
        mail_date:  ["mailed","maileddate","mailedon","mail date","mailed on"],
        crm_date:   ["crmdate","date","created","updated","last activity","activity date"],
        amount:     ["amount","amountusd","value","total","sum","revenue","donation","paid"]
      }, payload.SYN||{});

      // Build suggestions: prefer saved mapping if present & valid; otherwise smart suggest
      const saved = readMapping();
      const mailHeaders = payload.mailHeaders || [];
      const crmHeaders  = payload.crmHeaders  || [];
      function exists(side, col){ return (side==="mail"? mailHeaders:crmHeaders).includes(col); }

      let suggestMail = smartSuggest(mailHeaders, payload.mailRows||[], SYN);
      let suggestCRM  = smartSuggest(crmHeaders,  payload.crmRows||[],  SYN);

      // Overlay saved mapping where columns still exist
      for(const [k,v] of Object.entries(saved.mail||{})){ if(exists("mail", v)) suggestMail[k]=v; }
      for(const [k,v] of Object.entries(saved.crm||{})){ if(exists("crm", v))  suggestCRM[k]=v; }

      // Apply suggestions to selects
      function applySuggestions(side, sugg){
        for(const [k,v] of Object.entries(sugg||{})){
          const sel = state.map[side][k];
          if(sel && v && (side==="mail" ? mailHeaders.includes(v) : crmHeaders.includes(v))){
            sel.value = v; sel.dispatchEvent(new Event("change"));
          }
        }
      }
      applySuggestions("mail", suggestMail);
      applySuggestions("crm",  suggestCRM);

      function collect(){
        const map = { mail:{}, crm:{} };
        for(const side of ["mail","crm"]){
          for(const key of Object.keys(state.map[side])){
            const sel = state.map[side][key];
            if(sel && sel.value) map[side][key] = sel.value;
          }
        }
        return map;
      }
      function validate(map){
        const miss = [];
        const label = s => s.replace("_"," ").replace(/\b\w/g, c => c.toUpperCase());
        for(const k of REQ_MAIL){ if(!map.mail[k]) miss.push("Mail: " + label(k)); }
        for(const k of REQ_CRM){  if(!map.crm[k])  miss.push("CRM: " + label(k)); }
        return miss;
      }
      function close(){ overlay.style.display="none"; overlay.setAttribute("aria-hidden","true"); }

      document.getElementById("mtMapperClose").onclick = ()=>{ close(); resolve(null); };
      document.getElementById("mtMapperCancel").onclick = ()=>{ close(); resolve(null); };
      document.getElementById("mtMapperApply").onclick = ()=>{
        const map = collect();
        const miss = validate(map);
        if(miss.length){
          document.getElementById("mtMapperHelp").innerHTML = 'Missing required mappings: <span class="missing">'+miss.join(", ")+'</span>';
          return;
        }
        saveMapping(map);
        close();
        resolve(map);
      };

      overlay.style.display="flex"; overlay.setAttribute("aria-hidden","false");
    });
  }

  // Replace existing openColumnMapper with our smarter version
  window.openColumnMapper = openColumnMapperSmart;
})();
</script>
<!-- v9 popup -->
<div aria-hidden="true" id="mtPopupOverlay">
<div aria-labelledby="mtPopupTitle" aria-modal="true" id="mtPopup" role="alertdialog">
<header>
<h3 id="mtPopupTitle">Missing required mappings</h3>
<button class="btn" id="mtPopupClose" title="Close">Close</button>
</header>
<div class="body">
<p>We couldn’t proceed because the following required fields aren’t mapped yet:</p>
<ul id="mtPopupList"></ul>
</div>
<footer>
<button class="btn primary" id="mtPopupOk">OK—take me back</button>
</footer>
</div>
</div>
<script id="mtMapper_v9_popup">
(function(){
  function ensurePopup(){
    if(document.getElementById("mtPopupOverlay")) return;
    const head = document.head || document.getElementsByTagName('head')[0];
    if(!document.querySelector('style[data-mtpopup]')){
      const st = document.createElement('style'); st.setAttribute('data-mtpopup','1');
      st.textContent = `
/* v9: prominent popup for missing required mappings */
#mtPopupOverlay{position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:10000;}
#mtPopup{background:#111827; color:#f9fafb; border:1px solid rgba(255,255,255,.12); border-radius:16px; width:min(620px, 92vw); box-shadow:0 20px 70px rgba(0,0,0,.45)}
#mtPopup header{display:flex; align-items:center; justify-content:space-between; padding:14px 18px; border-bottom:1px solid rgba(255,255,255,.08)}
#mtPopup header h3{margin:0; font-size:18px}
#mtPopup .body{padding:16px 18px}
#mtPopup .body ul{margin:.25rem 0 .5rem 1rem; padding:0}
#mtPopup .body li{margin:.25rem 0; font-size:14px}
#mtPopup footer{display:flex; gap:10px; justify-content:flex-end; padding:14px 18px; border-top:1px solid rgba(255,255,255,.08)}
#mtPopup .btn{background:#1f2937; color:#e5eef9; border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:.55rem 1rem; font-weight:700; cursor:pointer}
#mtPopup .btn.primary{background:#dc2626; border-color:transparent; color:#fff}
/* highlight missing selects */
.mt-missing { outline:2px solid #dc2626 !important; box-shadow:0 0 0 3px rgba(220,38,38,.3); }
@keyframes mt-shake { 10%, 90% { transform: translateX(-1px);} 20%, 80% { transform: translateX(2px);} 30%, 50%, 70% { transform: translateX(-4px);} 40%, 60% { transform: translateX(4px);} }
.mt-shake { animation: mt-shake .45s ease-in-out both; }
`;
      head.appendChild(st);
    }
    const c = document.createElement('div');
    c.innerHTML = `
<!-- v9 popup -->
<div id="mtPopupOverlay" aria-hidden="true">
  <div id="mtPopup" role="alertdialog" aria-modal="true" aria-labelledby="mtPopupTitle">
    <header>
      <h3 id="mtPopupTitle">Missing required mappings</h3>
      <button class="btn" id="mtPopupClose" title="Close">Close</button>
    </header>
    <div class="body">
      <p>We couldn’t proceed because the following required fields aren’t mapped yet:</p>
      <ul id="mtPopupList"></ul>
    </div>
    <footer>
      <button class="btn primary" id="mtPopupOk">OK—take me back</button>
    </footer>
  </div>
</div>
`;
    document.body.appendChild(c.firstElementChild);
  }

  function showPopup(items){
    ensurePopup();
    const ov = document.getElementById("mtPopupOverlay");
    const ul = document.getElementById("mtPopupList");
    ul.innerHTML = (items||[]).map(x=>`<li>${x}</li>`).join("");
    ov.style.display="flex";
    ov.setAttribute("aria-hidden","false");
    const close = ()=>{ ov.style.display="none"; ov.setAttribute("aria-hidden","true"); };
    document.getElementById("mtPopupClose").onclick = close;
    document.getElementById("mtPopupOk").onclick = close;
  }

  // Map label text back to field keys for highlighting
  const LABEL_TO_KEY = {
    "first name":"first_name",
    "last name":"last_name",
    "address 1":"address1",
    "address 2":"address2",
    "city":"city",
    "state":"state",
    "zip":"zip",
    "mail date":"mail_date",
    "crm date":"crm_date",
    "amount":"amount"
  };

  // Monkey-patch current openColumnMapper to add popup + highlight behavior
  const prevOpen = window.openColumnMapper;
  window.openColumnMapper = async function(payload){
    // Call current implementation to render the modal UI (fields & selects)
    const result = await (async ()=>{
      // We need the UI built before we can hook Apply
      return new Promise(resolve => {
        // Temporarily wrap apply after UI build by observing overlay visibility
        const runOnce = async ()=>{
          // Attach our handler
          const apply = document.getElementById("mtMapperApply");
          const help  = document.getElementById("mtMapperHelp");
          if(apply && !apply.__mtV9Bound){
            apply.__mtV9Bound = true;
            const orig = apply.onclick;
            apply.onclick = (ev)=>{
              // Let original handler compute miss list via DOM text if it sets help, but we intercept first
              // Instead, reconstruct missing list by reading selects marked required and empty.
              const fieldsMail = [
                ["first_name",true],["last_name",true],["address1",false],["address2",false],["city",false],["state",false],["zip",false],["mail_date",false]
              ];
              const fieldsCRM = [
                ["first_name",true],["last_name",true],["address1",false],["address2",false],["city",false],["state",false],["zip",false],["crm_date",false],["amount",false]
              ];
              const rows = [];
              function checkSide(side, list){
                for(const [key, optional] of list){
                  if(optional) continue;
                  const sel = (side==="mail"
                                ? document.querySelector("#mtMapMail .rows select:nth-of-type(" + (Object.keys(LABEL_TO_KEY).indexOf(key)>=0 ? 1 : 1) + ")")
                                : document.querySelector("#mtMapCRM .rows select:nth-of-type(" + (Object.keys(LABEL_TO_KEY).indexOf(key)>=0 ? 1 : 1) + ")"));
                }
              }
              // Build miss list by scanning the mapping rows we constructed earlier
              const reqMail = ["address1","address2","city","state","zip","mail_date"];
              const reqCRM  = ["address1","address2","city","state","zip","crm_date","amount"];
              const missItems = [];
              // helper to find select by field key
              function findSelect(side, key){
                const label = (side==="mail" ? document.querySelectorAll("#mtMapMail .row label") : document.querySelectorAll("#mtMapCRM .row label"));
                const selects = (side==="mail" ? document.querySelectorAll("#mtMapMail .row select") : document.querySelectorAll("#mtMapCRM .row select"));
                for(let i=0;i<label.length;i++){
                  const txt = label[i].textContent.toLowerCase();
                  const short = (key.replace("_"," ") + (key.endsWith("_date")? "" : "")).toLowerCase();
                  // match by includes to be resilient
                  if(txt.includes(short)){
                    return selects[i];
                  }
                }
                return null;
              }
              const missingPairs = [];
              for(const k of reqMail){
                const sel = findSelect("mail", k);
                if(sel && !sel.value){ missItems.push("Mail → " + k.replace("_"," ").replace(/\b\w/g,c=>c.toUpperCase())); missingPairs.push(["mail",k,sel]); }
              }
              for(const k of reqCRM){
                const sel = findSelect("crm", k);
                if(sel && !sel.value){ missItems.push("CRM → " + k.replace("_"," ").replace(/\b\w/g,c=>c.toUpperCase())); missingPairs.push(["crm",k,sel]); }
              }
              if(missItems.length){
                ev && ev.preventDefault();
                if(help) help.textContent = " ";
                // highlight selects and scroll first into view
                missingPairs.forEach(([side,k,sel],idx)=>{
                  sel.classList.remove("mt-missing","mt-shake");
                  void sel.offsetWidth; // reflow
                  sel.classList.add("mt-missing","mt-shake");
                  if(idx===0){
                    sel.scrollIntoView({behavior:"smooth", block:"center"});
                    sel.focus({preventScroll:true});
                  }
                });
                showPopup(missItems);
                return false;
              }
              // No missing → run original click handler
              return orig ? orig.call(apply, ev) : null;
            };
          }
          resolve(await prevOpen(payload));
        };
        // If overlay already exists, run immediately, else after open completes
        runOnce();
      });
    })();
    return result;
  };
})();
</script>
<script id="mtMapper_v10_enforce">
(function(){
  // Ensure popup exists
  function ensurePopup(){
    if(document.getElementById("mtPopupOverlay")) return;
    const head = document.head || document.getElementsByTagName('head')[0];
    if(!document.querySelector('style[data-mtpopup]')){
      const st = document.createElement('style'); st.setAttribute('data-mtpopup','1');
      st.textContent = `
/* ensure v9 popup styles present */
#mtPopupOverlay{position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:10000;}
#mtPopup{background:#111827; color:#f9fafb; border:1px solid rgba(255,255,255,.12); border-radius:16px; width:min(620px, 92vw); box-shadow:0 20px 70px rgba(0,0,0,.45)}
#mtPopup header{display:flex; align-items:center; justify-content:space-between; padding:14px 18px; border-bottom:1px solid rgba(255,255,255,.08)}
#mtPopup header h3{margin:0; font-size:18px}
#mtPopup .body{padding:16px 18px}
#mtPopup .body ul{margin:.25rem 0 .5rem 1rem; padding:0}
#mtPopup .body li{margin:.25rem 0; font-size:14px}
#mtPopup footer{display:flex; gap:10px; justify-content:flex-end; padding:14px 18px; border-top:1px solid rgba(255,255,255,.08)}
#mtPopup .btn{background:#1f2937; color:#e5eef9; border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:.55rem 1rem; font-weight:700; cursor:pointer}
#mtPopup .btn.primary{background:#dc2626; border-color:transparent; color:#fff}
.mt-missing { outline:2px solid #dc2626 !important; box-shadow:0 0 0 3px rgba(220,38,38,.3); }
@keyframes mt-shake { 10%, 90% { transform: translateX(-1px);} 20%, 80% { transform: translateX(2px);} 30%, 50%, 70% { transform: translateX(-4px);} 40%, 60% { transform: translateX(4px);} }
.mt-shake { animation: mt-shake .45s ease-in-out both; }
`;
      head.appendChild(st);
    }
    const c = document.createElement('div');
    c.innerHTML = `
<!-- ensure v9 popup present -->
<div id="mtPopupOverlay" aria-hidden="true">
  <div id="mtPopup" role="alertdialog" aria-modal="true" aria-labelledby="mtPopupTitle">
    <header>
      <h3 id="mtPopupTitle">Missing required mappings</h3>
      <button class="btn" id="mtPopupClose" title="Close">Close</button>
    </header>
    <div class="body">
      <p>We couldn’t proceed because the following required fields aren’t mapped yet:</p>
      <ul id="mtPopupList"></ul>
    </div>
    <footer>
      <button class="btn primary" id="mtPopupOk">OK—take me back</button>
    </footer>
  </div>
</div>
`;
    document.body.appendChild(c.firstElementChild);
  }
  function showPopup(list){
    ensurePopup();
    const ov = document.getElementById("mtPopupOverlay");
    const ul = document.getElementById("mtPopupList");
    ul.innerHTML = (list||[]).map(x=>`<li>${x}</li>`).join("");
    ov.style.display="flex"; ov.setAttribute("aria-hidden","false");
    const close = ()=>{ ov.style.display="none"; ov.setAttribute("aria-hidden","true"); };
    document.getElementById("mtPopupClose").onclick = close;
    document.getElementById("mtPopupOk").onclick = close;
  }
  function labelize(k){
    return k.replace("_"," ").replace(/\b\w/g,c=>c.toUpperCase());
  }
  function findMissing(){
    const reqMail = ["address1","address2","city","state","zip","mail_date"];
    const reqCRM  = ["address1","address2","city","state","zip","crm_date","amount"];
    const out = [];
    const pairs = [];
    function scan(side, req){
      const container = side==="mail" ? document.querySelector("#mtMapMail .rows") : document.querySelector("#mtMapCRM .rows");
      if(!container) return;
      const rows = Array.from(container.querySelectorAll(".row"));
      for(const key of req){
        // find label row that contains key text
        let sel = null;
        for(const r of rows){
          const lab = r.querySelector("label");
          const s = r.querySelector("select");
          if(!lab || !s) continue;
          const txt = (lab.textContent||"").toLowerCase();
          const target = key.replace("_"," ");
          if(txt.includes(target)){
            sel = s; break;
          }
        }
        if(sel && !sel.value){
          out.push((side==="mail"?"Mail":"CRM") + " → " + labelize(key));
          pairs.push(sel);
        }
      }
      return {out, pairs};
    }
    scan("mail", reqMail); scan("crm", reqCRM);
    return {list: out, selects: pairs};
  }
  function highlight(selects){
    if(!selects || !selects.length) return;
    selects.forEach((sel,idx)=>{
      sel.classList.remove("mt-missing","mt-shake"); void sel.offsetWidth;
      sel.classList.add("mt-missing","mt-shake");
      if(idx===0){ sel.scrollIntoView({behavior:"smooth", block:"center"}); sel.focus({preventScroll:true}); }
    });
  }

  // Capture click on Apply to pre-empt any existing handler
  function onClickCapture(ev){
    const tgt = ev.target.closest && ev.target.closest("#mtMapperApply");
    if(!tgt) return;
    const miss = findMissing();
    if(miss.list.length){
      ev.preventDefault(); ev.stopImmediatePropagation(); ev.stopPropagation();
      // Clear any subtle top message if present
      const help = document.getElementById("mtMapperHelp");
      if(help) help.textContent = " ";
      highlight(miss.selects);
      showPopup(miss.list);
    }
  }
  document.addEventListener("click", onClickCapture, true); // CAPTURE phase

  // Also re-attach when the mapper opens (for safety)
  const obs = new MutationObserver(()=>{
    const apply = document.getElementById("mtMapperApply");
    if(apply && !apply.__mtV10Bound){
      apply.__mtV10Bound = true;
      // no-op; our capture handler already intercepts earlier than target handlers
    }
  });
  document.addEventListener("DOMContentLoaded", ()=>{
    try{ obs.observe(document.body, {childList:true, subtree:true}); }catch{}
  });
})();
</script>
<script id="mtMapper_v12_improveDates">
(function(){
  // Patch smartSuggest if present; otherwise define a focused version used by the modal
  function install(){
    const US_STATES = new Set(["AL","AK","AZ","AR","CA","CO","CT","DC","DE","FL","GA","HI","IA","ID","IL","IN","KS","KY","LA","MA","MD","ME","MI","MN","MO","MS","MT","NC","ND","NE","NH","NJ","NM","NV","NY","OH","OK","OR","PA","PR","RI","SC","SD","TN","TX","UT","VA","VI","VT","WA","WI","WV","WY"]);
    const DATE_MIN = new Date(2000,0,1).getTime();
    const DATE_MAX = new Date(2100,0,1).getTime();
    const isName    = s => /^[A-Za-z .'\-]{2,}$/.test(s||"");
    const isAddress1= s => !!s && s.length>=5 && /\d/.test(s) && /[A-Za-z]/.test(s);
    const isAddress2= s => !!s && (/apt|unit|ste|suite|#|fl|floor|bldg|building|lot|trlr|trailer|rm|room/i.test(s) || s.length>=2);
    const isCity    = s => /^[A-Za-z .'\-]{2,}$/.test(s||"");
    const isState   = s => { const t=(s||"").trim(); return US_STATES.has(t.toUpperCase()) || /^[A-Za-z .'\-]{3,}$/.test(t); };
    const isZip     = s => /^\d{5}(-\d{4})?$/.test(String(s||"").trim());
    const isDate    = s => { const t=Date.parse(s); return !Number.isNaN(t) && t>=DATE_MIN && t<=DATE_MAX; };
    const isAmount  = s => { const t=String(s??"").replace(/[$,]/g,"").trim(); if(!t) return false; const n=Number(t); return Number.isFinite(n); };

    function sampleScore(rows, col, check, cap=200){
      let ok=0, tot=0;
      for(const r of rows){
        const v = (r[col] ?? "").toString().trim();
        if(v==="") continue;
        tot++; if(check(v)) ok++;
        if(tot>=cap) break;
      }
      return tot ? (ok/tot) : 0;
    }

    function normalize(s){ return (s||"").toLowerCase().replace(/[\s_\-]/g,""); }
    function containsToken(name, tokens){
      const low = (name||"").toLowerCase();
      return tokens.some(t => low.includes(t));
    }

    // Expose for debugging if needed
    window.__mt_isDate = isDate;

    function smartSuggestLimited(headers, rows, SYN, wantKeys){
      const CHECKERS = {
        first_name: isName, last_name: isName, address1: isAddress1, address2: isAddress2,
        city: isCity, state: isState, zip: isZip, mail_date: isDate, crm_date: isDate, amount: isAmount
      };
      const normalizedSyn = {};
      for(const [k, arr] of Object.entries(SYN)){
        normalizedSyn[k] = (arr||[]).map(a=>normalize(a));
      }
      const picks = {};
      const used = new Set();
      for(const key of wantKeys){
        const checker = CHECKERS[key];
        let best = {col:"", score:-1, dataScore:0, headerScore:0};
        for(const col of headers){
          if(used.has(col)) continue;
          const colNorm = normalize(col);
          const syns = normalizedSyn[key] || [];
          const exact = syns.includes(colNorm) ? 1 : 0;
          const partial = (!exact && containsToken(col, syns)) ? 1 : 0;
          const headerScore = exact ? 0.7 : (partial ? 0.35 : 0);
          const dataScore = sampleScore(rows, col, checker);
          // Increase weight on data for date fields
          const weight = (key==="crm_date" || key==="mail_date") ? 0.9 : 0.8;
          const total = headerScore + (weight * dataScore);
          // Keep best by total score; tie-break by higher dataScore
          if(total > best.score || (total===best.score && dataScore>best.dataScore)):
              best = {col, score: total, dataScore, headerScore};
        }
        // thresholds
        const minData = (key==="address2") ? 0.15 : (key==="amount" ? 0.35 : (key==="crm_date"||key==="mail_date" ? 0.3 : 0.4));
        if(best.col && (best.dataScore >= minData || best.headerScore >= 0.7)){
          picks[key] = best.col;
          used.add(best.col);
        }
      }
      return picks;
    }

    // Hook into existing openColumnMapper && replace its suggestion phase if we can find it
    const oldOpen = window.openColumnMapper;
    if(typeof oldOpen === "function"){
      window.openColumnMapper = async function(payload){
        // if our sentinel is present, skip (already using v8 smart)
        // We will wrap after the UI is built to apply our limited smart suggestions.
        const res = await oldOpen(payload);
        return res;
      };
    }

    // Provide a helper other parts of the script can call when building the modal
    window.__mt_smartSuggestLimited = smartSuggestLimited;
  }

  try{ install(); }catch(e){ console.error("v12 install failed", e); }
})();
</script>
<script id="mtMapper_v12_hookApply">
(function(){
  function applyLimitedSuggestions(){
    if(!window.__mt_smartSuggestLimited) return;
    const overlay = document.getElementById("mtMapperOverlay");
    if(!overlay || overlay.style.display==="none") return;
    // Collect headers from selects
    const mailHeaders = Array.from(document.querySelectorAll("#mtMapMail .row select option")).map(o=>o.value).filter(Boolean);
    const crmHeaders  = Array.from(document.querySelectorAll("#mtMapCRM .row select option")).map(o=>o.value).filter(Boolean);
    // Build sample rows from visible options is not trivial; rely on payload cached in state if available
    const st = window.MailTraceUI && window.MailTraceUI.state;
    const mailRows = (st && st.mail && st.mail.rows) ? st.mail.rows.slice(0,200) : [];
    const crmRows  = (st && st.crm && st.crm.rows) ? st.crm.rows.slice(0,200) : [];
    const SYN = {
      first_name: ["first name","firstname","fname","given name","givenname","first"],
      last_name:  ["last name","lastname","lname","surname","family name","familyname","last"],
      address1:   ["address 1","address1","addr1","street","street address","primarylocation","linea","line 1","address line 1"],
      address2:   ["address 2","address2","addr2","line2","secondarylocation","apartment","apt","unit","suite","ste","#"],
      city:       ["city","cityname","town","locality"],
      state:      ["state","stateprov","region","province","st","state code"],
      zip:        ["zip","zipcode","postal","postalcode"],
      mail_date:  ["mailed","maileddate","mailedon","mail date","mailed on","postmark","postmarkdate","postmark_dt","postmarkdt","post_date"],
      crm_date:   ["crm","crmdate","date","created","updated","last activity","activity date","closed","closedate","closed_dt","close date","closed date","dt"],
      amount:     ["amount","amountusd","value","total","sum","revenue","donation","paid","invoice","invoice_total"]
    };
    const wantMail = ["first_name","last_name","address1","address2","city","state","zip","mail_date"];
    const wantCRM  = ["first_name","last_name","address1","address2","city","state","zip","crm_date","amount"];
    const suggMail = window.__mt_smartSuggestLimited(mailHeaders, mailRows, SYN, wantMail);
    const suggCRM  = window.__mt_smartSuggestLimited(crmHeaders,  crmRows,  SYN, wantCRM);
    // Apply to selects by label matching
    function apply(side, sugg){
      const labels = Array.from(document.querySelectorAll(side==="mail" ? "#mtMapMail .row label" : "#mtMapCRM .row label")).map(el=>el.textContent.toLowerCase());
      const selects = Array.from(document.querySelectorAll(side==="mail" ? "#mtMapMail .row select" : "#mtMapCRM .row select"));
      function setFor(key, val){
        // find row index by key
        const pretty = key.replace("_"," ");
        for(let i=0;i<labels.length;i++){
          if(labels[i].includes(pretty)){
            const sel = selects[i];
            if(sel && Array.from(sel.options).some(o=>o.value===val)){
              sel.value = val; sel.dispatchEvent(new Event("change"));
            }
            break;
          }
        }
      }
      for(const [k,v] of Object.entries(sugg)) setFor(k,v);
    }
    apply("mail", suggMail);
    apply("crm",  suggCRM);
  }

  // Run after the modal opens (observe overlay visibility changes)
  const obs = new MutationObserver(()=>{
    const ov = document.getElementById("mtMapperOverlay");
    if(ov && ov.style.display!== "none"){
      setTimeout(applyLimitedSuggestions, 50);
    }
  });
  document.addEventListener("DOMContentLoaded", ()=>{
    try{ obs.observe(document.body, {attributes:true, childList:true, subtree:true}); }catch{}
  });
})();
</script>
<script id="mt-legend-navy-ultimate-v3">
(function(){
  var NAVY = '#0d2c54';

  // Treat these as legend labels or note fragments (segment-aware)
  var patterns = [
    /mail\s*volume/i,
    /crm\s*jobs/i,
    /matches/i,
    /dashed/i,
    /previous\s*year/i
  ];

  function isHit(text){
    if (text == null) return false;
    var t = String(text).replace(/\s+/g,' ').trim();
    for (var i=0;i<patterns.length;i++){
      if (patterns[i].test(t)) return true;
    }
    return false;
  }

  // CSS for HTML/SVG legends
  var style = document.createElement('style');
  style.textContent = [
    '.apexcharts-legend-text,',
    '.highcharts-legend text,',
    '.plotly .legend .legendtext,',
    '.chart-legend, .chart-legend *,',
    '.legend, .legend * {',
    '  color:'+NAVY+' !important; fill:'+NAVY+' !important;',
    '}'
  ].join('\n');
  document.head.appendChild(style);

  // DOM/SVG pass
  function paintDOM(root){
    var walker = document.createTreeWalker(root || document.body, NodeFilter.SHOW_TEXT, null, false);
    var node;
    while ((node = walker.nextNode())){
      var val = (node.nodeValue || '').trim();
      if (!val) continue;
      if (!isHit(val)) continue;
      var el = node.parentElement;
      if (!el) continue;
      el.style.color = NAVY;
      if (el.tagName && el.tagName.toLowerCase() === 'text'){
        el.setAttribute('fill', NAVY);
        el.style.fill = NAVY;
        // Guard against muted styles
        el.setAttribute('opacity','1');
        el.style.opacity = '1';
      }
    }
  }

  // Canvas hook (for Chart.js-like legends)
  (function hookCanvas(){
    if (typeof CanvasRenderingContext2D === 'undefined') return;
    var proto = CanvasRenderingContext2D.prototype;
    if (proto.__mtLegendPatchedV3) return;
    ['fillText','strokeText'].forEach(function(method){
      var orig = proto[method];
      if (!orig) return;
      proto[method] = function(text){
        try{
          if (isHit(text)){
            var pf = this.fillStyle, ps = this.strokeStyle,
                pa = this.globalAlpha, sc = this.shadowColor, flt = this.filter;
            this.fillStyle = NAVY;
            this.strokeStyle = NAVY;
            this.globalAlpha = 1;
            this.shadowColor = 'transparent';
            this.filter = 'none';
            var out = orig.apply(this, arguments);
            this.fillStyle = pf; this.strokeStyle = ps;
            this.globalAlpha = pa; this.shadowColor = sc; this.filter = flt;
            return out;
          }
        }catch(e){}
        return orig.apply(this, arguments);
      };
    });
    proto.__mtLegendPatchedV3 = true;
  })();

  // Library-specific gentle nudges
  function tryPlotly(){
    if (!window.Plotly) return;
    document.querySelectorAll('.js-plotly-plot').forEach(function(div){
      try { window.Plotly.relayout(div, {'legend.font.color': NAVY}); } catch(e){}
    });
  }
  function tryHighcharts(){
    if (!window.Highcharts || !window.Highcharts.charts) return;
    window.Highcharts.charts.forEach(function(c){
      if (!c) return;
      try {
        c.update({ legend: { itemStyle: { color: NAVY }, itemHoverStyle: { color: NAVY } } }, false);
        c.redraw(false);
      } catch(e){}
    });
  }
  function tryECharts(){
    if (!window.echarts) return;
    document.querySelectorAll('[__echarts_instance__]').forEach(function(el){
      try {
        var inst = window.echarts.getInstanceByDom(el);
        if (!inst) return;
        var opt = inst.getOption && inst.getOption();
        inst.setOption({ legend: (opt && opt.legend && opt.legend.length ? opt.legend.map(function(l){ 
          l = l || {}; l.textStyle = l.textStyle || {}; l.textStyle.color = NAVY; return l; 
        }) : [{textStyle:{color:NAVY}}]) }, false);
      } catch(e){}
    });
  }
  function tryChartJS(){
    if (!window.Chart || !window.Chart.getChart) return;
    document.querySelectorAll('canvas').forEach(function(cv){
      try {
        var ch = window.Chart.getChart(cv);
        if (!ch || !ch.options) return;
        ch.options.plugins = ch.options.plugins || {};
        ch.options.plugins.legend = ch.options.plugins.legend || {};
        ch.options.plugins.legend.labels = ch.options.plugins.legend.labels || {};
        ch.options.plugins.legend.labels.color = NAVY;
        ch.update('none');
      } catch(e){}
    });
  }

  function tick(){
    paintDOM(document.body);
    tryPlotly(); tryHighcharts(); tryECharts(); tryChartJS();
  }

  function boot(){
    tick();
    var i = 0, t = setInterval(function(){
      tick();
      if (++i > 30) clearInterval(t);
    }, 200);
    var mo = new MutationObserver(function(muts){
      for (var k=0;k<muts.length;k++){
        for (var j=0;j<(muts[k].addedNodes||[]).length;j++){
          var n = muts[k].addedNodes[j];
          if (n.nodeType === 1) paintDOM(n);
        }
      }
    });
    mo.observe(document.body, {childList:true, subtree:true});
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive'){
    setTimeout(boot, 50);
  } else {
    document.addEventListener('DOMContentLoaded', boot);
  }
})();
</script>
<script id="v47-advbtn-finder">
(function(){
  function pickButton(){
    var root = document.querySelector('#cmp-kpis');
    if (!root) return;
    // candidate buttons/links inside KPI card
    var cand = Array.prototype.slice.call(
      root.querySelectorAll('button, .btn, [role="button"], a.button, a.btn')
    );
    if (!cand.length) return;
    // Choose the lowest (visually) button in the card — the one "below the KPIs"
    var best = null, bestTop = -Infinity;
    cand.forEach(function(el){
      var r = el.getBoundingClientRect();
      if (!r || !isFinite(r.top)) return;
      if (r.top > bestTop) { bestTop = r.top; best = el; }
    });
    if (!best) return;
    // Apply visible styling
    best.classList.add('mt-advbtn');
    best.style.visibility = 'visible';
    best.style.opacity = '1';
  }

  function boot(){
    pickButton();
    // Retry for async renders
    var tries = 0, t = setInterval(function(){
      pickButton();
      if (++tries > 20) clearInterval(t);
    }, 200);
    // Observe KPI card for late changes
    var root = document.querySelector('#cmp-kpis');
    if (root) {
      var mo = new MutationObserver(function(){ pickButton(); });
      mo.observe(root, {childList:true, subtree:true});
    }
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive'){
    setTimeout(boot, 40);
  } else {
    document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 40); });
  }
})();
</script>
<script id="v47-cta-3d-apply">
(function(){
  var SELECTOR = 'button, a, [role="button"], input[type="button"], input[type="submit"], .btn, .button';
  var RE_RUN   = /run\s*matching/i;
  var RE_EDIT  = /edit\s*mapping/i;
  var RE_KPIS  = /(show|hide)\s*.*advanced\s*kpi[\u2019']?s?/i;
  var rafScanEnd = 0;

  function norm(s){
    return (s||'')
      .replace(/[\u00A0]/g,' ')        // nbsp -> space
      .replace(/\s+/g,' ')             // collapse whitespace
      .replace(/[»›<>\(\)\[\]]/g,'')   // strip adornments
      .trim();
  }
  function labelOf(el){
    return norm(
      (el.textContent||'') ||
      (el.value||'') ||
      el.getAttribute('aria-label') ||
      el.getAttribute('title')
    );
  }
  function makePrimary(el){
    el.classList.add('mt-cta-3d');
    el.classList.remove('mt-cta-secondary');
    el.style.visibility = 'visible';
    el.style.opacity = '1';
    el.dataset.mtCta3d = '1';
  }
  function makeSecondary(el){
    el.classList.add('mt-cta-secondary');
    el.classList.remove('mt-cta-3d');
    el.style.visibility = 'visible';
    el.style.opacity = '1';
    el.dataset.mtCta3d = '1';
  }
  function maybeTag(el){
    if (!el || el.dataset.mtCta3d === '1') return false;
    var t = labelOf(el);
    if (!t) return false;
    if (RE_RUN.test(t))   { makePrimary(el); return true; }
    if (RE_EDIT.test(t))  { makeSecondary(el); return true; }
    if (RE_KPIS.test(t))  { makePrimary(el); return true; } // Show/Hide Advanced KPIs
    return false;
  }
  function sweep(root){
    var nodes = (root || document).querySelectorAll ? (root || document).querySelectorAll(SELECTOR) : [];
    nodes = Array.prototype.slice.call(nodes);
    nodes.forEach(maybeTag);
  }

  // Observe standard DOM
  var mo = new MutationObserver(function(muts){
    for (var i=0;i<muts.length;i++){
      var m = muts[i];
      for (var j=0;j<(m.addedNodes||[]).length;j++){
        var n = m.addedNodes[j];
        if (n.nodeType !== 1) continue;
        if (!maybeTag(n)) sweep(n);
      }
    }
  });
  function startObserver(doc){
    try { mo.observe(doc.body, {childList:true, subtree:true}); } catch(e){}
  }

  // Hook shadow DOM creation
  var oldAttach = Element.prototype.attachShadow;
  if (oldAttach){
    Element.prototype.attachShadow = function(init){
      var sr = oldAttach.call(this, init);
      try {
        var mo2 = new MutationObserver(function(muts){
          for (var i=0;i<muts.length;i++){
            for (var j=0;j<(muts[i].addedNodes||[]).length;j++){
              var n = muts[i].addedNodes[j];
              if (n.nodeType !== 1) continue;
              if (!maybeTag(n)){
                try { sweep(n); } catch(e){}
              }
            }
          }
        });
        mo2.observe(sr, {childList:true, subtree:true});
        // initial sweep inside shadow root
        sweep(sr);
      } catch(e){}
      return sr;
    };
  }

  // Watch same-origin iframes too
  function hookIframes(){
    var iframes = Array.prototype.slice.call(document.querySelectorAll('iframe'));
    iframes.forEach(function(fr){
      try {
        var idoc = fr.contentDocument;
        if (!idoc || idoc.__mtCTAHooked) return;
        idoc.__mtCTAHooked = true;
        // Sweep + observe inside iframe
        sweep(idoc);
        var moF = new MutationObserver(function(muts){
          for (var i=0;i<muts.length;i++){
            for (var j=0;j<(muts[i].addedNodes||[]).length;j++){
              var n = muts[i].addedNodes[j];
              if (n.nodeType !== 1) continue;
              if (!maybeTag(n)) sweep(n);
            }
          }
        });
        moF.observe(idoc, {childList:true, subtree:true});
      } catch(e){ /* cross-origin -> ignore */ }
    });
  }

  // After clicking "Run matching", scan aggressively for a few seconds
  function hookRunMatching(){
    var nodes = Array.prototype.slice.call(document.querySelectorAll(SELECTOR));
    nodes.forEach(function(el){
      var t = labelOf(el);
      if (!t) return;
      if (RE_RUN.test(t)){
        el.addEventListener('click', function(){
          var end = Date.now() + 12000; // 12s aggressive scan
          function pump(){
            sweep(document);
            hookIframes();
            if (Date.now() < end) requestAnimationFrame(pump);
          }
          requestAnimationFrame(pump);
        }, {once:false});
      }
    });
  }

  function boot(){
    // Initial passes
    sweep(document);
    startObserver(document);
    hookIframes();
    hookRunMatching();

    // Safety periodic sweeps (lightweight)
    var count = 0;
    var t = setInterval(function(){
      sweep(document);
      hookIframes();
      if (++count > 60) clearInterval(t); // ~2 minutes
    }, 2000);
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive'){
    setTimeout(boot, 60);
  } else {
    document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 60); });
  }
})();
</script>
<div aria-labelledby="mt-modal-title" aria-modal="true" id="mt-modal-backdrop" role="dialog" style="display:none">
<div aria-describedby="mt-modal-desc" id="mt-modal" role="document" tabindex="-1">
<header>
<span aria-hidden="true" class="dot"></span>
<h3 id="mt-modal-title">Action needed</h3>
</header>
<div class="content">
<p id="mt-modal-desc">Please pick <strong>both CSV files</strong> first.</p>
<p class="hint">Tip: select your <em>Mail CSV</em> and your <em>CRM CSV</em>, then click <strong>Run matching</strong>.</p>
</div>
<footer>
<button class="btn btn-outline" id="mt-modal-cancel" type="button">Cancel</button>
<button class="btn btn-primary" id="mt-modal-ok" type="button">Okay</button>
</footer>
</div>
</div>
<script id="v47-modal-logic">
(function(){
  var BACKDROP_ID = 'mt-modal-backdrop';
  var MODAL_ID = 'mt-modal';
  function $(sel, root){ return (root||document).querySelector(sel); }
  function $all(sel, root){ return Array.prototype.slice.call((root||document).querySelectorAll(sel)); }

  function countPickedFiles(){
    // Count files selected across all file inputs
    var inputs = $all('input[type="file"]');
    var total = 0;
    inputs.forEach(function(i){
      try { total += (i.files && i.files.length) ? i.files.length : 0; } catch(e){}
    });
    return total;
  }

  function openModal(){
    var bd = $('#'+BACKDROP_ID), m = $('#'+MODAL_ID);
    if (!bd || !m) return;
    bd.style.display = 'flex';
    // force reflow then animate open
    requestAnimationFrame(function(){
      bd.classList.add('show');
      m.classList.add('open');
      try { m.focus(); } catch(e){}
    });
  }
  function closeModal(){
    var bd = $('#'+BACKDROP_ID), m = $('#'+MODAL_ID);
    if (!bd || !m) return;
    m.classList.remove('open');
    bd.classList.remove('show');
    setTimeout(function(){ bd.style.display = 'none'; }, 120);
  }

  function guardRun(ev){
    // If fewer than 2 files are selected, block and show modal
    if (countPickedFiles() < 2){
      if (ev){ ev.preventDefault(); ev.stopPropagation(); }
      openModal();
      return false;
    }
    return true;
  }

  // Attach listeners to Run Matching buttons
  function attachToRunButtons(root){
    var RE_RUN = /run\s*matching/i;
    var btns = $all('button, a, [role="button"], input[type="button"], input[type="submit"]', root);
    btns.forEach(function(b){
      var txt = (b.textContent || b.value || b.getAttribute('aria-label') || b.getAttribute('title') || '').replace(/\s+/g,' ').trim();
      if (RE_RUN.test(txt)){
        // Capture phase handler to block before other listeners
        b.addEventListener('click', function(ev){ guardRun(ev); }, true);
      }
    });
  }

  // Intercept form submit on containing forms as a fallback
  function attachToForms(){
    $all('form').forEach(function(f){
      f.addEventListener('submit', function(ev){
        guardRun(ev);
      }, true);
    });
  }

  // Hide/replace top red banner if it shows up
  function watchErrors(){
    var mo = new MutationObserver(function(muts){
      muts.forEach(function(m){
        (m.addedNodes||[]).forEach(function(n){
          if (!n || n.nodeType !== 1) return;
          var txt = (n.textContent || '').trim();
          if (/please\s*pick\s*both\s*csv\s*files\s*first/i.test(txt)){
            // hide the node and show modal instead
            n.style.display = 'none';
            openModal();
          }
        });
      });
    });
    try { mo.observe(document.body, {childList:true, subtree:true}); } catch(e){}
  }

  function boot(){
    attachToRunButtons(document);
    attachToForms();
    watchErrors();
    // close handlers
    var ok = $('#mt-modal-ok'), cancel = $('#mt-modal-cancel'), bd = $('#'+BACKDROP_ID);
    if (ok) ok.addEventListener('click', closeModal);
    if (cancel) cancel.addEventListener('click', closeModal);
    if (bd) bd.addEventListener('click', function(e){ if (e.target === bd) closeModal(); });
    // keyboard escape
    document.addEventListener('keydown', function(e){ if (e.key === 'Escape') closeModal(); });
    // Observe dynamic buttons (in case UI renders later)
    var mo2 = new MutationObserver(function(muts){
      muts.forEach(function(m){
        (m.addedNodes||[]).forEach(function(n){
          if (n && n.nodeType === 1) attachToRunButtons(n);
        });
      });
    });
    try { mo2.observe(document.body, {childList:true, subtree:true}); } catch(e){}
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive'){
    setTimeout(boot, 60);
  } else {
    document.addEventListener('DOMContentLoaded', function(){ setTimeout(boot, 60); });
  }
})();
</script>
<script defer="True" src="assets/lsv1-loader.js?v=20250930_170112"></script><script defer="True" src="assets/mailtrace-ui.js?v=20250930_170112"></script><script defer="True" src="assets/mailtrace-charts.js?v=20250930_170112"></script><script defer="True" src="assets/progress_wiring.js?v=20250930_170112"></script><script src="assets/mt-sharded-driver.js?v=20250930_170112" type="module"></script><script>
// Tooltip enhancer v2 — mm-yyyy label + better offset & edge flip
(function(){
  // replace existing patch if present
  if (window.__mtTooltipPatchedV2) return; window.__mtTooltipPatchedV2 = true;
  const tryPatch = () => {
    if (typeof window.lineChart !== 'function') { setTimeout(tryPatch, 50); return; }
    const orig = window.lineChart;
    window.lineChart = function(canvas, labels, series, overlay){
      // draw
      try { orig(canvas, labels, series, overlay); } catch(e){ console.error(e); }
      try {
        const W = canvas.width, H = canvas.height, pad = 30;
        const all = [...(series||[]).flatMap(s=>s.data||[]), ...((overlay||[]).flatMap(s=>s.data||[]))];
        const min = 0, max = Math.max(1, Math.max.apply(null, [1].concat(all)));
        const xFor = i => pad + i*(W-2*pad)/Math.max(1, (labels||[]).length-1);
        const yFor = v => H-pad - ( (v-min)/(max-min) )*(H-2*pad);
        canvas.__mtMeta = { labels, series, overlay, pad, W, H, min, max, xFor, yFor };
        // tooltip
        let tip = canvas.__mtTip;
        if (!tip){
          tip = document.createElement('div');
          tip.className = 'mt-tooltip';
          Object.assign(tip.style, {
            position:'absolute', pointerEvents:'none', background:'#fff', color:'#0d2c54',
            border:'1px solid #e6edf5', padding:'6px 8px', borderRadius:'6px',
            font:'12px system-ui', boxShadow:'0 4px 14px rgba(13,44,84,.15)', zIndex:1000, display:'none',
            whiteSpace:'nowrap'
          });
          canvas.__mtTip = tip;
          const host = canvas.parentElement || document.body;
          if (getComputedStyle(host).position === 'static') host.style.position = 'relative';
          host.appendChild(tip);
        }
        // listeners
        if (!canvas.__mtHoverV2){
          canvas.addEventListener('mousemove', function(e){
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
            const meta = canvas.__mtMeta; if (!meta) return;
            const {labels, series, overlay, pad, W, H} = meta;
            if (mx<pad || mx>W-pad || my<pad || my>H-pad){ tip.style.display='none'; return; }
            const frac = (mx - pad) / Math.max(1, (W - 2*pad));
            let idx = Math.round(frac * Math.max(0, (labels||[]).length - 1));
            idx = Math.max(0, Math.min((labels||[]).length-1, idx));
            // format label mm-yyyy
            const rawLab = (labels||[])[idx] || '';
            let lab = rawLab;
            const m1 = /^(\d{4})-(\d{1,2})$/.exec(rawLab);           // yyyy-mm
            const m2 = /^(\d{4})-(\d{1,2})-(\d{1,2})$/.exec(rawLab); // yyyy-mm-dd
            if (m2) lab = (m2[2].padStart(2,'0')) + '-' + m2[1]; else
            if (m1) lab = (m1[2].padStart(2,'0')) + '-' + m1[1];
            // series values
            const parts = [];
            (series||[]).forEach(s=>{ const v=(s.data||[])[idx]; parts.push(`${s.label||'Series'}: ${Number(v||0).toLocaleString()}`); });
            (overlay||[]).forEach(s=>{ const v=(s.data||[])[idx]; parts.push(`${s.label||'YoY'}: ${Number(v||0).toLocaleString()}`); });
            tip.innerHTML = `<div style="font-weight:700;margin-bottom:4px">${lab}</div><div>${parts.join('<br>')}</div>`;
            tip.style.display = 'block';
            // position with larger right offset; flip to left near edge
            const host = canvas.parentElement || document.body;
            const hostRect = host.getBoundingClientRect();
            const offsetX = 28, offsetY = 16;
            let left = mx + offsetX, top = my + offsetY;
            // clamp/flip horizontally
            const need = left + tip.offsetWidth + 8;
            if (need > hostRect.width){
              left = mx - tip.offsetWidth - offsetX;
              if (left < 8) left = hostRect.width - tip.offsetWidth - 8;
            }
            if (top + tip.offsetHeight + 8 > hostRect.height){
              top = hostRect.height - tip.offsetHeight - 8;
            }
            tip.style.left = left + 'px';
            tip.style.top = top + 'px';
          });
          canvas.addEventListener('mouseleave', ()=>{ if(canvas.__mtTip) canvas.__mtTip.style.display='none'; });
          canvas.__mtHoverV2 = true;
        }
      } catch(e){ console.error('Tooltip v2 error:', e); }
    };
  };
  tryPatch();
})();
</script>
<script>
(function(){
  function fmtMoney(n){ try{ n = Number(n)||0; return '$' + n.toLocaleString(undefined,{maximumFractionDigits:2}); }catch(_){ return '$0'; } }
  function setKpi(name, val){ const el = document.querySelector(`[data-kpi="${name}"]`); if(!el) return;
    if(name==='match_rate'){ el.textContent = (Number(val)||0).toFixed(2) + '%'; }
    else if(name==='match_revenue'){ el.textContent = fmtMoney(val); }
    else { el.textContent = (Number(val)||0).toLocaleString(); }
  }
  function renderKpis(k){ setKpi('mail',k.mail); setKpi('uniqmail',k.uniqmail); setKpi('crm',k.crm); setKpi('matches',k.matches); setKpi('match_rate',k.match_rate); setKpi('match_revenue',k.match_revenue); }

  function renderGraph(g){
    const c = document.getElementById('chart'); if(!c||!c.getContext) return; const ctx = c.getContext('2d');
    function draw(){
      const dpr = window.devicePixelRatio||1, W = c.clientWidth*dpr, H = c.clientHeight*dpr; c.width=W; c.height=H;
      ctx.clearRect(0,0,W,H);
      const padL=40,padR=10,padT=16,padB=26, xs=g.months||[], ys=g.matches||[], py=g.prev_year||[];
      const n=xs.length; if(!n) return; const ymax=Math.max(10, Math.max.apply(null, ys.concat(py)));
      const yPix=v=> H-padB - (v/ymax)*(H-padT-padB); const xPix=i=> padL + (i*(W-padL-padR)/Math.max(1,n-1));
      ctx.strokeStyle='#e6edf5'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(padL,padT); ctx.lineTo(padL,H-padB); ctx.lineTo(W-padR,H-padB); ctx.stroke();
      ctx.strokeStyle='#0d2c54'; ctx.lineWidth=2; ctx.beginPath(); for (let i=0;i<n;i++){ const x=xPix(i), y=yPix(ys[i]||0); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.stroke();

      const btn = document.getElementById('chartYoyToggle');
      const showYoy = localStorage.getItem('mt_yoy') === '1';
      if (btn){ btn.textContent = showYoy ? 'Hide YoY' : 'Show YoY'; btn.onclick = ()=>{ localStorage.setItem('mt_yoy', showYoy ? '0' : '1'); renderGraph(g); }; }
      if (showYoy && py.length===n){ ctx.setLineDash([8,6]); ctx.beginPath(); for (let j=0;j<n;j++){ const x2=xPix(j), y2=yPix(py[j]||0); if(j===0) ctx.moveTo(x2,y2); else ctx.lineTo(x2,y2);} ctx.stroke(); ctx.setLineDash([]); }
    }
    draw(); window.addEventListener('resize', draw);
  }

  function renderSummary(rows){
    const tb = document.querySelector('[data-summary="rows"]'); if(!tb) return; tb.innerHTML='';
    (rows||[]).forEach(r=>{
      const tr=document.createElement('tr');
      const cols=[r.mail_address1||'', r.mail_unit||'', r.crm_address1||'', r.crm_unit||'', r.city||'', r.state||'', (r.zip||'').toString().slice(0,5), r.mail_dates||'', r.crm_date||'', r.amount||0, (r.confidence||0)+'%', r.notes||''];
      cols.forEach((val,i)=>{ const td=document.createElement('td'); td.textContent=(i===9? ('$'+Number(val).toLocaleString()) : val); if(i===9||i===10) td.style.textAlign='right';
        if(i===10){ const v=parseFloat(String(val).replace('%',''))||0; td.className = v>95? 'conf-green': (v>=86? 'conf-yellow':'conf-red'); }
        tr.appendChild(td);
      });
      tb.appendChild(tr);
    });
  }

  function renderTop(kind, arr){
    const tb=document.querySelector(`[data-top="${kind}"]`); if(!tb) return; tb.innerHTML='';
    (arr||[]).forEach(p=>{ const tr=document.createElement('tr'); const n=p[0], t=p[1]||0;
      const c1=document.createElement('td'); c1.textContent=n;
      const c2=document.createElement('td'); c2.style.textAlign='center'; c2.textContent=Number(t).toLocaleString();
      const c3=document.createElement('td'); c3.style.textAlign='center'; c3.textContent='';
      tr.appendChild(c1); tr.appendChild(c2); tr.appendChild(c3); tb.appendChild(tr);
    });
  }

  async function start(fd){ const r=await fetch('/api/match_start',{method:'POST', body:fd}); const d=await r.json(); if(!r.ok) throw new Error(d.error||'start failed'); return d.job_id; }
  async function poll(id){
    while(true){
      const r=await fetch('/api/match_progress?job_id='+encodeURIComponent(id));
      const d=await r.json();
      if(d.status==='done'){ if(window.MailTraceLoader?.setProgress) MailTraceLoader.setProgress(100,'Finishing…'); break; }
      if(d.status==='error'){ throw new Error('Server error'); }
      if(window.MailTraceLoader?.setProgress){ MailTraceLoader.setProgress(d.percent||0, d.phase||'matching'); }
      await new Promise(s=>setTimeout(s,1200));
    }
  }
  async function getRes(id){ const r=await fetch('/api/match_result?job_id='+encodeURIComponent(id)); if(r.status===202) return null; const d=await r.json(); if(!r.ok) throw new Error(d.error||'failed'); return d; }

  const btn = document.getElementById('runBtn');
  if (btn){
    btn.addEventListener('click', async (ev)=>{
      ev.preventDefault();
      const mail = document.getElementById('mailCsv')?.files?.[0];
      const crm  = document.getElementById('crmCsv') ?.files?.[0];
      if(!mail || !crm){ alert('Please select both Mail and CRM CSV files.'); return; }
      try{
        if(window.MailTraceLoader?.show) MailTraceLoader.show({progress:0, text:'Uploading…'});
        const fd = new FormData(); fd.append('mail_csv', mail); fd.append('crm_csv', crm); fd.append('mode','loose');
        const id = await start(fd);
        await poll(id);
        const data = await getRes(id); if(!data) return;
        renderKpis(data.kpis||{}); renderGraph(data.graph||{months:[],matches:[],prev_year:[]});
        renderSummary(data.summary||[]); renderTop('cities', data.top_cities||[]); renderTop('zips', data.top_zips||[]);
      }catch(e){ console.error(e); alert('Match failed: '+e.message); }
      finally{ if(window.MailTraceLoader?.hide) MailTraceLoader.hide(); }
      return false;
    }, {capture:true});
  }
})();
</script>


<script>
(function(){
  const p = location.pathname.replace(/\/$/, '');
  if (p === '' || p === '/dashboard') document.getElementById('mt-link-dash')?.classList.add('active');
  if (p === '/map' || p.endsWith('/static/map.html')) document.getElementById('mt-link-map')?.classList.add('active');

  const hist = document.getElementById('mt-hist');
  if (!hist) return;
  const btn = hist.querySelector('.hist-btn');
  const list = document.getElementById('mt-hist-list');
  const empty = document.getElementById('mt-hist-empty');

  btn.addEventListener('click', () => hist.classList.toggle('open'));
  document.addEventListener('click', (e) => { if (!hist.contains(e.target)) hist.classList.remove('open'); });

  fetch('/api/runs')
    .then(r=>r.json()).then(data => {
      const runs = (data && data.runs) || [];
      empty.style.display = runs.length ? 'none' : 'block';
      list.innerHTML = runs.map((r,i) => {
        const dt = r.started_at ? new Date(r.started_at) : null;
        const label = dt ? dt.toLocaleString() : ('Run ' + (i+1));
        return `<a class="hist-item" href="/dashboard?run_id=${encodeURIComponent(r.run_id)}">
                  <span>${label}</span>
                  <span style="color:#999">${r.mail_count||0} mail</span>
                </a>`;
      }).join('');
    })
    .catch(()=>{ empty.textContent = 'No runs found'; });
})();
</script>


<script>
document.addEventListener('DOMContentLoaded', function() {
  const nodes = document.querySelectorAll('h1,h2,h3,div,section,header');
  for (const n of nodes) {
    const t = (n.textContent || '').toLowerCase();
    if (t.includes('modular dashboard')) { n.remove(); break; }
  }
});
</script>

</body>
</html>
<!-- MailTrace SSOT section versions: {"baseline": "v19.4", "sections": {"summary": "s1.11", "graph": "g1.9", "kpis": "k1.5", "topMail": "t1.6", "input": "i1.0", "logic": "m1.1"}, "locked_on": "2025-09-17", "note": "KPIs: RPM, Avg Ticket, Median Days, \u226430/60/90, Unique Mail Addresses; advanced KPIs collapsible inside KPI box (3-across grid). Labels updated (Total Jobs). Controls hidden; Strictness default Loose."} -->
<script>window.MailTraceSectionVersions = {"baseline": "v19.4", "sections": {"summary": "s1.11", "graph": "g1.9", "kpis": "k1.5", "topMail": "t1.6", "input": "i1.0", "logic": "m1.1"}, "locked_on": "2025-09-17", "note": "KPIs: RPM, Avg Ticket, Median Days, \u226430/60/90, Unique Mail Addresses; advanced KPIs collapsible inside KPI box (3-across grid). Labels updated (Total Jobs). Controls hidden; Strictness default Loose."};</script>
<!-- lineChart override: thin+points + legend + MMM/Jan-year + dark-blue + Jan dotted + clipped guides + hover -->
<script>
(function(){
  const MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  function parseMonYr(lbl){
    const s = String(lbl||'').trim(); let m;
    m = s.match(/^(\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[2]}; }
    m = s.match(/^(\d{4})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
    m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[3]}; }
    m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
    m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[\s\-](\d{4})$/i);
    if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:+m[2]}; }
    m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i);
    if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:null}; }
    return {mon:null, yr:null};
  }

  function ensureLegend(canvas, labelsAndColors){
    const wrap = canvas.parentElement || document.body;
    let legend = wrap.querySelector('.legend');
    if(!legend){
      legend = document.createElement('div');
      legend.className = 'legend';
      legend.style.cssText = 'display:flex;gap:16px;align-items:center;justify-content:flex-end;margin-top:8px;font-size:12px;color:#9fb2c8';
      wrap.appendChild(legend);
    }
    legend.innerHTML = '';
    labelsAndColors.forEach(item => {
      const span = document.createElement('span');
      span.className = 'item';
      const sw = document.createElement('span');
      sw.style.cssText = 'display:inline-block;width:12px;height:3px;border-radius:2px;margin-right:6px;background:'+item.color;
      span.appendChild(sw);
      span.appendChild(document.createTextNode(item.label));
      legend.appendChild(span);
    });
    const badge = document.createElement('span');
    badge.className = 'item';
    const dash = document.createElement('span');
    dash.style.cssText = 'display:inline-block;width:26px;height:3px;background:linear-gradient(90deg,#9fb2c8 0 40%,transparent 40% 60%,#9fb2c8 60%);margin-right:6px';
    badge.appendChild(dash);
    badge.appendChild(document.createTextNode('Dashed = Previous Year'));
    legend.appendChild(badge);
  }

  window.lineChart = function(canvas, labels, series, overlay){
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height, pad = 40;
    const colors = ["#60a5fa","#f59e0b","#34d399","#f472b6","#a78bfa"];
    const comp = getComputedStyle(document.body);
    const darkBlue = comp.getPropertyValue('--dash-blue').trim() || '#173b64';

    function drawSmooth(ctx, pts, t){
      if(pts.length < 2) return;
      const tension = (typeof t === 'number') ? t : 0.35;
      ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=0;i<pts.length-1;i++){
        const p0=pts[i-1]||pts[i], p1=pts[i], p2=pts[i+1], p3=pts[i+2]||p2;
        const cp1x=p1.x+(p2.x-p0.x)*t/2, cp1y=p1.y+(p2.y-p0.y)*t/2;
        const cp2x=p2.x-(p3.x-p1.x)*t/2, cp2y=p2.y-(p3.y-p1.y)*t/2;
        ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,p2.x,p2.y);
      }
      ctx.stroke();
    }

    ensureLegend(canvas, [
      {label:'Mail volume', color:colors[0]},
      {label:'CRM jobs',    color:colors[1]},
      {label:'Matches',     color:colors[2]}
    ]);

    const allVals = [...(series||[]).flatMap(s => s.data||[]), ...(overlay||[]).flatMap(s => s.data||[])];
    const max = Math.max(1, ...allVals.map(v => Number(v||0)));
    const min = 0;
    const xFor = i => pad + i*(W-2*pad)/Math.max(1, (labels||[]).length-1);
    const yFor = v => H - pad - ((Number(v||0)-min)/(max-min)) * (H-2*pad);

    function drawFrame(focusIdx){
      ctx.clearRect(0,0,W,H);

      // Axes
      ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(pad,H-pad); ctx.lineTo(W-pad,H-pad); ctx.moveTo(pad,H-pad); ctx.lineTo(pad,pad); ctx.stroke();

      const step = (W-2*pad)/Math.max(1,(labels||[]).length-1);

      // Vertical guides (CLIPPED), January dotted, labels (Jan on 2 lines, others MMM)
      for(let i=0;i<(labels||[]).length;i++){
        const x = pad + i*step;
        const p = parseMonYr(labels[i]);

        // light guide (clip to plot area)
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.globalAlpha=.18; ctx.strokeStyle='rgba(255,255,255,.5)'; ctx.setLineDash([]); ctx.lineCap='butt';
        ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, H - pad); ctx.stroke();
        ctx.restore(); ctx.globalAlpha=1;

        // January dotted (clip + butt caps)
        if(p.mon === 1){
          ctx.save();
          ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
          ctx.strokeStyle = darkBlue; ctx.setLineDash([3,3]); ctx.lineCap='butt';
          ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, H - pad); ctx.stroke();
          ctx.restore();
        }

        // X-axis labels
        ctx.fillStyle = darkBlue; ctx.font='11px system-ui';
        if(p.mon === 1 && p.yr){ ctx.fillText('Jan', x-12, H - pad + 14); ctx.fillText(String(p.yr), x-16, H - pad + 26); }
        else if(p.mon){ ctx.fillText(MONTHS[p.mon-1], x-12, H - pad + 14); }
        else { ctx.fillText(String(labels[i]||''), x-12, H - pad + 14); }
      }

      // Series: thin + points with smoothing
      ctx.lineCap='round'; ctx.lineJoin='round';
      (series||[]).forEach((s,si)=>{
        const col = colors[si%colors.length];
        const pts = (s.data||[]).map((v,i)=>({x:xFor(i), y:yFor(v)}));
        ctx.save();
        ctx.strokeStyle=col; ctx.lineWidth=1.6;
        drawSmooth(ctx, pts, 0.35);
        ctx.fillStyle=col;
        pts.forEach((p,i)=>{ ctx.beginPath(); ctx.arc(p.x,p.y,2.2,0,Math.PI*2); ctx.fill(); if(focusIdx===i){ ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); } });
        ctx.restore();
      });

      // Overlay: dashed, smoothed
      (overlay||[]).forEach((s,si)=>{
        const col = colors[si%colors.length];
        const pts = (s.data||[]).map((v,i)=>({x:xFor(i), y:yFor(v)}));
        ctx.save(); ctx.setLineDash([5,4]); ctx.globalAlpha=.6; ctx.strokeStyle=col; ctx.lineWidth=2; drawSmooth(ctx, pts, 0.35); ctx.restore();
      });

      // Hover guide (CLIPPED) + tooltip with all series values
      if(typeof focusIdx === 'number' && focusIdx >= 0){
        const gx = xFor(focusIdx);
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.strokeStyle='rgba(255,255,255,.15)'; ctx.setLineDash([4,4]); ctx.lineCap='butt';
        ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, H - pad); ctx.stroke();
        ctx.restore();

        const rows = [];
        (series||[]).forEach((s,si)=>{ const v=(s.data||[])[focusIdx]; if(v!=null){ rows.push({label:s.label||('Series '+(si+1)), value:Number(v), color:colors[si%colors.length]}); } });

        const tx = Math.min(gx + 12, W - pad - 180), ty = pad + 10, tw = 170, th = 22 + rows.length * 18;
        ctx.save(); ctx.fillStyle='rgba(13,22,37,.95)'; ctx.strokeStyle='rgba(255,255,255,.12)'; ctx.lineWidth=1;
        if(ctx.roundRect){ ctx.beginPath(); ctx.roundRect(tx, ty, tw, th, 6); ctx.fill(); ctx.stroke(); } else { ctx.fillRect(tx,ty,tw,th); ctx.strokeRect(tx,ty,tw,th); }
        ctx.fillStyle=darkBlue; ctx.font='12px system-ui';
        const p = parseMonYr(labels[focusIdx]);
        if(p.mon === 1 && p.yr){ ctx.fillText('Jan', tx+10, ty+14); ctx.fillText(String(p.yr), tx+10, ty+28); }
        else{ ctx.fillText(p.mon ? MONTHS[p.mon-1] : String(labels[focusIdx]||''), tx+10, ty+14); }
        rows.forEach((r,i)=>{ ctx.fillStyle=r.color; const base = (p.mon===1 && p.yr)? 28 : 14; const y=ty+ base + (i+1)*18; ctx.fillText(r.label+': '+r.value, tx+10, y); });
        ctx.restore();
      }
    }

    drawFrame(null);
    canvas.onmousemove = function(e){
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const step = (W - 2*pad)/Math.max(1,(labels||[]).length-1);
      let idx = Math.round((mx - pad)/step);
      idx = Math.max(0, Math.min((labels||[]).length-1, idx));
      drawFrame(idx);
    };
    canvas.onmouseleave = function(){ drawFrame(null); };
  };
})();
</script>

<!-- Patch: clip *lines* themselves (series + overlay) to plot area -->
<script>
(function(){
  // keep previous helpers; just override the drawing internals to clip lines and points
  const prev = window.lineChart;
  window.lineChart = function(canvas, labels, series, overlay){
    // reuse previous behavior but with clipping around series/overlay drawing
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height, pad = 40;
    const colors = ["#60a5fa","#f59e0b","#34d399","#f472b6","#a78bfa"];
    const MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    const comp = getComputedStyle(document.body);
    const darkBlue = comp.getPropertyValue('--dash-blue').trim() || '#173b64';

    function parseMonYr(lbl){
      const s = String(lbl||'').trim(); let m;
      m = s.match(/^(\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[2]}; }
      m = s.match(/^(\d{4})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
      m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[3]}; }
      m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
      m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[\s\-](\d{4})$/i);
      if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:+m[2]}; }
      m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i);
      if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:null}; }
      return {mon:null, yr:null};
    }

    function drawSmooth(ctx, pts, t){
      if(pts.length < 2) return;
      const tension = (typeof t === 'number') ? t : 0.35;
      ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=0;i<pts.length-1;i++){
        const p0=pts[i-1]||pts[i], p1=pts[i], p2=pts[i+1], p3=pts[i+2]||p2;
        const cp1x=p1.x+(p2.x-p0.x)*t/2, cp1y=p1.y+(p2.y-p0.y)*t/2;
        const cp2x=p2.x-(p3.x-p1.x)*t/2, cp2y=p2.y-(p3.y-p1.y)*t/2;
        ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,p2.x,p2.y);
      }
      ctx.stroke();
    }

    const allVals = [...(series||[]).flatMap(s => s.data||[]), ...(overlay||[]).flatMap(s => s.data||[])];
    const max = Math.max(1, ...allVals.map(v => Number(v||0)));
    const min = 0;
    const xFor = i => pad + i*(W-2*pad)/Math.max(1, (labels||[]).length-1);
    const yFor = v => H - pad - ((Number(v||0)-min)/(max-min)) * (H-2*pad);

    function drawFrame(focusIdx){
      ctx.clearRect(0,0,W,H);
      // axes
      ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(pad,H-pad); ctx.lineTo(W-pad,H-pad); ctx.moveTo(pad,H-pad); ctx.lineTo(pad,pad); ctx.stroke();

      const step = (W-2*pad)/Math.max(1,(labels||[]).length-1);
      // vertical guides + Jan dotted + labels (keep existing look & clipping for guides)
      for(let i=0;i<(labels||[]).length;i++){
        const x = pad + i*step;
        const p = parseMonYr(labels[i]);
        // light guide (clip)
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.globalAlpha=.18; ctx.strokeStyle='rgba(255,255,255,.5)'; ctx.setLineDash([]); ctx.lineCap='butt';
        ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, H - pad); ctx.stroke();
        ctx.restore(); ctx.globalAlpha=1;
        // Jan dotted (clip)
        if(p.mon === 1){
          ctx.save();
          ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
          ctx.strokeStyle = darkBlue; ctx.setLineDash([3,3]); ctx.lineCap='butt';
          ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, H - pad); ctx.stroke();
          ctx.restore();
        }
        // labels
        ctx.fillStyle = darkBlue; ctx.font='11px system-ui';
        if(p.mon === 1 && p.yr){ ctx.fillText('Jan', x-12, H - pad + 14); ctx.fillText(String(p.yr), x-16, H - pad + 26); }
        else if(p.mon){ ctx.fillText(MONTHS[p.mon-1], x-12, H - pad + 14); }
        else { ctx.fillText(String(labels[i]||''), x-12, H - pad + 14); }
      }

      // ---- SERIES (solid) — CLIPPED ----
      ctx.lineCap='round'; ctx.lineJoin='round';
      (series||[]).forEach((s,si)=>{
        const col = colors[si%colors.length];
        const pts = (s.data||[]).map((v,i)=>({x:xFor(i), y:yFor(v)}));
        ctx.save();
        // clip to plot area so curves can't overshoot baseline due to Beziers
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.strokeStyle=col; ctx.lineWidth=1.6;
        drawSmooth(ctx, pts, 0.35);
        // points (also clipped)
        ctx.fillStyle=col;
        pts.forEach((p,i)=>{ ctx.beginPath(); ctx.arc(p.x,p.y,2.2,0,Math.PI*2); ctx.fill(); if(focusIdx===i){ ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); } });
        ctx.restore();
      });

      // ---- OVERLAY (dashed YoY) — CLIPPED + butt caps ----
      (overlay||[]).forEach((s,si)=>{
        const col = colors[si%colors.length];
        const pts = (s.data||[]).map((v,i)=>({x:xFor(i), y:yFor(v)}));
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.setLineDash([5,4]); ctx.globalAlpha=.8; ctx.strokeStyle=col; ctx.lineWidth=2; ctx.lineCap='butt';
        drawSmooth(ctx, pts, 0.35);
        ctx.restore();
      });

      // Hover guide (already clipped) + tooltip
      if(typeof focusIdx === 'number' && focusIdx >= 0){
        const gx = xFor(focusIdx);
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.strokeStyle='rgba(255,255,255,.15)'; ctx.setLineDash([4,4]); ctx.lineCap='butt';
        ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, H - pad); ctx.stroke();
        ctx.restore();

        const rows = [];
        (series||[]).forEach((s,si)=>{ const v=(s.data||[])[focusIdx]; if(v!=null){ rows.push({label:s.label||('Series '+(si+1)), value:Number(v), color:colors[si%colors.length]}); } });

        const tx = Math.min(gx + 12, W - pad - 180), ty = pad + 10, tw = 170, th = 22 + rows.length * 18;
        ctx.save(); ctx.fillStyle='rgba(13,22,37,.95)'; ctx.strokeStyle='rgba(255,255,255,.12)'; ctx.lineWidth=1;
        if(ctx.roundRect){ ctx.beginPath(); ctx.roundRect(tx, ty, tw, th, 6); ctx.fill(); ctx.stroke(); } else { ctx.fillRect(tx,ty,tw,th); ctx.strokeRect(tx,ty,tw,th); }
        ctx.fillStyle=darkBlue; ctx.font='12px system-ui';
        const p = parseMonYr(labels[focusIdx]);
        if(p.mon === 1 && p.yr){ ctx.fillText('Jan', tx+10, ty+14); ctx.fillText(String(p.yr), tx+10, ty+28); }
        else{ ctx.fillText(p.mon ? MONTHS[p.mon-1] : String(labels[focusIdx]||''), tx+10, ty+14); }
        rows.forEach((r,i)=>{ ctx.fillStyle=r.color; const base = (p.mon===1 && p.yr)? 28 : 14; const y=ty+ base + (i+1)*18; ctx.fillText(r.label+': '+r.value, tx+10, y); });
        ctx.restore();
      }
    }

    // initial + pointer events
    drawFrame(null);
    canvas.onmousemove = function(e){
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const step = (W - 2*pad)/Math.max(1,(labels||[]).length-1);
      let idx = Math.round((mx - pad)/step);
      idx = Math.max(0, Math.min((labels||[]).length-1, idx));
      drawFrame(idx);
    };
    canvas.onmouseleave = function(){ drawFrame(null); };
  };
})();
</script>

<!-- Patch: clamp y inside plot to avoid top/bottom clipping (keeps guides clipped) -->
<script>
(function(){
  window.lineChart = function(canvas, labels, series, overlay){
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height, pad = 40;
    const colors = ["#60a5fa","#f59e0b","#34d399","#f472b6","#a78bfa"];
    const MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    const darkBlue = getComputedStyle(document.body).getPropertyValue('--dash-blue').trim() || '#173b64';

    function parseMonYr(lbl){
      const s = String(lbl||'').trim(); let m;
      m = s.match(/^(\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[2]}; }
      m = s.match(/^(\d{4})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
      m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[3]}; }
      m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
      m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[\s\-](\d{4})$/i);
      if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:+m[2]}; }
      m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i);
      if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:null}; }
      return {mon:null, yr:null};
    }

    function drawSmooth(ctx, pts, t){
      if(pts.length < 2) return;
      const tension = (typeof t === 'number') ? t : 0.35;
      ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=0;i<pts.length-1;i++){
        const p0=pts[i-1]||pts[i], p1=pts[i], p2=pts[i+1], p3=pts[i+2]||p2;
        const cp1x=p1.x+(p2.x-p0.x)*t/2, cp1y=p1.y+(p2.y-p0.y)*t/2;
        const cp2x=p2.x-(p3.x-p1.x)*t/2, cp2y=p2.y-(p3.y-p1.y)*t/2;
        ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,p2.x,p2.y);
      }
      ctx.stroke();
    }

    // scales
    const allVals = [...(series||[]).flatMap(s => s.data||[]), ...(overlay||[]).flatMap(s => s.data||[])];
    const max = Math.max(1, ...allVals.map(v => Number(v||0)));
    const min = 0;
    const xFor = i => pad + i*(W-2*pad)/Math.max(1, (labels||[]).length-1);
    const yFor = v => H - pad - ((Number(v||0)-min)/(max-min)) * (H-2*pad);
    // Clamp 1.5px inside plot area to avoid visible clipping at edges
    const yClampTop = pad + 1.5;
    const yClampBottom = H - pad - 1.5;
    const clampY = y => Math.max(yClampTop, Math.min(yClampBottom, y));

    function drawFrame(focusIdx){
      ctx.clearRect(0,0,W,H);
      // axes
      ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(pad,H-pad); ctx.lineTo(W-pad,H-pad); ctx.moveTo(pad,H-pad); ctx.lineTo(pad,pad); ctx.stroke();

      const step = (W-2*pad)/Math.max(1,(labels||[]).length-1);
      for(let i=0;i<(labels||[]).length;i++){
        const x = pad + i*step;
        const p = parseMonYr(labels[i]);
        // light guide (clipped)
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.globalAlpha=.18; ctx.strokeStyle='rgba(255,255,255,.5)'; ctx.setLineDash([]); ctx.lineCap='butt';
        ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, H - pad); ctx.stroke();
        ctx.restore(); ctx.globalAlpha=1;
        // January dotted (clipped + butt caps)
        if(p.mon === 1){
          ctx.save();
          ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
          ctx.strokeStyle = darkBlue; ctx.setLineDash([3,3]); ctx.lineCap='butt';
          ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, H - pad); ctx.stroke();
          ctx.restore();
        }
        // labels
        ctx.fillStyle = darkBlue; ctx.font='11px system-ui';
        if(p.mon === 1 && p.yr){ ctx.fillText('Jan', x-12, H - pad + 14); ctx.fillText(String(p.yr), x-16, H - pad + 26); }
        else if(p.mon){ ctx.fillText(MONTHS[p.mon-1], x-12, H - pad + 14); }
        else { ctx.fillText(String(labels[i]||''), x-12, H - pad + 14); }
      }

      // series (thin + points) — use clamped Y and clip to plot area
      ctx.lineCap='round'; ctx.lineJoin='round';
      (series||[]).forEach((s,si)=>{
        const col = colors[si%colors.length];
        const pts = (s.data||[]).map((v,i)=>({x:xFor(i), y:clampY(yFor(v))}));
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.strokeStyle=col; ctx.lineWidth=1.6;
        drawSmooth(ctx, pts, 0.35);
        ctx.fillStyle=col;
        pts.forEach((p,i)=>{ ctx.beginPath(); ctx.arc(p.x,p.y,2.2,0,Math.PI*2); ctx.fill(); if(focusIdx===i){ ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); } });
        ctx.restore();
      });

      // overlay dashed YoY — also clamped + clipped
      (overlay||[]).forEach((s,si)=>{
        const col = colors[si%colors.length];
        const pts = (s.data||[]).map((v,i)=>({x:xFor(i), y:clampY(yFor(v))}));
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.setLineDash([5,4]); ctx.globalAlpha=.8; ctx.strokeStyle=col; ctx.lineWidth=2; ctx.lineCap='butt';
        drawSmooth(ctx, pts, 0.35);
        ctx.restore();
      });

      // hover guide (clipped) + tooltip
      if(typeof focusIdx === 'number' && focusIdx >= 0){
        const gx = xFor(focusIdx);
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.strokeStyle='rgba(255,255,255,.15)'; ctx.setLineDash([4,4]); ctx.lineCap='butt';
        ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, H - pad); ctx.stroke();
        ctx.restore();

        const rows = [];
        (series||[]).forEach((s,si)=>{ const v=(s.data||[])[focusIdx]; if(v!=null){ rows.push({label:s.label||('Series '+(si+1)), value:Number(v), color:colors[si%colors.length]}); } });

        const tx = Math.min(gx + 12, W - pad - 180), ty = pad + 10, tw = 170, th = 22 + rows.length * 18;
        ctx.save(); ctx.fillStyle='rgba(13,22,37,.95)'; ctx.strokeStyle='rgba(255,255,255,.12)'; ctx.lineWidth=1;
        if(ctx.roundRect){ ctx.beginPath(); ctx.roundRect(tx, ty, tw, th, 6); ctx.fill(); ctx.stroke(); } else { ctx.fillRect(tx,ty,tw,th); ctx.strokeRect(tx,ty,tw,th); }
        ctx.fillStyle=darkBlue; ctx.font='12px system-ui';
        const p = parseMonYr(labels[focusIdx]);
        if(p.mon === 1 && p.yr){ ctx.fillText('Jan', tx+10, ty+14); ctx.fillText(String(p.yr), tx+10, ty+28); }
        else{ ctx.fillText(p.mon ? MONTHS[p.mon-1] : String(labels[focusIdx]||''), tx+10, ty+14); }
        rows.forEach((r,i)=>{ ctx.fillStyle=r.color; const base = (p.mon===1 && p.yr)? 28 : 14; const y=ty+ base + (i+1)*18; ctx.fillText(r.label+': '+r.value, tx+10, y); });
        ctx.restore();
      }
    }

    drawFrame(null);
    canvas.onmousemove = function(e){
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const step = (W - 2*pad)/Math.max(1,(labels||[]).length-1);
      let idx = Math.round((mx - pad)/step);
      idx = Math.max(0, Math.min((labels||[]).length-1, idx));
      drawFrame(idx);
    };
    canvas.onmouseleave = function(){ drawFrame(null); };
  };
})();
</script>

<!-- Patch: add Y-scale headroom (15%) + gentle clamp inside plot area -->
<script>
(function(){
  const MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  function parseMonYr(lbl){
    const s = String(lbl||'').trim(); let m;
    m = s.match(/^(\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[2]}; }
    m = s.match(/^(\d{4})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
    m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[3]}; }
    m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
    m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[\s\-](\d{4})$/i);
    if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:+m[2]}; }
    m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i);
    if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:null}; }
    return {mon:null, yr:null};
  }
  function ensureLegend(canvas, labelsAndColors){
    const wrap = canvas.parentElement || document.body;
    let legend = wrap.querySelector('.legend');
    if(!legend){
      legend = document.createElement('div');
      legend.className = 'legend';
      legend.style.cssText = 'display:flex;gap:16px;align-items:center;justify-content:flex-end;margin-top:8px;font-size:12px;color:#9fb2c8';
      wrap.appendChild(legend);
    } else {
      legend.innerHTML = '';
    }
    labelsAndColors.forEach(item => {
      const span = document.createElement('span');
      span.className = 'item';
      const sw = document.createElement('span');
      sw.style.cssText = 'display:inline-block;width:12px;height:3px;border-radius:2px;margin-right:6px;background:'+item.color;
      span.appendChild(sw);
      span.appendChild(document.createTextNode(item.label));
      legend.appendChild(span);
    });
    const badge = document.createElement('span');
    badge.className = 'item';
    const dash = document.createElement('span');
    dash.style.cssText = 'display:inline-block;width:26px;height:3px;background:linear-gradient(90deg,#9fb2c8 0 40%,transparent 40% 60%,#9fb2c8 60%);margin-right:6px';
    badge.appendChild(dash);
    badge.appendChild(document.createTextNode('Dashed = Previous Year'));
    legend.appendChild(badge);
  }
  window.lineChart = function(canvas, labels, series, overlay){
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height, pad = 40;
    const colors = ["#60a5fa","#f59e0b","#34d399","#f472b6","#a78bfa"];
    const darkBlue = getComputedStyle(document.body).getPropertyValue('--dash-blue').trim() || '#173b64';

    function drawSmooth(ctx, pts, t){
      if(pts.length < 2) return;
      const tension = (typeof t === 'number') ? t : 0.35;
      ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=0;i<pts.length-1;i++){
        const p0=pts[i-1]||pts[i], p1=pts[i], p2=pts[i+1], p3=pts[i+2]||p2;
        const cp1x=p1.x+(p2.x-p0.x)*t/2, cp1y=p1.y+(p2.y-p0.y)*t/2;
        const cp2x=p2.x-(p3.x-p1.x)*t/2, cp2y=p2.y-(p3.y-p1.y)*t/2;
        ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,p2.x,p2.y);
      }
      ctx.stroke();
    }

    ensureLegend(canvas, [
      {label:'Mail volume', color:colors[0]},
      {label:'CRM jobs',    color:colors[1]},
      {label:'Matches',     color:colors[2]}
    ]);

    // ----- SCALE with headroom -----
    const allVals = [...(series||[]).flatMap(s => s.data||[]), ...(overlay||[]).flatMap(s => s.data||[])].map(v => Number(v||0));
    const rawMax = Math.max(1, ...allVals);
    const rawMin = 0;
    const headroom = Math.max(5, (rawMax - rawMin) * 0.15);  // 15% top padding (>=5 units)
    const yMax = rawMax + headroom;
    const yMin = rawMin;
    const xFor = i => pad + i*(W-2*pad)/Math.max(1, (labels||[]).length-1);
    const yFor = v => {
      const y = H - pad - ((Number(v||0)-yMin)/(yMax-yMin)) * (H-2*pad);
      return y;
    };
    // tiny clamp to avoid hairline overlap with border
    const yClampTop = pad + 1;      // 1px inset from top
    const yClampBottom = H - pad - 1; // 1px inset from baseline
    const clampY = y => Math.max(yClampTop, Math.min(yClampBottom, y));

    function drawFrame(focusIdx){
      ctx.clearRect(0,0,W,H);
      // axes
      ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(pad,H-pad); ctx.lineTo(W-pad,H-pad); ctx.moveTo(pad,H-pad); ctx.lineTo(pad,pad); ctx.stroke();

      const step = (W-2*pad)/Math.max(1,(labels||[]).length-1);
      for(let i=0;i<(labels||[]).length;i++){
        const x = pad + i*step;
        const p = parseMonYr(labels[i]);

        // light guide (clip to plot area)
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.globalAlpha=.18; ctx.strokeStyle='rgba(255,255,255,.5)'; ctx.setLineDash([]); ctx.lineCap='butt';
        ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, H - pad); ctx.stroke();
        ctx.restore(); ctx.globalAlpha=1;

        // January dotted (clip + butt caps)
        if(p.mon === 1){
          ctx.save();
          ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
          ctx.strokeStyle = darkBlue; ctx.setLineDash([3,3]); ctx.lineCap='butt';
          ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, H - pad); ctx.stroke();
          ctx.restore();
        }

        // X-axis labels
        ctx.fillStyle = darkBlue; ctx.font='11px system-ui';
        if(p.mon === 1 && p.yr){ ctx.fillText('Jan', x-12, H - pad + 14); ctx.fillText(String(p.yr), x-16, H - pad + 26); }
        else if(p.mon){ ctx.fillText(MONTHS[p.mon-1], x-12, H - pad + 14); }
        else { ctx.fillText(String(labels[i]||''), x-12, H - pad + 14); }
      }

      // series (thin + points) — clip to plot & clamp to avoid edge touching
      ctx.lineCap='round'; ctx.lineJoin='round';
      (series||[]).forEach((s,si)=>{
        const col = colors[si%colors.length];
        const pts = (s.data||[]).map((v,i)=>({x:xFor(i), y:clampY(yFor(v))}));
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.strokeStyle=col; ctx.lineWidth=1.6;
        drawSmooth(ctx, pts, 0.35);
        ctx.fillStyle=col;
        pts.forEach((p,i)=>{ ctx.beginPath(); ctx.arc(p.x,p.y,2.2,0,Math.PI*2); ctx.fill(); if(focusIdx===i){ ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); } });
        ctx.restore();
      });

      // overlay dashed YoY — clip & clamp
      (overlay||[]).forEach((s,si)=>{
        const col = colors[si%colors.length];
        const pts = (s.data||[]).map((v,i)=>({x:xFor(i), y:clampY(yFor(v))}));
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.setLineDash([5,4]); ctx.globalAlpha=.8; ctx.strokeStyle=col; ctx.lineWidth=2; ctx.lineCap='butt';
        drawSmooth(ctx, pts, 0.35);
        ctx.restore();
      });

      // hover guide (clipped) + tooltip
      if(typeof focusIdx === 'number' && focusIdx >= 0){
        const gx = xFor(focusIdx);
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.strokeStyle='rgba(255,255,255,.15)'; ctx.setLineDash([4,4]); ctx.lineCap='butt';
        ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, H - pad); ctx.stroke();
        ctx.restore();

        const rows = [];
        (series||[]).forEach((s,si)=>{ const v=(s.data||[])[focusIdx]; if(v!=null){ rows.push({label:s.label||('Series '+(si+1)), value:Number(v), color:colors[si%colors.length]}); } });

        const tx = Math.min(gx + 12, W - pad - 180), ty = pad + 10, tw = 170, th = 22 + rows.length * 18;
        ctx.save(); ctx.fillStyle='rgba(13,22,37,.95)'; ctx.strokeStyle='rgba(255,255,255,.12)'; ctx.lineWidth=1;
        if(ctx.roundRect){ ctx.beginPath(); ctx.roundRect(tx, ty, tw, th, 6); ctx.fill(); ctx.stroke(); } else { ctx.fillRect(tx,ty,tw,th); ctx.strokeRect(tx,ty,tw,th); }
        ctx.fillStyle=darkBlue; ctx.font='12px system-ui';
        const p = parseMonYr(labels[focusIdx]);
        if(p.mon === 1 && p.yr){ ctx.fillText('Jan', tx+10, ty+14); ctx.fillText(String(p.yr), tx+10, ty+28); }
        else{ ctx.fillText(p.mon ? MONTHS[p.mon-1] : String(labels[focusIdx]||''), tx+10, ty+14); }
        rows.forEach((r,i)=>{ ctx.fillStyle=r.color; const base = (p.mon===1 && p.yr)? 28 : 14; const y=ty+ base + (i+1)*18; ctx.fillText(r.label+': '+r.value, tx+10, y); });
        ctx.restore();
      }
    }

    drawFrame(null);
    canvas.onmousemove = function(e){
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const step = (W - 2*pad)/Math.max(1,(labels||[]).length-1);
      let idx = Math.round((mx - pad)/step);
      idx = Math.max(0, Math.min((labels||[]).length-1, idx));
      drawFrame(idx);
    };
    canvas.onmouseleave = function(){ drawFrame(null); };
  };
})();
</script>

<!-- Patch: light-blue tooltip background + dark text + color swatches -->
<script>
(function(){
  const prev = window.lineChart;
  window.lineChart = function(canvas, labels, series, overlay){
    // reuse previous implementation but replace only the hover tooltip styling/paint
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height, pad = 40;
    const colors = ["#60a5fa","#f59e0b","#34d399","#f472b6","#a78bfa"];
    const MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
    const cs = getComputedStyle(document.body);
    const darkBlue = cs.getPropertyValue('--dash-blue').trim() || '#173b64';
    const lightBg = cs.getPropertyValue('--dash-light').trim() || cs.getPropertyValue('--dash-bg-light').trim() || '#E6F1FF';

    function parseMonYr(lbl){
      const s = String(lbl||'').trim(); let m;
      m = s.match(/^(\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[2]}; }
      m = s.match(/^(\d{4})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
      m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[3]}; }
      m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
      m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[\s\-](\d{4})$/i);
      if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:+m[2]}; }
      m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i);
      if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:null}; }
      return {mon:null, yr:null};
    }

    // Hook into the existing function by copying it, but swap only the hover drawer.
    // We'll re-run the draw logic from the current implementation in the file by
    // calling back into the previous lineChart with a proxy canvas that lets us
    // intercept hover. Simpler: replicate minimal hover code path here while
    // leaving axes/lines as-is by delegating initial draw and mouse handlers to prev,
    // then replacing mouse handlers with our styled version.

    // First, call prev to set up everything and draw once.
    prev(canvas, labels, series, overlay);

    // Now override the mouse handlers to use our tooltip styling but keep positions & scales stable.
    const rect = () => canvas.getBoundingClientRect();
    function computeScale(){
      const W=canvas.width, H=canvas.height, pad=40;
      const all = [...(series||[]).flatMap(s=>s.data||[]), ...(overlay||[]).flatMap(s=>s.data||[])].map(v=>Number(v||0));
      const rawMax = Math.max(1, ...all), rawMin = 0;
      const headroom = Math.max(5, (rawMax - rawMin) * 0.15);
      const yMax = rawMax + headroom, yMin = rawMin;
      const xFor = i => pad + i*(W-2*pad)/Math.max(1, (labels||[]).length-1);
      const yFor = v => H - pad - ((Number(v||0)-yMin)/(yMax-yMin)) * (H-2*pad);
      return {W,H,pad,xFor,yFor};
    }

    function redrawBase(idxHover){
      // Reinvoke prev to redraw base, then draw our hover
      prev(canvas, labels, series, overlay);
      if (typeof idxHover === 'number') drawHover(idxHover);
    }

    function drawHover(idx){
      const {W,H,pad,xFor,yFor} = computeScale();
      const gx = xFor(idx);

      // draw our own guide (clipped)
      ctx.save();
      ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
      ctx.strokeStyle='rgba(0,0,0,.18)'; ctx.setLineDash([4,4]); ctx.lineCap='butt';
      ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, H - pad); ctx.stroke();
      ctx.restore();

      // Tooltip content
      const rows = (series||[]).map((s,si)=>({label:s.label||('Series '+(si+1)), value:Number((s.data||[])[idx]), color:colors[si%colors.length]}))
                               .filter(r => !Number.isNaN(r.value));
      const tx = Math.min(gx + 12, W - pad - 220), ty = pad + 10, tw = 210, th = 28 + rows.length * 18 + 6;

      ctx.save();
      ctx.fillStyle = lightBg;
      ctx.strokeStyle = darkBlue;
      ctx.globalAlpha = 0.98;
      if(ctx.roundRect){ ctx.beginPath(); ctx.roundRect(tx, ty, tw, th, 8); ctx.fill(); ctx.globalAlpha=1; ctx.stroke(); }
      else { ctx.fillRect(tx,ty,tw,th); ctx.strokeRect(tx,ty,tw,th); }
      ctx.globalAlpha = 1;

      // Header: Jan on first line, year below (dark text)
      ctx.fillStyle = darkBlue; ctx.font = '12px system-ui';
      const p = parseMonYr(labels[idx]);
      if(p.mon === 1 && p.yr){ ctx.fillText('Jan', tx+10, ty+16); ctx.fillText(String(p.yr), tx+10, ty+30); }
      else { const m = p.mon ? MONTHS[p.mon-1] : String(labels[idx]||''); ctx.fillText(m, tx+10, ty+16); }

      // Rows: color swatch + dark text for readability
      rows.forEach((r,i)=>{
        const base = (p.mon===1 && p.yr)? 32 : 18;
        const y = ty + base + (i+1)*18;
        // swatch
        ctx.fillStyle = r.color;
        ctx.fillRect(tx+10, y-9, 10, 10);
        // text
        ctx.fillStyle = darkBlue;
        ctx.fillText(r.label + ': ' + r.value, tx+26, y);
      });
      ctx.restore();
    }

    // Replace handlers
    canvas.onmousemove = function(e){
      const r = rect();
      const mx = (e.clientX - r.left) * (canvas.width / r.width);
      const step = (canvas.width - 2*40)/Math.max(1,(labels||[]).length-1);
      let idx = Math.round((mx - 40)/step);
      idx = Math.max(0, Math.min((labels||[]).length-1, idx));
      redrawBase(idx);
    };
    canvas.onmouseleave = function(){ redrawBase(null); };
  };
})();
</script>

<!-- FINAL lineChart override: styling + clipping + headroom + LIGHT tooltip -->
<script>
(function(){
  const MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  window.lineChart = function(canvas, labels, series, overlay){
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height, pad = 40;
    const colors = ["#60a5fa","#f59e0b","#34d399","#f472b6","#a78bfa"];
    const cs = getComputedStyle(document.body);
    const darkBlue = cs.getPropertyValue('--dash-blue').trim() || '#173b64';
    const lightBg  = cs.getPropertyValue('--dash-light').trim() || cs.getPropertyValue('--dash-bg-light').trim() || '#E6F1FF';

    function parseMonYr(lbl){
      const s = String(lbl||'').trim(); let m;
      m = s.match(/^(\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[2]}; }
      m = s.match(/^(\d{4})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
      m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[3]}; }
      m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
      m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[\s\-](\d{4})$/i);
      if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:+m[2]}; }
      m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i);
      if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:null}; }
      return {mon:null, yr:null};
    }

    function drawSmooth(ctx, pts, t){
      if(pts.length < 2) return;
      const tension = (typeof t === 'number') ? t : 0.35;
      ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=0;i<pts.length-1;i++){
        const p0=pts[i-1]||pts[i], p1=pts[i], p2=pts[i+1], p3=pts[i+2]||p2;
        const cp1x=p1.x+(p2.x-p0.x)*t/2, cp1y=p1.y+(p2.y-p0.y)*t/2;
        const cp2x=p2.x-(p3.x-p1.x)*t/2, cp2y=p2.y-(p3.y-p1.y)*t/2;
        ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,p2.x,p2.y);
      }
      ctx.stroke();
    }

    // Legend (kept as-is)
    (function ensureLegend(){
      const wrap = canvas.parentElement || document.body;
      let legend = wrap.querySelector('.legend');
      if(!legend){
        legend = document.createElement('div');
        legend.className = 'legend';
        legend.style.cssText = 'display:flex;gap:16px;align-items:center;justify-content:flex-end;margin-top:8px;font-size:12px;color:#9fb2c8';
        wrap.appendChild(legend);
      }
      legend.innerHTML = '';
      [{label:'Mail volume',color:colors[0]},{label:'CRM jobs',color:colors[1]},{label:'Matches',color:colors[2]}].forEach(item=>{
        const span = document.createElement('span');
        span.className = 'item';
        const sw = document.createElement('span');
        sw.style.cssText = 'display:inline-block;width:12px;height:3px;border-radius:2px;margin-right:6px;background:'+item.color;
        span.appendChild(sw);
        span.appendChild(document.createTextNode(item.label));
        legend.appendChild(span);
      });
      const badge = document.createElement('span');
      badge.className='item';
      const dash = document.createElement('span');
      dash.style.cssText='display:inline-block;width:26px;height:3px;background:linear-gradient(90deg,#9fb2c8 0 40%,transparent 40% 60%,#9fb2c8 60%);margin-right:6px';
      badge.appendChild(dash);
      badge.appendChild(document.createTextNode('Dashed = Previous Year'));
      legend.appendChild(badge);
    })();

    // ----- SCALE with headroom -----
    const allVals = [...(series||[]).flatMap(s => s.data||[]), ...(overlay||[]).flatMap(s => s.data||[])].map(v => Number(v||0));
    const rawMax = Math.max(1, ...allVals);
    const rawMin = 0;
    const headroom = Math.max(5, (rawMax - rawMin) * 0.15);  // 15% top padding (>=5 units)
    const yMax = rawMax + headroom;
    const yMin = rawMin;

    const xFor = i => pad + i*(W-2*pad)/Math.max(1, (labels||[]).length-1);
    const yFor = v => H - pad - ((Number(v||0)-yMin)/(yMax-yMin)) * (H-2*pad);
    const yClampTop = pad + 1;      // tiny inset to avoid overlap with border
    const yClampBottom = H - pad - 1;
    const clampY = y => Math.max(yClampTop, Math.min(yClampBottom, y));

    function drawFrame(focusIdx){
      ctx.clearRect(0,0,W,H);
      // axes
      ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(pad,H-pad); ctx.lineTo(W-pad,H-pad); ctx.moveTo(pad,H-pad); ctx.lineTo(pad,pad); ctx.stroke();

      const step = (W-2*pad)/Math.max(1,(labels||[]).length-1);
      for(let i=0;i<(labels||[]).length;i++){
        const x = pad + i*step;
        const p = parseMonYr(labels[i]);
        // light guide (clipped)
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.globalAlpha=.18; ctx.strokeStyle='rgba(255,255,255,.5)'; ctx.setLineDash([]); ctx.lineCap='butt';
        ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, H - pad); ctx.stroke();
        ctx.restore(); ctx.globalAlpha=1;
        // January dotted (clipped + butt caps)
        if(p.mon === 1){
          ctx.save();
          ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
          ctx.strokeStyle = darkBlue; ctx.setLineDash([3,3]); ctx.lineCap='butt';
          ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, H - pad); ctx.stroke();
          ctx.restore();
        }
        // labels
        ctx.fillStyle = darkBlue; ctx.font='11px system-ui';
        if(p.mon === 1 && p.yr){ ctx.fillText('Jan', x-12, H - pad + 14); ctx.fillText(String(p.yr), x-16, H - pad + 26); }
        else if(p.mon){ ctx.fillText(MONTHS[p.mon-1], x-12, H - pad + 14); }
      }

      // series (thin + points) — clip + clamp
      ctx.lineCap='round'; ctx.lineJoin='round';
      (series||[]).forEach((s,si)=>{
        const col = colors[si%colors.length];
        const pts = (s.data||[]).map((v,i)=>({x:xFor(i), y:clampY(yFor(v))}));
        ctx.save(); ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.strokeStyle=col; ctx.lineWidth=1.6; drawSmooth(ctx, pts, 0.35);
        ctx.fillStyle=col; pts.forEach((p,i)=>{ ctx.beginPath(); ctx.arc(p.x,p.y,2.2,0,Math.PI*2); ctx.fill(); if(focusIdx===i){ ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); } });
        ctx.restore();
      });

      // overlay dashed YoY — clip + clamp
      (overlay||[]).forEach((s,si)=>{
        const col = colors[si%colors.length];
        const pts = (s.data||[]).map((v,i)=>({x:xFor(i), y:clampY(yFor(v))}));
        ctx.save(); ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.setLineDash([5,4]); ctx.globalAlpha=.8; ctx.strokeStyle=col; ctx.lineWidth=2; ctx.lineCap='butt'; drawSmooth(ctx, pts, 0.35);
        ctx.restore();
      });

      // hover
      if(typeof focusIdx === 'number' && focusIdx >= 0){
        const gx = xFor(focusIdx);
        // guide (clipped)
        ctx.save(); ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.strokeStyle='rgba(0,0,0,.18)'; ctx.setLineDash([4,4]); ctx.lineCap='butt';
        ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, H - pad); ctx.stroke(); ctx.restore();

        // tooltip: LIGHT background + dark text
        const rows = (series||[]).map((s,si)=>({label:s.label||('Series '+(si+1)), value:Number((s.data||[])[focusIdx]), color:colors[si%colors.length]}))
                                 .filter(r => !Number.isNaN(r.value));
        const tx = Math.min(gx + 12, W - pad - 220), ty = pad + 10, tw = 210, th = 28 + rows.length * 18 + 6;

        ctx.save();
        ctx.fillStyle = lightBg;
        ctx.strokeStyle = darkBlue;
        if(ctx.roundRect){ ctx.beginPath(); ctx.roundRect(tx, ty, tw, th, 8); ctx.fill(); ctx.stroke(); }
        else { ctx.fillRect(tx,ty,tw,th); ctx.strokeRect(tx,ty,tw,th); }

        // header
        ctx.fillStyle = darkBlue; ctx.font = '12px system-ui';
        const p = parseMonYr(labels[focusIdx]);
        if(p.mon === 1 && p.yr){ ctx.fillText('Jan', tx+10, ty+16); ctx.fillText(String(p.yr), tx+10, ty+30); }
        else { const m = p.mon ? MONTHS[p.mon-1] : String(labels[focusIdx]||''); ctx.fillText(m, tx+10, ty+16); }

        // rows with color swatches
        rows.forEach((r,i)=>{
          const base = (p.mon===1 && p.yr)? 32 : 18;
          const y = ty + base + (i+1)*18;
          ctx.fillStyle = r.color; ctx.fillRect(tx+10, y-9, 10, 10);
          ctx.fillStyle = darkBlue; ctx.fillText(r.label+': '+r.value, tx+26, y);
        });
        ctx.restore();
      }
    }

    // draw + handlers
    drawFrame(null);
    canvas.onmousemove = function(e){
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const step = (W - 2*pad)/Math.max(1,(labels||[]).length-1);
      let idx = Math.round((mx - pad)/step);
      idx = Math.max(0, Math.min((labels||[]).length-1, idx));
      drawFrame(idx);
    };
    canvas.onmouseleave = function(){ drawFrame(null); };
  };
})();
</script>

<!-- Tooltip tweak: month-only header + inherit exact dashboard background color -->
<script>
(function(){
  const MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  function parseMonYr(lbl){
    const s = String(lbl||'').trim(); let m;
    m = s.match(/^(\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[2]}; }
    m = s.match(/^(\d{4})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
    m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[3]}; }
    m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
    m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[\s\-](\d{4})$/i);
    if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:+m[2]}; }
    m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i);
    if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:null}; }
    return {mon:null, yr:null};
  }

  function pickTooltipBg(canvas){
    // Walk up the DOM to find the first ancestor with a solid (non-transparent) background
    function alphaFromColor(c){
      // expects rgb(a) string; assume opaque if not rgba
      if(!c) return 0;
      if (c === 'transparent') return 0;
      const m = c.match(/rgba?\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)(?:\s*,\s*([\d.]+))?\s*\)/i);
      if(!m) return 1; // non-rgba string like hex => treat as opaque
      return m[4] == null ? 1 : parseFloat(m[4]);
    }
    let el = canvas;
    while(el){
      const cs = getComputedStyle(el);
      const bg = cs.backgroundColor;
      if (alphaFromColor(bg) > 0) return bg;
      el = el.parentElement;
    }
    // Fallbacks: design tokens if present, else default light blue
    const root = getComputedStyle(document.body);
    return root.getPropertyValue('--dash-light').trim() || root.getPropertyValue('--dash-bg-light').trim() || '#E6F1FF';
  }

  // Wrap/replace the current lineChart to change only tooltip drawing
  const prev = window.lineChart;
  if (!prev) return;
  window.lineChart = function(canvas, labels, series, overlay){
    // Call existing to set up and draw
    prev(canvas, labels, series, overlay);

    const ctx = canvas.getContext('2d');
    const cs = getComputedStyle(document.body);
    const darkBlue = cs.getPropertyValue('--dash-blue').trim() || '#173b64';

    // Recompute scale helpers to position our tooltip
    function computeScale(){
      const W=canvas.width, H=canvas.height, pad=40;
      const all = [...(series||[]).flatMap(s => s.data||[]), ...(overlay||[]).flatMap(s => s.data||[])].map(v => Number(v||0));
      const rawMax = Math.max(1, ...all), rawMin = 0;
      const headroom = Math.max(5, (rawMax - rawMin) * 0.15);
      const yMax = rawMax + headroom, yMin = rawMin;
      const xFor = i => pad + i*(W-2*pad)/Math.max(1, (labels||[]).length-1);
      const yFor = v => H - pad - ((Number(v||0)-yMin)/(yMax-yMin)) * (H-2*pad);
      return {W,H,pad,xFor,yFor};
    }

    function redrawBase(idxHover){
      // Reinvoke prev to redraw base, then paint our tooltip
      prev(canvas, labels, series, overlay);
      if (typeof idxHover === 'number') drawHover(idxHover);
    }

    function drawHover(idx){
      const {W,H,pad,xFor} = computeScale();
      const gx = xFor(idx);

      // Guide (clipped)
      ctx.save();
      ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
      ctx.strokeStyle='rgba(0,0,0,.18)'; ctx.setLineDash([4,4]); ctx.lineCap='butt';
      ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, H - pad); ctx.stroke();
      ctx.restore();

      // Tooltip content
      const rows = (series||[]).map((s,si)=>({label:s.label||('Series '+(si+1)), value:Number((s.data||[])[idx]), color: ['#60a5fa','#f59e0b','#34d399','#f472b6','#a78bfa'][si%5]}))
                               .filter(r => !Number.isNaN(r.value));

      // Month-only (no year) in header
      const p = parseMonYr(labels[idx]);
      const monthLabel = p.mon ? MONTHS[p.mon-1] : String(labels[idx]||'');

      const tx = Math.min(gx + 12, W - pad - 220), ty = pad + 10, tw = 210, th = 24 + rows.length * 18 + 8;

      // Light background pulled from actual dashboard container
      const lightBg = pickTooltipBg(canvas);

      ctx.save();
      ctx.fillStyle = lightBg;
      ctx.strokeStyle = darkBlue;
      if(ctx.roundRect){ ctx.beginPath(); ctx.roundRect(tx, ty, tw, th, 8); ctx.fill(); ctx.stroke(); }
      else { ctx.fillRect(tx,ty,tw,th); ctx.strokeRect(tx,ty,tw,th); }

      // Header: month only
      ctx.fillStyle = darkBlue; ctx.font = '12px system-ui';
      ctx.fillText(monthLabel, tx+10, ty+16);

      // Rows with color swatches
      rows.forEach((r,i)=>{
        const y = ty + 16 + 6 + (i+1)*18;
        ctx.fillStyle = r.color; ctx.fillRect(tx+10, y-9, 10, 10);
        ctx.fillStyle = darkBlue; ctx.fillText(r.label+': '+r.value, tx+26, y);
      });
      ctx.restore();
    }

    canvas.onmousemove = function(e){
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const step = (canvas.width - 2*40)/Math.max(1,(labels||[]).length-1);
      let idx = Math.round((mx - 40)/step);
      idx = Math.max(0, Math.min((labels||[]).length-1, idx));
      redrawBase(idx);
    };
    canvas.onmouseleave = function(){ redrawBase(null); };
  };
})();
</script>

<!-- AUTHORITATIVE OVERRIDE: month-only tooltip + exact bg + existing style -->
<script>
(function(){
  const MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

  function parseMonYr(lbl){
    const s = String(lbl||'').trim(); let m;
    m = s.match(/^(\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[2]}; }
    m = s.match(/^(\d{4})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
    m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[3]}; }
    m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
    m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[\s\-](\d{4})$/i);
    if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:+m[2]}; }
    m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i);
    if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:null}; }
    return {mon:null, yr:null};
  }

  function ensureLegend(canvas, labelsAndColors){
    const wrap = canvas.parentElement || document.body;
    let legend = wrap.querySelector('.legend');
    if(!legend){
      legend = document.createElement('div');
      legend.className = 'legend';
      legend.style.cssText = 'display:flex;gap:16px;align-items:center;justify-content:flex-end;margin-top:8px;font-size:12px;color:#9fb2c8';
      wrap.appendChild(legend);
    }
    legend.innerHTML = '';
    labelsAndColors.forEach(item => {
      const span = document.createElement('span');
      span.className = 'item';
      const sw = document.createElement('span');
      sw.style.cssText = 'display:inline-block;width:12px;height:3px;border-radius:2px;margin-right:6px;background:'+item.color;
      span.appendChild(sw);
      span.appendChild(document.createTextNode(item.label));
      legend.appendChild(span);
    });
    const badge = document.createElement('span');
    badge.className = 'item';
    const dash = document.createElement('span');
    dash.style.cssText = 'display:inline-block;width:26px;height:3px;background:linear-gradient(90deg,#9fb2c8 0 40%,transparent 40% 60%,#9fb2c8 60%);margin-right:6px';
    badge.appendChild(dash);
    badge.appendChild(document.createTextNode('Dashed = Previous Year'));
    legend.appendChild(badge);
  }

  function pickTooltipBg(canvas){
    function alphaFromColor(c){
      if(!c) return 0;
      if (c === 'transparent') return 0;
      const m = c.match(/rgba?\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)(?:\s*,\s*([\d.]+))?\s*\)/i);
      if(!m) return 1; // hex or named color -> assume opaque
      return m[4] == null ? 1 : parseFloat(m[4]);
    }
    let el = canvas;
    while(el){
      const cs = getComputedStyle(el);
      const bg = cs.backgroundColor;
      if (alphaFromColor(bg) > 0) return bg;
      el = el.parentElement;
    }
    const root = getComputedStyle(document.body);
    return root.getPropertyValue('--dash-light').trim() || root.getPropertyValue('--dash-bg-light').trim() || '#E6F1FF';
  }

  window.lineChart = function(canvas, labels, series, overlay){
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height, pad = 40;
    const colors = ["#60a5fa","#f59e0b","#34d399","#f472b6","#a78bfa"];
    const cs = getComputedStyle(document.body);
    const darkBlue = cs.getPropertyValue('--dash-blue').trim() || '#173b64';

    function drawSmooth(ctx, pts, t){
      if(pts.length < 2) return;
      const tension = (typeof t === 'number') ? t : 0.35;
      ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=0;i<pts.length-1;i++){
        const p0=pts[i-1]||pts[i], p1=pts[i], p2=pts[i+1], p3=pts[i+2]||p2;
        const cp1x=p1.x+(p2.x-p0.x)*t/2, cp1y=p1.y+(p2.y-p0.y)*t/2;
        const cp2x=p2.x-(p3.x-p1.x)*t/2, cp2y=p2.y-(p3.y-p1.y)*t/2;
        ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,p2.x,p2.y);
      }
      ctx.stroke();
    }

    ensureLegend(canvas, [
      {label:'Mail volume', color:colors[0]},
      {label:'CRM jobs',    color:colors[1]},
      {label:'Matches',     color:colors[2]}
    ]);

    // SCALE with headroom
    const allVals = [...(series||[]).flatMap(s => s.data||[]), ...(overlay||[]).flatMap(s => s.data||[])].map(v => Number(v||0));
    const rawMax = Math.max(1, ...allVals);
    const rawMin = 0;
    const headroom = Math.max(5, (rawMax - rawMin) * 0.15);
    const yMax = rawMax + headroom, yMin = rawMin;

    const xFor = i => pad + i*(W-2*pad)/Math.max(1, (labels||[]).length-1);
    const yFor = v => H - pad - ((Number(v||0)-yMin)/(yMax-yMin)) * (H-2*pad);
    const yClampTop = pad + 1, yClampBottom = H - pad - 1;
    const clampY = y => Math.max(yClampTop, Math.min(yClampBottom, y));

    function drawFrame(focusIdx){
      ctx.clearRect(0,0,W,H);
      // axes
      ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(pad,H-pad); ctx.lineTo(W-pad,H-pad); ctx.moveTo(pad,H-pad); ctx.lineTo(pad,pad); ctx.stroke();

      const step = (W-2*pad)/Math.max(1,(labels||[]).length-1);
      for(let i=0;i<(labels||[]).length;i++){
        const x = pad + i*step;
        const p = parseMonYr(labels[i]);

        // light guide (clipped)
        ctx.save();
        ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.globalAlpha=.18; ctx.strokeStyle='rgba(255,255,255,.5)'; ctx.setLineDash([]); ctx.lineCap='butt';
        ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, H - pad); ctx.stroke();
        ctx.restore(); ctx.globalAlpha=1;

        // January dotted (clipped + butt caps)
        if(p.mon === 1){
          ctx.save();
          ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
          ctx.strokeStyle = darkBlue; ctx.setLineDash([3,3]); ctx.lineCap='butt';
          ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, H - pad); ctx.stroke();
          ctx.restore();
        }

        // X-axis labels: Jan on top line + year below; others MMM
        ctx.fillStyle = darkBlue; ctx.font='11px system-ui';
        if(p.mon === 1 && p.yr){ ctx.fillText('Jan', x-12, H - pad + 14); ctx.fillText(String(p.yr), x-16, H - pad + 26); }
        else if(p.mon){ ctx.fillText(MONTHS[p.mon-1], x-12, H - pad + 14); }
      }

      // series (thin + points) — clip + clamp
      ctx.lineCap='round'; ctx.lineJoin='round';
      (series||[]).forEach((s,si)=>{
        const col = colors[si%colors.length];
        const pts = (s.data||[]).map((v,i)=>({x:xFor(i), y:clampY(yFor(v))}));
        ctx.save(); ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.strokeStyle=col; ctx.lineWidth=1.6; drawSmooth(ctx, pts, 0.35);
        ctx.fillStyle=col; pts.forEach((p,i)=>{ ctx.beginPath(); ctx.arc(p.x,p.y,2.2,0,Math.PI*2); ctx.fill(); if(focusIdx===i){ ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); } });
        ctx.restore();
      });

      // overlay dashed YoY — clip + clamp
      (overlay||[]).forEach((s,si)=>{
        const col = colors[si%colors.length];
        const pts = (s.data||[]).map((v,i)=>({x:xFor(i), y:clampY(yFor(v))}));
        ctx.save(); ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.setLineDash([5,4]); ctx.globalAlpha=.8; ctx.strokeStyle=col; ctx.lineWidth=2; ctx.lineCap='butt'; drawSmooth(ctx, pts, 0.35);
        ctx.restore();
      });

      // hover: month-only header + exact bg
      if(typeof focusIdx === 'number' && focusIdx >= 0){
        const gx = xFor(focusIdx);
        // guide (clipped)
        ctx.save(); ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
        ctx.strokeStyle='rgba(0,0,0,.18)'; ctx.setLineDash([4,4]); ctx.lineCap='butt';
        ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, H - pad); ctx.stroke(); ctx.restore();

        const rows = (series||[]).map((s,si)=>({label:s.label||('Series '+(si+1)), value:Number((s.data||[])[focusIdx]), color:colors[si%colors.length]}))
                                 .filter(r => !Number.isNaN(r.value));

        // month-only
        const p = parseMonYr(labels[focusIdx]);
        const monthLabel = p.mon ? MONTHS[p.mon-1] : String(labels[focusIdx]||'');

        const tx = Math.min(gx + 12, W - pad - 220), ty = pad + 10, tw = 210, th = 24 + rows.length * 18 + 8;
        const lightBg = pickTooltipBg(canvas);

        ctx.save();
        ctx.fillStyle = lightBg;
        ctx.strokeStyle = darkBlue;
        if(ctx.roundRect){ ctx.beginPath(); ctx.roundRect(tx, ty, tw, th, 8); ctx.fill(); ctx.stroke(); }
        else { ctx.fillRect(tx,ty,tw,th); ctx.strokeRect(tx,ty,tw,th); }

        ctx.fillStyle = darkBlue; ctx.font = '12px system-ui';
        ctx.fillText(monthLabel, tx+10, ty+16);

        rows.forEach((r,i)=>{
          const y = ty + 16 + 6 + (i+1)*18;
          ctx.fillStyle = r.color; ctx.fillRect(tx+10, y-9, 10, 10);
          ctx.fillStyle = darkBlue; ctx.fillText(r.label+': '+r.value, tx+26, y);
        });
        ctx.restore();
      }
    }

    // draw + handlers (ours only)
    drawFrame(null);
    canvas.onmousemove = function(e){
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const step = (W - 2*pad)/Math.max(1,(labels||[]).length-1);
      let idx = Math.round((mx - pad)/step);
      idx = Math.max(0, Math.min((labels||[]).length-1, idx));
      drawFrame(idx);
    };
    canvas.onmouseleave = function(){ drawFrame(null); };
  };
})();
</script>

<!-- In-chart YoY toggle: move control to top-right of the graph and drive overlay on/off -->
<script>
(function(){
  const lastArgs = new WeakMap(); // canvas -> {labels, series, overlay}

  // Wrap the current lineChart so we can store args and ensure a toggle exists
  const prev = window.lineChart;
  if (!prev) return;

  function ensureYoYToggle(canvas){
    const parent = canvas.parentElement || document.body;
    // Make the parent a positioned container so we can place the toggle inside
    if (getComputedStyle(parent).position === 'static') {
      parent.style.position = 'relative';
    }
    let holder = parent.querySelector('#yoyToggleInChart');
    if (!holder){
      holder = document.createElement('label');
      holder.id = 'yoyToggleInChart';
      holder.style.cssText = [
        'position:absolute','top:8px','right:8px','display:flex','align-items:center','gap:6px',
        'background: rgba(255,255,255,0.85)','backdrop-filter: blur(6px)',
        'padding:6px 10px','border-radius:8px','border:1px solid rgba(0,0,0,.08)',
        'font: 12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif',
        'color:#0b2942','cursor:pointer','z-index:5'
      ].join(';');
      const cb = document.createElement('input');
      cb.type = 'checkbox'; cb.id = 'yoyToggleInChart_cb';
      // default on; load from storage if present
      const saved = localStorage.getItem('chart_yoy_enabled');
      cb.checked = saved == null ? true : saved === 'true';
      const span = document.createElement('span'); span.textContent = 'Show YoY overlay';
      holder.appendChild(cb); holder.appendChild(span);
      parent.appendChild(holder);

      cb.addEventListener('change', function(){
        localStorage.setItem('chart_yoy_enabled', String(cb.checked));
        // re-render the chart using last known args
        const args = lastArgs.get(canvas);
        if (args){
          // Call the authoritative renderer if present; else use prev
          (window.lineChart.authoritative || window.lineChart)(canvas, args.labels, args.series, args.overlay);
        }
      });
    }
    return holder.querySelector('input[type="checkbox"]');
  }

  function yoyEnabled(canvas){
    const cb = (canvas.parentElement||document.body).querySelector('#yoyToggleInChart_cb');
    if (cb) return cb.checked;
    const saved = localStorage.getItem('chart_yoy_enabled');
    return saved == null ? true : saved === 'true';
  }

  // Authoritative renderer that respects the YoY toggle
  function renderWithToggle(canvas, labels, series, overlay){
    lastArgs.set(canvas, {labels, series, overlay});
    // Ensure toggle exists
    ensureYoYToggle(canvas);
    // Call the current renderer but pass overlay only if enabled
    const useOverlay = yoyEnabled(canvas) ? (overlay || []) : [];
    // We rely on the latest authoritative implementation already appended
    // which defines window.lineChart (this function will be attached to it below).
    // To avoid recursion, temporarily swap out window.lineChart to the previous renderer.
    const current = window.lineChart;
    window.lineChart = prev;
    try {
      prev(canvas, labels, series, useOverlay);
    } finally {
      window.lineChart = current;
    }
  }

  // Expose as the new lineChart (and mark as authoritative so our toggle handler can call it)
  function lineChart(canvas, labels, series, overlay){ renderWithToggle(canvas, labels, series, overlay); }
  lineChart.authoritative = renderWithToggle;
  window.lineChart = lineChart;

  // Try to hide any old global "Show YoY overlay" control elsewhere on the page
  // by finding a label containing that exact text.
  window.requestAnimationFrame(()=>{
    const all = Array.from(document.querySelectorAll('label,button,span'));
    const needle = /show\s*yoy\s*overlay/i;
    for (const el of all){
      if (needle.test(el.textContent || '')){
        // If it's not our in-chart one, hide its container
        if (el.id !== 'yoyToggleInChart'){
          const container = el.closest('*');
          if (container && container !== document.body && container.id !== 'yoyToggleInChart'){
            container.style.display = 'none';
          }
        }
      }
    }
  });
})();
</script>

<!-- Brand Color Override: darker blue/green/orange for series & legend -->
<script>
(function(){
  const MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  function pickVar(vars, fallback){
    const cs = getComputedStyle(document.body);
    for (const v of vars){
      const val = cs.getPropertyValue(v).trim();
      if (val) return val;
    }
    return fallback;
  }

  // Build a brand palette from CSS variables with sensible dark fallbacks
  function brandColors(){
    const blue   = pickVar(['--dash-blue','--brand-blue','--primary-700','--primary'], '#0f2f52');   // dark navy
    const orange = pickVar(['--brand-orange','--accent-orange','--warning-700','--warning'], '#b45309'); // dark orange
    const green  = pickVar(['--brand-green','--accent-green','--success-700','--success'], '#176a4d');   // dark green
    const pink   = pickVar(['--brand-pink','--accent-pink'], '#9d174d');
    const violet = pickVar(['--brand-violet','--accent-violet'], '#6d28d9');
    return [blue, orange, green, pink, violet];
  }

  // Authoritative recolor wrapper: leave rendering/tooltip behavior intact,
  // but swap the color palette used by the chart + legend.
  const prev = window.lineChart;
  if (!prev) return;

  window.lineChart = function(canvas, labels, series, overlay){
    // We'll call the latest authoritative renderer but before that,
    // we temporarily monkey-patch getComputedStyle to inject our brand colors
    // by overriding the 'colors' array creation via a proxy.
    // Simpler: re-implement a thin layer that mirrors the last authoritative function,
    // but only differs in the palette.
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height, pad = 40;

    const colors = brandColors();
    const cs = getComputedStyle(document.body);
    const darkBlue = cs.getPropertyValue('--dash-blue').trim() || colors[0];

    function parseMonYr(lbl){
      const s = String(lbl||'').trim(); let m;
      m = s.match(/^(\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[2]}; }
      m = s.match(/^(\d{4})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
      m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[3]}; }
      m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
      m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[\s\-](\d{4})$/i);
      if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:+m[2]}; }
      m = s.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/i);
      if(m){ const mon = MONTHS.findIndex(x=>x.toLowerCase()===m[1].slice(0,3).toLowerCase())+1; return {mon, yr:null}; }
      return {mon:null, yr:null};
    }

    // Legend (recolored)
    (function ensureLegend(){
      const wrap = canvas.parentElement || document.body;
      let legend = wrap.querySelector('.legend');
      if(!legend){
        legend = document.createElement('div');
        legend.className = 'legend';
        legend.style.cssText = 'display:flex;gap:16px;align-items:center;justify-content:flex-end;margin-top:8px;font-size:12px;color:#9fb2c8';
        wrap.appendChild(legend);
      }
      legend.innerHTML = '';
      [{label:'Mail volume',color:colors[0]},{label:'CRM jobs',color:colors[1]},{label:'Matches',color:colors[2]}].forEach(item=>{
        const span = document.createElement('span');
        span.className = 'item';
        const sw = document.createElement('span');
        sw.style.cssText = 'display:inline-block;width:12px;height:3px;border-radius:2px;margin-right:6px;background:'+item.color;
        span.appendChild(sw);
        span.appendChild(document.createTextNode(item.label));
        legend.appendChild(span);
      });
      const badge = document.createElement('span');
      badge.className='item';
      const dash = document.createElement('span');
      dash.style.cssText='display:inline-block;width:26px;height:3px;background:linear-gradient(90deg,#9fb2c8 0 40%,transparent 40% 60%,#9fb2c8 60%);margin-right:6px';
      badge.appendChild(dash);
      badge.appendChild(document.createTextNode('Dashed = Previous Year'));
      legend.appendChild(badge);
    })();

    // Use the last authoritative renderer for everything else, but pass through the recolored palette
    // by rewriting the series colors at draw time.
    function recolorSeries(data, palette){
      // do not mutate original
      return (data||[]).map((s, i)=>{
        const copy = Object.assign({}, s);
        copy.color = palette[i % palette.length];
        return copy;
      });
    }

    // Render using the authoritative implementation we defined previously
    // but feed recolored series/overlay. We rely on that function reading s.color if present.
    const authoritative = (function(){
      // Find the most recent lineChart definition that has our full drawFrame pipeline.
      // We stored it in window.lineChart before overwriting; it's accessible via 'prev' above.
      return prev;
    })();

    // If the underlying renderer ignores s.color and uses its own palette,
    // fall back to calling our own full renderer. For simplicity here,
    // we call prev (which is our latest authoritative that uses 'colors' inside).
    // Because of that, we cannot inject palette inside; so we replicate minimal drawing here:
    // To avoid conflicts, we detect a flag:
    const usesInternalPalette = true;

    if (usesInternalPalette){
      // Re-implement the previously set authoritative renderer with our palette
      // (copy of the last override, but with 'colors = brandColors()' baked in).
      const W=canvas.width, H=canvas.height, pad=40;
      const allVals = [...(series||[]).flatMap(s => s.data||[]), ...(overlay||[]).flatMap(s => s.data||[])].map(v => Number(v||0));
      const rawMax = Math.max(1, ...allVals), rawMin = 0;
      const headroom = Math.max(5, (rawMax - rawMin) * 0.15);
      const yMax = rawMax + headroom, yMin = rawMin;
      const yFor = v => H - pad - ((Number(v||0)-yMin)/(yMax-yMin)) * (H-2*pad);
      const xFor = i => pad + i*(W-2*pad)/Math.max(1,(labels||[]).length-1);
      const yClampTop = pad + 1, yClampBottom = H - pad - 1;
      const clampY = y => Math.max(yClampTop, Math.min(yClampBottom, y));

      function drawSmooth(ctx, pts, t){
        if(pts.length < 2) return;
        const tension = (typeof t === 'number') ? t : 0.35;
        ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=0;i<pts.length-1;i++){
          const p0=pts[i-1]||pts[i], p1=pts[i], p2=pts[i+1], p3=pts[i+2]||p2;
          const cp1x=p1.x+(p2.x-p0.x)*t/2, cp1y=p1.y+(p2.y-p0.y)*t/2;
          const cp2x=p2.x-(p3.x-p1.x)*t/2, cp2y=p2.y-(p3.y-p1.y)*t/2;
          ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,p2.x,p2.y);
        }
        ctx.stroke();
      }

      function drawFrame(focusIdx){
        ctx.clearRect(0,0,W,H);
        // axes
        ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(pad,H-pad); ctx.lineTo(W-pad,H-pad); ctx.moveTo(pad,H-pad); ctx.lineTo(pad,pad); ctx.stroke();

        const step = (W-2*pad)/Math.max(1,(labels||[]).length-1);
        for(let i=0;i<(labels||[]).length;i++){
          const x = pad + i*step;
          const label = labels[i];
          // light vertical guide (clipped)
          ctx.save(); ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
          ctx.globalAlpha=.18; ctx.strokeStyle='rgba(255,255,255,.5)'; ctx.setLineDash([]); ctx.lineCap='butt';
          ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, H - pad); ctx.stroke();
          ctx.restore(); ctx.globalAlpha=1;

          // January dotted (if month 1 present in label)
          const p = (function(l){ 
            const s = String(l||'').trim(); let m;
            m = s.match(/^(\d{4})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
            m = s.match(/^(\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[2]}; }
            m = s.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})$/); if(m){ return {mon:+m[1], yr:+m[3]}; }
            m = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})$/); if(m){ return {mon:+m[2], yr:+m[1]}; }
            return {mon:null, yr:null};
          })(label);
          if(p.mon === 1){
            ctx.save(); ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
            ctx.strokeStyle = darkBlue; ctx.setLineDash([3,3]); ctx.lineCap='butt';
            ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, H - pad); ctx.stroke();
            ctx.restore();
          }
          // X labels
          ctx.fillStyle = darkBlue; ctx.font='11px system-ui';
          if(p.mon === 1 && p.yr){ ctx.fillText('Jan', x-12, H - pad + 14); ctx.fillText(String(p.yr), x-16, H - pad + 26); }
          else if(p.mon){ ctx.fillText(MONTHS[p.mon-1], x-12, H - pad + 14); }
        }

        // series (recolored)
        ctx.lineCap='round'; ctx.lineJoin='round';
        (series||[]).forEach((s,si)=>{
          const col = colors[si%colors.length];
          const pts = (s.data||[]).map((v,i)=>({x:xFor(i), y:clampY(yFor(v))}));
          ctx.save(); ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
          ctx.strokeStyle=col; ctx.lineWidth=1.6; drawSmooth(ctx, pts, 0.35);
          ctx.fillStyle=col; pts.forEach((p,i)=>{ ctx.beginPath(); ctx.arc(p.x,p.y,2.2,0,Math.PI*2); ctx.fill(); if(focusIdx===i){ ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); } });
          ctx.restore();
        });

        // overlay (recolored to match series index), shown/hidden by existing toggle logic
        (overlay||[]).forEach((s,si)=>{
          const col = colors[si%colors.length];
          const pts = (s.data||[]).map((v,i)=>({x:xFor(i), y:clampY(yFor(v))}));
          ctx.save(); ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
          ctx.setLineDash([5,4]); ctx.globalAlpha=.8; ctx.strokeStyle=col; ctx.lineWidth=2; ctx.lineCap='butt'; drawSmooth(ctx, pts, 0.35);
          ctx.restore();
        });

        // hover (month-only, uses existing bg logic already in file)
        canvas.onmousemove = function(e){
          const rect = canvas.getBoundingClientRect();
          const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
          let idx = Math.round((mx - pad)/((W-2*pad)/Math.max(1,(labels||[]).length-1)));
          idx = Math.max(0, Math.min((labels||[]).length-1, idx));
          // delegate to existing hover renderer by re-calling previous most recent chart draw
          // which draws tooltip; but we need month-only. We'll draw a simple month-only tooltip here:
          drawFrame(idx); // redraw base
          // guide
          const gx = xFor(idx);
          ctx.save(); ctx.beginPath(); ctx.rect(pad, pad, W - 2*pad, H - 2*pad); ctx.clip();
          ctx.strokeStyle='rgba(0,0,0,.18)'; ctx.setLineDash([4,4]); ctx.lineCap='butt';
          ctx.beginPath(); ctx.moveTo(gx, pad); ctx.lineTo(gx, H - pad); ctx.stroke(); ctx.restore();

          // Tooltip bg from ancestor
          function pickBg(){
            function alphaFromColor(c){
              if(!c) return 0; if (c === 'transparent') return 0;
              const m = c.match(/rgba?\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)(?:\s*,\s*([\d.]+))?\s*\)/i);
              if(!m) return 1; return m[4]==null?1:parseFloat(m[4]);
            }
            let el = canvas; while(el){
              const cs = getComputedStyle(el); const bg = cs.backgroundColor;
              if (alphaFromColor(bg)>0) return bg; el = el.parentElement;
            }
            return '#E6F1FF';
          }
          const tx = Math.min(gx + 12, W - pad - 220), ty = pad + 10, tw = 210;
          const vals = (series||[]).map((s,si)=>({label:s.label||('Series '+(si+1)), value:Number((s.data||[])[idx]), color:colors[si%colors.length]})).filter(r=>!Number.isNaN(r.value));
          const th = 24 + vals.length*18 + 8;
          const lightBg = pickBg();
          ctx.save(); ctx.fillStyle=lightBg; ctx.strokeStyle=darkBlue;
          if(ctx.roundRect){ ctx.beginPath(); ctx.roundRect(tx, ty, tw, th, 8); ctx.fill(); ctx.stroke(); }
          else { ctx.fillRect(tx,ty,tw,th); ctx.strokeRect(tx,ty,tw,th); }
          ctx.fillStyle=darkBlue; ctx.font='12px system-ui';
          // month-only header
          const s = String(labels[idx]||''); let m = s.match(/^(\d{4})[-\/](\d{1,2})$/); let mIdx=null;
          if(m){ mIdx = +m[2]-1; } else { m = s.match(/^(\d{1,2})[-\/](\d{4})$/); if(m){ mIdx=+m[1]-1; }}
          const monthLabel = (mIdx!=null && mIdx>=0 && mIdx<12) ? MONTHS[mIdx] : s;
          ctx.fillText(monthLabel, tx+10, ty+16);
          vals.forEach((r,i)=>{ const y = ty + 16 + 6 + (i+1)*18; ctx.fillStyle=r.color; ctx.fillRect(tx+10,y-9,10,10); ctx.fillStyle=darkBlue; ctx.fillText(r.label+': '+r.value, tx+26, y); });
          ctx.restore();
        };
        canvas.onmouseleave = function(){ drawFrame(null); };
      }
      drawFrame(null);
    } else {
      authoritative(canvas, labels, recolorSeries(series, colors), recolorSeries(overlay, colors));
    }
  };
})();
</script>

<!-- Restore in-chart YoY toggle (top-right of graph) and bind to current renderer -->
<script>
(function(){
  if (!window.lineChart) return;
  const prev = window.lineChart;
  const LAST_KEY = 'chart_yoy_enabled';
  const lastArgs = new WeakMap();

  function ensureToggle(canvas){
    const parent = canvas.parentElement || document.body;
    if (getComputedStyle(parent).position === 'static') { parent.style.position = 'relative'; }
    let holder = parent.querySelector('#yoyToggleInChart');
    if (!holder){
      holder = document.createElement('label');
      holder.id = 'yoyToggleInChart';
      holder.style.cssText = [
        'position:absolute','top:8px','right:8px','display:flex','align-items:center','gap:6px',
        'background: rgba(255,255,255,0.85)','backdrop-filter: blur(6px)',
        'padding:6px 10px','border-radius:8px','border:1px solid rgba(0,0,0,.08)',
        'font: 12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif',
        'color:#0b2942','cursor:pointer','z-index:99'
      ].join(';');
      const cb = document.createElement('input');
      cb.type = 'checkbox'; cb.id = 'yoyToggleInChart_cb';
      const saved = localStorage.getItem(LAST_KEY);
      cb.checked = saved == null ? true : saved === 'true';
      const span = document.createElement('span'); span.textContent = 'Show YoY overlay';
      holder.appendChild(cb); holder.appendChild(span);
      parent.appendChild(holder);
    }
    return holder.querySelector('input[type="checkbox"]');
  }

  function yoyEnabled(canvas){
    const cb = (canvas.parentElement||document.body).querySelector('#yoyToggleInChart_cb');
    if (cb) return cb.checked;
    const saved = localStorage.getItem(LAST_KEY);
    return saved == null ? true : saved === 'true';
  }

  function render(canvas, labels, series, overlay){
    const cb = ensureToggle(canvas);
    const enabled = yoyEnabled(canvas);
    const finalOverlay = enabled ? (overlay || []) : [];
    // Call the previous renderer (brand-colored) with overlay filtered
    prev(canvas, labels, series, finalOverlay);
    if (cb && !cb.dataset.bound){
      cb.dataset.bound = '1';
      cb.addEventListener('change', function(){
        localStorage.setItem(LAST_KEY, String(cb.checked));
        const a = lastArgs.get(canvas);
        if (a){ render(canvas, a.labels, a.series, a.overlay); }
      });
    }
  }

  window.lineChart = function(canvas, labels, series, overlay){
    lastArgs.set(canvas, {labels, series, overlay});
    render(canvas, labels, series, overlay);
  };
})();
</script>

<!-- DASHBOARD SKIN: Mapping Tool Aesthetic Match -->
<style id="dash-mapper-skin">
  :root{
    /* fallbacks if tokens are missing */
    --dash-blue: var(--brand-blue, #173b64);
    --dash-panel: var(--dash-light, var(--dash-bg-light, #E6F1FF));
    --dash-text: var(--text-900, #0b2942);
    --dash-muted: var(--text-500, #6b7f93);
    --dash-border: rgba(0,0,0,.10);
    --dash-accent: var(--brand-orange, #b45309);
    --dash-success: var(--brand-green, #176a4d);
  }
  /* Try to catch common mapping tool containers */
  .mapping-tool, #mappingTool, .map-tool, .column-mapper, .mapping-panel, [data-role="mapper"], [data-view="mapping"]{
    background: var(--dash-panel);
    color: var(--dash-text);
    border: 1px solid var(--dash-border);
    border-radius: 14px;
    box-shadow: 0 6px 20px rgba(0,0,0,.06);
    padding: 16px 16px 12px;
  }
  .mapping-tool h2, #mappingTool h2, .map-tool h2, .column-mapper h2{
    color: var(--dash-blue);
    font: 600 14px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    letter-spacing: .2px;
    margin: 0 0 10px 0;
  }
  .mapping-tool .subtle, .column-mapper .help, .map-tool .help, .mapping-panel .help, .mapping-tool p.hint{
    color: var(--dash-muted);
    font-size: 12px;
    margin: 4px 0 10px;
  }
  /* Inputs & selects */
  .mapping-tool select, .mapping-tool input[type="text"],
  .column-mapper select, .column-mapper input[type="text"],
  .map-tool select, .map-tool input[type="text"]{
    background: #fff;
    color: var(--dash-text);
    border: 1px solid var(--dash-border);
    border-radius: 10px;
    padding: 8px 10px;
    outline: none;
  }
  .mapping-tool select:focus, .mapping-tool input[type="text"]:focus,
  .column-mapper select:focus, .column-mapper input[type="text"]:focus{
    border-color: color-mix(in oklab, var(--dash-blue) 50%, #ffffff 50%);
    box-shadow: 0 0 0 3px color-mix(in oklab, var(--dash-blue) 20%, transparent);
  }
  /* Buttons */
  .mapping-tool .btn, .column-mapper .btn, .map-tool .btn{
    display: inline-flex; align-items:center; gap:8px;
    border-radius: 999px;
    padding: 8px 14px;
    border: 1px solid var(--dash-border);
    background: #fff;
    color: var(--dash-blue);
    font-weight: 600; font-size: 12px;
    cursor: pointer;
  }
  .mapping-tool .btn.primary, .column-mapper .btn.primary, .map-tool .btn.primary{
    background: var(--dash-blue); color:#fff; border-color: transparent;
  }
  .mapping-tool .btn.ghost, .column-mapper .btn.ghost, .map-tool .btn.ghost{
    background: transparent; color: var(--dash-blue);
  }
  .mapping-tool .btn:hover, .column-mapper .btn:hover, .map-tool .btn:hover{
    filter: brightness(0.97);
  }
  /* Table / grid of detected columns */
  .mapping-tool .grid, .column-mapper .grid, .map-tool .grid{
    display:grid; grid-template-columns: 1fr 1fr; gap: 10px;
    margin-top: 10px;
  }
  .mapping-tool .card, .column-mapper .card, .map-tool .card{
    background:#fff; border:1px solid var(--dash-border); border-radius:12px; padding:10px;
  }
  .mapping-tool .card h3{ font:600 12px/1.2 system-ui; color:var(--dash-blue); margin:0 0 6px; }
  .mapping-tool .badge, .column-mapper .badge, .map-tool .badge{
    display:inline-block; padding:3px 8px; border-radius:999px; font-size:11px;
    border:1px solid var(--dash-border); background: #fff; color: var(--dash-text);
  }
  .mapping-tool .badge.unmapped{ background: color-mix(in oklab, var(--dash-accent) 12%, #fff 88%); color: var(--dash-accent); border-color: color-mix(in oklab, var(--dash-accent) 30%, #fff 70%); }
  .mapping-tool .badge.mapped{ background: color-mix(in oklab, var(--dash-success) 12%, #fff 88%); color: var(--dash-success); border-color: color-mix(in oklab, var(--dash-success) 30%, #fff 70%); }
  /* Error/empty state */
  .mapping-tool .empty, .column-mapper .empty, .map-tool .empty{
    background: color-mix(in oklab, var(--dash-blue) 6%, #fff 94%);
    border: 1px dashed color-mix(in oklab, var(--dash-blue) 30%, #fff 70%);
    border-radius: 12px; padding: 14px; color: var(--dash-muted); font-size:12px;
  }
</style>
<script>
(function(){
  // If the existing mapping UI had an inline dark background, neutralize it to match the dashboard.
  function applyDashSkin(){
    const candidates = document.querySelectorAll('.mapping-tool, #mappingTool, .map-tool, .column-mapper, .mapping-panel, [data-role="mapper"], [data-view="mapping"]');
    candidates.forEach(el => {
      // Only adjust if the background is a dark blue-ish tone
      const bg = getComputedStyle(el).backgroundColor;
      // Heuristic: if computed luminance is low and hue is bluish, override it
      const m = bg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
      if(m){
        const r=+m[1], g=+m[2], b=+m[3];
        const lum = 0.2126*r + 0.7152*g + 0.0722*b; // relative-ish
        if(lum < 120 && b > r && b > g){ // likely dark blue
          el.style.background = getComputedStyle(document.body).getPropertyValue('--dash-panel').trim() || '#E6F1FF';
          el.style.color = getComputedStyle(document.body).getPropertyValue('--dash-text').trim() || '#0b2942';
        }
      }
      el.classList.add('mapping-tool'); // ensure our skin selectors apply
    });
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', applyDashSkin);
  } else {
    applyDashSkin();
  }
  // Also re-apply after the app swaps its route/state (very light observer)
  new MutationObserver(() => applyDashSkin()).observe(document.body, {subtree:true, childList:true});
})();
</script>

<!-- Dashboard Skin: Mapping Modal (month/columns popup) -->
<style id="dash-mapper-modal-skin">
  :root{
    --dash-blue: var(--brand-blue, #173b64);
    --dash-panel: var(--dash-light, var(--dash-bg-light, #E6F1FF));
    --dash-text: var(--text-900, #0b2942);
    --dash-muted: var(--text-500, #6b7f93);
    --dash-border: rgba(0,0,0,.10);
    --dash-accent: var(--brand-orange, #b45309);
    --dash-success: var(--brand-green, #176a4d);
  }
  /* Generic modal containers we might encounter */
  .dash-mapper-modal,
  .modal, .dialog, .popup, .modal-container, .ReactModal__Content, .ant-modal, .chakra-modal__content, [role="dialog"]{
    /* Only apply our palette when our script marks it or when it clearly matches mapper */
  }
  /* Our modal class explicitly set by script below */
  .dash-mapper-modal{
    background: var(--dash-panel) !important;
    color: var(--dash-text) !important;
    border: 1px solid var(--dash-border);
    border-radius: 14px;
    box-shadow: 0 12px 40px rgba(0,0,0,.15);
    padding: 18px 18px 14px;
  }
  .dash-mapper-modal h1,
  .dash-mapper-modal h2,
  .dash-mapper-modal .title{
    color: var(--dash-blue);
    font: 700 16px/1.25 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    margin: 0 0 8px 0;
  }
  .dash-mapper-modal p,
  .dash-mapper-modal .subtitle,
  .dash-mapper-modal .hint{
    color: var(--dash-muted);
    font-size: 12px;
    margin: 4px 0 12px;
  }
  .dash-mapper-modal .section-title{
    margin-top: 10px;
    font: 600 12px/1.2 system-ui;
    color: var(--dash-blue);
  }
  .dash-mapper-modal input[type="text"],
  .dash-mapper-modal input[type="search"],
  .dash-mapper-modal select,
  .dash-mapper-modal textarea{
    background: #fff;
    color: var(--dash-text);
    border: 1px solid var(--dash-border);
    border-radius: 10px;
    padding: 8px 10px;
    outline: none;
  }
  .dash-mapper-modal input:focus,
  .dash-mapper-modal select:focus,
  .dash-mapper-modal textarea:focus{
    border-color: color-mix(in oklab, var(--dash-blue) 50%, #ffffff 50%);
    box-shadow: 0 0 0 3px color-mix(in oklab, var(--dash-blue) 20%, transparent);
  }
  .dash-mapper-modal .example, .dash-mapper-modal .help-text{
    color: var(--dash-muted);
    font-size: 11px;
  }
  .dash-mapper-modal .btn,
  .dash-mapper-modal button{
    display: inline-flex; align-items:center; gap:8px;
    border-radius: 999px;
    padding: 8px 14px;
    border: 1px solid var(--dash-border);
    background: #fff;
    color: var(--dash-blue);
    font-weight: 600; font-size: 12px;
    cursor: pointer;
  }
  .dash-mapper-modal .btn.primary{
    background: var(--dash-blue); color:#fff; border-color: transparent;
  }
  .dash-mapper-modal .btn.ghost{
    background: transparent; color: var(--dash-blue);
  }
  .dash-mapper-modal .danger,
  .dash-mapper-modal .link-danger{
    color: var(--dash-accent);
  }
  .dash-mapper-modal .footer{
    display:flex; justify-content:flex-end; gap:8px; margin-top: 12px;
  }
  /* Badges for "required"/"optional" */
  .dash-mapper-modal .badge{
    display:inline-block; padding:3px 8px; border-radius:999px; font-size:11px;
    border:1px solid var(--dash-border); background: #fff; color: var(--dash-text);
  }
  .dash-mapper-modal .badge.required{ background: color-mix(in oklab, var(--dash-accent) 12%, #fff 88%); color: var(--dash-accent); border-color: color-mix(in oklab, var(--dash-accent) 30%, #fff 70%); }
  .dash-mapper-modal .badge.optional{ background: color-mix(in oklab, var(--dash-success) 12%, #fff 88%); color: var(--dash-success); border-color: color-mix(in oklab, var(--dash-success) 30%, #fff 70%); }

  /* Backdrop */
  .dash-mapper-backdrop{
    background: rgba(11, 41, 66, 0.35) !important; /* subtle dark-blue translucent */
    position: fixed; inset: 0; pointer-events: none;
  }
</style>
<script>
(function(){
  // Find the mapping popup and tag it so our CSS applies, even if classes are dynamic.
  function tagMapperModal(){
    const dialogs = Array.from(document.querySelectorAll('[role="dialog"], .modal, .dialog, .popup, .modal-container, .ReactModal__Content, .ant-modal, .chakra-modal__content'));
    for (const el of dialogs){
      const txt = (el.textContent || '').toLowerCase();
      // Heuristic: these phrases are unique to the mapper UI
      if (txt.includes('map your columns') && txt.includes('we couldn\'t automatically detect some columns')){
        el.classList.add('dash-mapper-modal');
        // Try to tag backdrop too
        const parent = el.parentElement || document.body;
        const bgs = parent.querySelectorAll('.modal-backdrop, .backdrop, .ant-modal-mask, .chakra-modal__overlay');
        bgs.forEach(bg => bg.classList.add('dash-mapper-backdrop'));
      }
    }
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', tagMapperModal);
  } else {
    tagMapperModal();
  }
  new MutationObserver(tagMapperModal).observe(document.body, {subtree:true, childList:true});
})();
</script>

<!-- Mapping Modal Sections: force light panel backgrounds for 'Mail CSV' and 'CRM CSV' groups -->
<style id="dash-mapper-modal-sections-skin">
  :root{
    --dash-blue: var(--brand-blue, #173b64);
    --dash-panel: var(--dash-light, var(--dash-bg-light, #E6F1FF));
    --dash-text: var(--text-900, #0b2942);
    --dash-border: rgba(0,0,0,.10);
  }
  /* Generic group containers inside the modal */
  .dash-mapper-modal .section,
  .dash-mapper-modal .panel,
  .dash-mapper-modal .card,
  .dash-mapper-modal .group,
  .dash-mapper-modal fieldset,
  .dash-mapper-modal .ant-card,
  .dash-mapper-modal .chakra-card,
  .dash-mapper-modal .MuiPaper-root{
    background: var(--dash-panel) !important;
    color: var(--dash-text) !important;
    border: 1px solid var(--dash-border);
    border-radius: 12px;
    padding: 12px;
  }
  /* Inputs still white for readability */
  .dash-mapper-modal input[type="text"],
  .dash-mapper-modal input[type="search"],
  .dash-mapper-modal select,
  .dash-mapper-modal textarea{
    background: #fff !important;
    color: var(--dash-text) !important;
  }
</style>
<script>
(function(){
  // Helper: detect dark-ish backgrounds
  function isDark(bg){
    if(!bg || bg === 'transparent') return false;
    const m = bg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
    if(!m) return false;
    const r=+m[1], g=+m[2], b=+m[3];
    const lum = 0.2126*r + 0.7152*g + 0.0722*b;
    return lum < 140; // threshold for "dark-ish"
  }
  function forceLight(el){
    const cs = getComputedStyle(el);
    if (isDark(cs.backgroundColor)){
      el.style.background = getComputedStyle(document.body).getPropertyValue('--dash-panel').trim() || '#E6F1FF';
      el.style.color = getComputedStyle(document.body).getPropertyValue('--dash-text').trim() || '#0b2942';
      el.style.border = '1px solid var(--dash-border)';
      el.style.borderRadius = '12px';
      el.style.padding = el.style.padding || '12px';
    }
  }
  function apply(){
    const modal = document.querySelector('.dash-mapper-modal, [role="dialog"]');
    if(!modal) return;
    // Find headings that read exactly "Mail CSV" or "CRM CSV"
    const headings = Array.from(modal.querySelectorAll('h1,h2,h3,h4,.title,.section-title')).filter(h => {
      const t = (h.textContent||'').trim().toLowerCase();
      return t === 'mail csv' || t === 'crm csv';
    });
    headings.forEach(h => {
      // climb up a few levels to find the group container
      let el = h; let steps = 0;
      while(el && steps < 5){
        el = el.parentElement; steps++;
        if(!el) break;
        const bg = getComputedStyle(el).backgroundColor;
        if (bg && bg !== 'transparent'){
          forceLight(el);
          // also lighten any direct children blocks that still look dark
          Array.from(el.children).forEach(ch => forceLight(ch));
          break;
        }
      }
    });
    // As a safety net, lighten any card/group under the modal that still has dark background
    Array.from(modal.querySelectorAll('.card,.panel,.section,.group,fieldset,div')).forEach(node => {
      if (node.closest('.dash-mapper-modal')){
        const cs = getComputedStyle(node);
        if (isDark(cs.backgroundColor)) forceLight(node);
      }
    });
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', apply);
  } else {
    apply();
  }
  new MutationObserver(apply).observe(document.body, {subtree:true, childList:true});
})();
</script>

<!-- POLISH: Dashboard-style mapping popup (visual only, no behavior changes) -->
<style id="dash-mapper-modal-polish">
  :root{
    --dash-blue: var(--brand-blue, #173b64);
    --dash-panel: var(--dash-light, var(--dash-bg-light, #E6F1FF));
    --dash-text: var(--text-900, #0b2942);
    --dash-muted: var(--text-500, #6b7f93);
    --dash-border: rgba(0,0,0,.10);
    --dash-shadow: 0 12px 40px rgba(0,0,0,.12);
    --dash-card: #ffffff;
  }
  .dash-mapper-modal{
    background: var(--dash-panel) !important;
    color: var(--dash-text) !important;
    border: 1px solid var(--dash-border) !important;
    border-radius: 16px !important;
    box-shadow: var(--dash-shadow) !important;
    padding: 18px 20px 14px !important;
    width: min(92vw, 980px) !important;
    max-height: min(80vh, 760px) !important;
    overflow: auto !important;
  }
  .dash-mapper-modal h1, .dash-mapper-modal h2, .dash-mapper-modal .title{
    color: var(--dash-blue) !important;
    font: 700 18px/1.25 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif !important;
    margin: 0 0 6px 0 !important;
    letter-spacing: .2px !important;
  }
  .dash-mapper-modal p, .dash-mapper-modal .subtitle, .dash-mapper-modal .hint{
    color: var(--dash-muted) !important;
    font-size: 12px !important;
    margin: 4px 0 12px !important;
  }
  .dash-mapper-modal h3, .dash-mapper-modal .section-title{
    display: inline-block !important;
    background: #fff !important;
    color: var(--dash-blue) !important;
    border: 1px solid var(--dash-border) !important;
    border-radius: 999px !important;
    padding: 6px 10px !important;
    font: 600 12px/1 system-ui !important;
    margin: 12px 0 8px !important;
  }
  .dash-mapper-modal .card, .dash-mapper-modal .panel, .dash-mapper-modal .group,
  .dash-mapper-modal fieldset, .dash-mapper-modal .ant-card, .dash-mapper-modal .chakra-card,
  .dash-mapper-modal .MuiPaper-root, .dash-mapper-modal .box, .dash-mapper-modal [class*="card"], .dash-mapper-modal [class*="panel"]{
    background: var(--dash-card) !important;
    color: var(--dash-text) !important;
    border: 1px solid var(--dash-border) !important;
    border-radius: 14px !important;
    padding: 12px !important;
    box-shadow: 0 4px 14px rgba(0,0,0,.05) !important;
  }
  .dash-mapper-modal label{ font: 600 12px/1.2 system-ui !important; color: var(--dash-blue) !important; }
  .dash-mapper-modal small, .dash-mapper-modal .example, .dash-mapper-modal .help-text{ color: var(--dash-muted) !important; font-size: 11px !important; }
  .dash-mapper-modal input[type="text"], .dash-mapper-modal input[type="search"],
  .dash-mapper-modal input[type="number"], .dash-mapper-modal select, .dash-mapper-modal textarea{
    background:#fff !important; color: var(--dash-text) !important;
    border:1px solid var(--dash-border) !important; border-radius:10px !important;
    padding:8px 10px !important; outline:none !important;
    height: 36px !important;
  }
  .dash-mapper-modal textarea{ height: auto !important; min-height: 64px !important; }
  .dash-mapper-modal select{ appearance: none; background-image: linear-gradient(45deg, transparent 50%, var(--dash-blue) 50%), linear-gradient(135deg, var(--dash-blue) 50%, transparent 50%);
    background-position: calc(100% - 16px) calc(1em + 2px), calc(100% - 12px) calc(1em + 2px);
    background-size: 4px 4px, 4px 4px; background-repeat: no-repeat; padding-right: 28px !important;
  }
  .dash-mapper-modal input:focus, .dash-mapper-modal select:focus, .dash-mapper-modal textarea:focus{
    border-color: color-mix(in oklab, var(--dash-blue) 55%, #ffffff 45%) !important;
    box-shadow: 0 0 0 3px color-mix(in oklab, var(--dash-blue) 20%, transparent) !important;
  }
  .dash-mapper-modal .btn, .dash-mapper-modal button{
    display:inline-flex !important; align-items:center !important; gap:8px !important;
    border-radius:999px !important; padding:8px 14px !important;
    border:1px solid var(--dash-border) !important; background:#fff !important; color:var(--dash-blue) !important;
    font-weight:600 !important; font-size:12px !important; cursor:pointer !important;
  }
  .dash-mapper-modal .btn.primary, .dash-mapper-modal .primary, .dash-mapper-modal .confirm{
    background: var(--dash-blue) !important; color:#fff !important; border-color: transparent !important;
  }
  .dash-mapper-modal .btn.ghost, .dash-mapper-modal .secondary{
    background: transparent !important; color: var(--dash-blue) !important;
  }
  .dash-mapper-modal .footer{ display:flex !important; justify-content:flex-end !important; gap:8px !important; margin-top:14px !important; }
  .dash-mapper-backdrop{ background: rgba(11,41,66,.35) !important; position: fixed !important; inset:0 !important; }
  /* Nuke dark nested blocks inside the modal */
  .dash-mapper-modal .bg-dark, .dash-mapper-modal .bg-primary, .dash-mapper-modal .bg-blue,
  .dash-mapper-modal [class*="bg-dark"], .dash-mapper-modal [class*="bg-blue"]{
    background: var(--dash-card) !important;
  }
</style>
<script>
(function(){
  function tag(){
    const dialogs = Array.from(document.querySelectorAll('[role="dialog"], .modal, .dialog, .popup, .modal-container, .ReactModal__Content, .ant-modal, .chakra-modal__content'));
    for (const el of dialogs){
      const txt = (el.textContent || '').toLowerCase();
      if (txt.includes('map your columns') && txt.includes('we couldn\\'t automatically detect some columns')){
        el.classList.add('dash-mapper-modal');
        const parent = el.parentElement || document.body;
        const bgs = parent.querySelectorAll('.modal-backdrop, .backdrop, .ant-modal-mask, .chakra-modal__overlay');
        bgs.forEach(bg => bg.classList.add('dash-mapper-backdrop'));
        // If Mail/CRM wrappers exist, make them "panel" cards to force light bg
        const heads = el.querySelectorAll('h1,h2,h3,.title,.section-title');
        heads.forEach(h=>{
          const t = (h.textContent||'').trim().toLowerCase();
          if (t === 'mail csv' || t === 'crm csv'){ (h.parentElement||el).classList.add('panel'); }
        });
      }
    }
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', tag); } else { tag(); }
  new MutationObserver(tag).observe(document.body, {subtree:true, childList:true});
})();
</script>

<!-- MAPPER POLISH V2: cohesive, minimal lines, true dash colors, no dark blocks -->
<style id="dash-mapper-modal-polish-v2">
  :root{
    --dash-blue: var(--brand-blue, #173b64);
    --dash-text: var(--text-900, #0b2942);
    --dash-muted: var(--text-500, #6b7f93);
    --dash-border: rgba(0,0,0,.08);
    --mapper-bg: var(--dash-bg-light, #f5f9ff); /* will be set by JS to EXACT panel bg */
    --mapper-card: #ffffff;                      /* card surface inside modal */
    --mapper-shadow: 0 16px 48px rgba(0,0,0,.16);
    --mapper-ring: color-mix(in oklab, var(--dash-blue) 22%, transparent);
  }
  /* Modal shell */
  .dash-mapper-modal{
    background: var(--mapper-bg) !important;
    color: var(--dash-text) !important;
    border: 0 !important;
    border-radius: 18px !important;
    box-shadow: var(--mapper-shadow) !important;
    padding: 20px 22px 16px !important;
    width: min(96vw, 980px) !important;
    max-height: min(84vh, 760px) !important;
    overflow: auto !important;
  }
  /* Header & subtitle */
  .dash-mapper-modal h1, .dash-mapper-modal h2, .dash-mapper-modal .title{
    color: var(--dash-blue) !important;
    font: 700 18px/1.25 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif !important;
    margin: 0 0 4px 0 !important;
    letter-spacing: .2px !important;
  }
  .dash-mapper-modal .subtitle, .dash-mapper-modal p.hint, .dash-mapper-modal .hint{
    color: var(--dash-muted) !important;
    font-size: 12px !important;
    margin: 2px 0 12px !important;
  }
  /* Layout: two-column grid for Mail/CRM blocks; stack on narrow widths */
  .dash-mapper-modal .mapper-grid{
    display: grid !important;
    grid-template-columns: 1fr 1fr;
    gap: 14px;
    margin-top: 10px;
  }
  @media (max-width: 900px){
    .dash-mapper-modal .mapper-grid{ grid-template-columns: 1fr; }
  }
  /* Section headers as soft pills */
  .dash-mapper-modal .section-title, .dash-mapper-modal h3{
    display:inline-block !important;
    background: var(--mapper-card) !important;
    color: var(--dash-blue) !important;
    border-radius: 999px !important;
    padding: 6px 10px !important;
    font: 600 12px/1 system-ui !important;
    margin: 6px 0 8px !important;
    box-shadow: 0 0 0 1px var(--dash-border) inset !important;
  }
  /* Cards (Mail CSV / CRM CSV) with NO heavy borders; subtle inset hairline only */
  .dash-mapper-modal .mapper-card{
    background: var(--mapper-card) !important;
    color: var(--dash-text) !important;
    border: 0 !important;
    border-radius: 14px !important;
    padding: 14px !important;
    box-shadow: 0 2px 10px rgba(0,0,0,.06) !important;
  }
  /* Form elements */
  .dash-mapper-modal label{
    display:block; margin: 8px 0 4px; font: 600 12px/1.2 system-ui !important; color: var(--dash-blue) !important;
  }
  .dash-mapper-modal small, .dash-mapper-modal .example, .dash-mapper-modal .help-text{
    color: var(--dash-muted) !important; font-size: 11px !important;
  }
  .dash-mapper-modal input[type="text"], .dash-mapper-modal input[type="search"],
  .dash-mapper-modal input[type="number"], .dash-mapper-modal select, .dash-mapper-modal textarea{
    background:#fff !important; color: var(--dash-text) !important;
    border:1px solid var(--dash-border) !important; border-radius:10px !important;
    padding:8px 10px !important; outline:none !important; height: 36px !important;
    box-shadow: none !important;
  }
  .dash-mapper-modal textarea{ min-height: 64px !important; }
  .dash-mapper-modal select{
    appearance: none;
    background-image: linear-gradient(45deg, transparent 50%, var(--dash-blue) 50%), linear-gradient(135deg, var(--dash-blue) 50%, transparent 50%);
    background-position: calc(100% - 16px) calc(1em + 2px), calc(100% - 12px) calc(1em + 2px);
    background-size: 4px 4px, 4px 4px; background-repeat: no-repeat; padding-right: 28px !important;
  }
  .dash-mapper-modal input:focus, .dash-mapper-modal select:focus, .dash-mapper-modal textarea:focus{
    border-color: color-mix(in oklab, var(--dash-blue) 55%, #ffffff 45%) !important;
    box-shadow: 0 0 0 3px var(--mapper-ring) !important;
  }
  /* Buttons */
  .dash-mapper-modal .btn, .dash-mapper-modal button{
    display:inline-flex !important; align-items:center !important; gap:8px !important;
    border-radius:999px !important; padding:8px 14px !important;
    border:1px solid var(--dash-border) !important; background:#fff !important; color:var(--dash-blue) !important;
    font-weight:600 !important; font-size:12px !important; cursor:pointer !important;
  }
  .dash-mapper-modal .btn.primary, .dash-mapper-modal .primary, .dash-mapper-modal .confirm{
    background: var(--dash-blue) !important; color:#fff !important; border-color: transparent !important;
  }
  .dash-mapper-modal .btn.ghost, .dash-mapper-modal .secondary{
    background: transparent !important; color: var(--dash-blue) !important;
  }
  .dash-mapper-modal .footer, .dash-mapper-modal .actions, .dash-mapper-modal .modal-footer{
    background: transparent !important;
    border-top: 0 !important;
    display:flex !important; justify-content:flex-end !important; gap:8px !important; margin-top:14px !important;
  }
  /* Remove unnecessary lines/borders inside the modal */
  .dash-mapper-modal hr, .dash-mapper-modal .divider{
    border: 0 !important; height: 0 !important; margin: 0 !important;
  }
  /* Kill any dark sections still present at bottom */
  .dash-mapper-modal [class*="bg-dark"], .dash-mapper-modal .bg-primary, .dash-mapper-modal .bg-blue{
    background: var(--mapper-card) !important;
  }
</style>
<script>
(function(){
  // Find & tag the mapper dialog; build a clean structure (grid + cards) without changing content.
  function luminance(rgb){
    const m = rgb && rgb.match(/rgba?\\((\\d+),(\\d+),(\\d+)/i);
    if(!m) return 255;
    const r=+m[1], g=+m[2], b=+m[3];
    return 0.2126*r + 0.7152*g + 0.0722*b;
  }
  function findPanelBg(){
    // Prefer the chart's parent bg so the modal matches the main panel
    const canvas = document.querySelector('canvas');
    const ref = canvas ? (canvas.parentElement || document.body) : document.body;
    let el = ref;
    while(el){
      const bg = getComputedStyle(el).backgroundColor;
      if (bg && bg !== 'transparent' && luminance(bg) > 180){
        return bg; // likely light panel
      }
      el = el.parentElement;
    }
    // fallback to body bg or a token
    const bodyBg = getComputedStyle(document.body).backgroundColor;
    return (bodyBg && bodyBg !== 'transparent') ? bodyBg : getComputedStyle(document.body).getPropertyValue('--dash-bg-light') || '#f5f9ff';
  }
  function tagAndStructure(){
    const dialogs = Array.from(document.querySelectorAll('[role="dialog"], .modal, .dialog, .popup, .modal-container, .ReactModal__Content, .ant-modal, .chakra-modal__content'));
    for (const el of dialogs){
      const txt = (el.textContent || '').toLowerCase();
      if (txt.includes('map your columns') && txt.includes('we couldn\\'t automatically detect some columns')){
        el.classList.add('dash-mapper-modal');
        el.style.setProperty('--mapper-bg', findPanelBg());

        // Wrap Mail/CRM areas into a grid if not present
        if (!el.querySelector('.mapper-grid')){
          // Find the container that holds both "Mail CSV" and "CRM CSV"
          const mailHead = Array.from(el.querySelectorAll('h1,h2,h3,.title,.section-title')).find(h=> (h.textContent||'').trim().toLowerCase() === 'mail csv');
          const crmHead  = Array.from(el.querySelectorAll('h1,h2,h3,.title,.section-title')).find(h=> (h.textContent||'').trim().toLowerCase() === 'crm csv');
          if (mailHead && crmHead){
            // Assume their common ancestor is the container
            let anc = mailHead.parentElement;
            while(anc && !anc.contains(crmHead)) anc = anc.parentElement;
            if (anc){
              const grid = document.createElement('div');
              grid.className = 'mapper-grid';
              // Split children around mail/crm headings into two cards
              function makeCard(head){
                const card = document.createElement('div'); card.className = 'mapper-card';
                // Move heading and its following siblings until the next section title or end
                card.appendChild(head);
                let n = head.nextSibling;
                while(n){
                  const next = n.nextSibling;
                  if (n.nodeType === 1){
                    const t = (n.textContent||'').trim().toLowerCase();
                    if (t === 'mail csv' || t === 'crm csv'){ break; }
                  }
                  card.appendChild(n);
                  n = next;
                }
                return card;
              }
              const mailCard = makeCard(mailHead);
              const crmCard  = makeCard(crmHead);
              // Move grid into ancestor
              anc.appendChild(grid);
              grid.appendChild(mailCard);
              grid.appendChild(crmCard);
            }
          } else {
            // If we can't detect both sections, at least convert any large block to a card
            Array.from(el.children).forEach(ch => {
              if (ch.nodeType === 1 && !ch.classList.contains('mapper-card')){
                ch.classList.add('mapper-card');
              }
            });
          }
        }

        // Remove heavy borders from nested elements
        Array.from(el.querySelectorAll('*')).forEach(node => {
          const cs = getComputedStyle(node);
          const bg = cs.backgroundColor;
          // Nuke dark blue strips often used as section footers
          if (bg && bg !== 'transparent' && luminance(bg) < 120){
            node.style.background = 'var(--mapper-card)';
          }
          // Remove visible heavy borders
          if (cs.borderTopWidth && parseFloat(cs.borderTopWidth) >= 1){
            node.style.borderTop = '0';
            node.style.boxShadow = (node.style.boxShadow || '') + ', inset 0 0 0 1px var(--dash-border)';
          }
          if (cs.borderBottomWidth && parseFloat(cs.borderBottomWidth) >= 1){
            node.style.borderBottom = '0';
          }
          if (cs.borderLeftWidth && parseFloat(cs.borderLeftWidth) >= 1){
            node.style.borderLeft = '0';
          }
          if (cs.borderRightWidth && parseFloat(cs.borderRightWidth) >= 1){
            node.style.borderRight = '0';
          }
        });
      }
    }
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', tagAndStructure); } else { tagAndStructure(); }
  new MutationObserver(tagAndStructure).observe(document.body, {subtree:true, childList:true});
})();
</script>

<!-- BORDERLESS MAPPER: remove all borders inside the mapping popup; keep soft shadows + focus ring -->
<style id="dash-mapper-borderless">
  :root{
    --dash-blue: var(--brand-blue, #173b64);
    --dash-text: var(--text-900, #0b2942);
    --dash-muted: var(--text-500, #6b7f93);
    --mapper-bg: var(--dash-bg-light, #f5f9ff);
    --mapper-card: #ffffff;
    --mapper-ring: color-mix(in oklab, var(--dash-blue) 22%, transparent);
  }
  /* Nuke all borders within the modal */
  .dash-mapper-modal, .dash-mapper-modal *{
    border: 0 !important;
  }
  /* Modal shell */
  .dash-mapper-modal{
    background: var(--mapper-bg) !important;
    color: var(--dash-text) !important;
    border-radius: 18px !important;
    box-shadow: 0 16px 48px rgba(0,0,0,.16) !important;
    padding: 20px 22px 16px !important;
    width: min(96vw, 980px) !important;
    max-height: min(84vh, 760px) !important;
    overflow: auto !important;
  }
  /* Section titles: pill, no borders */
  .dash-mapper-modal .section-title, .dash-mapper-modal h3{
    display:inline-block !important;
    background: var(--mapper-card) !important;
    color: var(--dash-blue) !important;
    border-radius: 999px !important;
    padding: 6px 10px !important;
    font: 600 12px/1 system-ui !important;
    margin: 6px 0 8px !important;
    box-shadow: 0 1px 3px rgba(0,0,0,.06) !important;
  }
  /* Cards: no borders, soft shadow */
  .dash-mapper-modal .mapper-card{
    background: var(--mapper-card) !important;
    color: var(--dash-text) !important;
    border-radius: 14px !important;
    padding: 14px !important;
    box-shadow: 0 4px 14px rgba(0,0,0,.05) !important;
  }
  /* Inputs/selects/buttons: borderless */
  .dash-mapper-modal input[type="text"],
  .dash-mapper-modal input[type="search"],
  .dash-mapper-modal input[type="number"],
  .dash-mapper-modal select,
  .dash-mapper-modal textarea{
    background:#fff !important; color: var(--dash-text) !important;
    border-radius:10px !important;
    padding:8px 10px !important;
    height:36px !important;
    box-shadow:none !important;
  }
  .dash-mapper-modal textarea{ min-height:64px !important; }
  .dash-mapper-modal select{
    appearance:none;
    background-image: linear-gradient(45deg, transparent 50%, var(--dash-blue) 50%), linear-gradient(135deg, var(--dash-blue) 50%, transparent 50%);
    background-position: calc(100% - 16px) calc(1em + 2px), calc(100% - 12px) calc(1em + 2px);
    background-size: 4px 4px, 4px 4px; background-repeat: no-repeat; padding-right: 28px !important;
  }
  /* Keep a visible focus ring (not a border) for accessibility */
  .dash-mapper-modal input:focus,
  .dash-mapper-modal select:focus,
  .dash-mapper-modal textarea:focus{
    box-shadow: 0 0 0 3px var(--mapper-ring) !important;
  }
  /* Buttons borderless with gentle shadow */
  .dash-mapper-modal .btn, .dash-mapper-modal button{
    display:inline-flex !important; align-items:center !important; gap:8px !important;
    border-radius:999px !important; padding:8px 14px !important;
    background:#fff !important; color: var(--dash-blue) !important;
    font-weight:600 !important; font-size:12px !important; cursor:pointer !important;
    box-shadow: 0 1px 3px rgba(0,0,0,.06) !important;
  }
  .dash-mapper-modal .btn.primary, .dash-mapper-modal .primary, .dash-mapper-modal .confirm{
    background: var(--dash-blue) !important; color:#fff !important;
    box-shadow: 0 2px 6px rgba(0,0,0,.12) !important;
  }
  /* Remove hr/dividers entirely */
  .dash-mapper-modal hr, .dash-mapper-modal .divider{ display:none !important; }
  /* Eliminate any dark strips at bottom (footer bars) */
  .dash-mapper-modal [class*="bg-dark"], .dash-mapper-modal .bg-primary, .dash-mapper-modal .bg-blue{
    background: transparent !important;
  }
</style>
<script>
(function(){
  // Ensure true panel color is used, and strip any inline "hairline/inset" shadows that act like borders.
  function luminance(rgb){
    const m = rgb && rgb.match(/rgba?\\((\\d+),(\\d+),(\\d+)/i);
    if(!m) return 255;
    const r=+m[1], g=+m[2], b=+m[3];
    return 0.2126*r + 0.7152*g + 0.0722*b;
  }
  function findPanelBg(){
    const anchor = document.querySelector('canvas')?.parentElement || document.body;
    let el = anchor;
    while(el){
      const bg = getComputedStyle(el).backgroundColor;
      if (bg && bg !== 'transparent' && luminance(bg) > 180){ return bg; }
      el = el.parentElement;
    }
    const bodyBg = getComputedStyle(document.body).backgroundColor;
    return (bodyBg && bodyBg !== 'transparent') ? bodyBg : '#f5f9ff';
  }
  function stripHairlines(modal){
    const nodes = modal.querySelectorAll('*');
    nodes.forEach(n=>{
      const bs = n.style.boxShadow || '';
      if (bs.includes('inset 0 0 0 1px') || /inset\\s+0\\s+0\\s+0\\s+1px/i.test(bs)){
        // keep only non-inset shadows
        const parts = bs.split(',').map(s=>s.trim()).filter(s=>!s.startsWith('inset'));
        n.style.boxShadow = parts.join(', ');
      }
      // Remove any inline borders that may be forced by a UI library
      if (n.style.border) n.style.border = '0';
      if (n.style.borderTop) n.style.borderTop = '0';
      if (n.style.borderRight) n.style.borderRight = '0';
      if (n.style.borderBottom) n.style.borderBottom = '0';
      if (n.style.borderLeft) n.style.borderLeft = '0';
    });
  }
  function structure(){
    const dialogs = Array.from(document.querySelectorAll('[role="dialog"], .modal, .dialog, .popup, .modal-container, .ReactModal__Content, .ant-modal, .chakra-modal__content'));
    for (const el of dialogs){
      const txt = (el.textContent || '').toLowerCase();
      if (txt.includes('map your columns') && txt.includes('we couldn\\'t automatically detect some columns')){
        el.classList.add('dash-mapper-modal');
        el.style.setProperty('--mapper-bg', findPanelBg());
        // Wrap mail/crm blocks into cards if not already
        const heads = Array.from(el.querySelectorAll('h1,h2,h3,.title,.section-title'));
        const mailHead = heads.find(h=> (h.textContent||'').trim().toLowerCase()==='mail csv');
        const crmHead  = heads.find(h=> (h.textContent||'').trim().toLowerCase()==='crm csv');
        if (mailHead && crmHead && !el.querySelector('.mapper-card')){
          let anc = mailHead.parentElement;
          while(anc && !anc.contains(crmHead)) anc = anc.parentElement;
          if (anc){
            const grid = document.createElement('div'); grid.className='mapper-grid';
            function makeCard(head){
              const card = document.createElement('div'); card.className='mapper-card';
              card.appendChild(head);
              let n=head.nextSibling;
              while(n){
                const next=n.nextSibling;
                if (n.nodeType===1){
                  const t=(n.textContent||'').trim().toLowerCase();
                  if (t==='mail csv' || t==='crm csv'){ break; }
                }
                card.appendChild(n); n=next;
              }
              return card;
            }
          }
        }
        stripHairlines(el);
      }
    }
  }
  if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', structure); } else { structure(); }
  new MutationObserver(structure).observe(document.body, {subtree:true, childList:true});
})();
</script>

<!-- Light style for "Clear saved mapping" in mapper modal -->
<style id="dash-mapper-clear-skin">
  :root{
    --dash-blue: var(--brand-blue, #173b64);
    --dash-text: var(--text-900, #0b2942);
    --dash-soft: color-mix(in oklab, var(--dash-blue) 12%, #ffffff 88%);
  }
  .dash-mapper-modal .mapper-clear{
    background: var(--dash-soft) !important;
    color: var(--dash-blue) !important;
    border: 0 !important;
    border-radius: 10px !important;
    padding: 8px 12px !important;
    display: inline-flex !important;
    align-items: center !important;
    gap: 6px !important;
    box-shadow: 0 1px 3px rgba(0,0,0,.06) !important;
    text-decoration: none !important;
  }
  .dash-mapper-modal .mapper-clear:hover{
    filter: brightness(0.98);
  }
</style>
<script>
(function(){
  function tagClear(){
    const modal = document.querySelector('.dash-mapper-modal, [role="dialog"]');
    if(!modal) return;
    const candidates = Array.from(modal.querySelectorAll('button, a, .btn'));
    for (const el of candidates){
      const t = (el.textContent || '').trim().toLowerCase();
      if (t === 'clear saved mapping'){
        el.classList.add('mapper-clear');
        // remove any "danger/primary/dark" classes that force dark bg
        ['danger','primary','bg-dark','bg-blue','bg-primary'].forEach(c=> el.classList.remove(c));
        // inline override if a library sets background
        el.style.background = 'var(--dash-soft)';
        el.style.color = 'var(--dash-blue)';
      }
    }
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', tagClear); } else { tagClear(); }
  new MutationObserver(tagClear).observe(document.body, {subtree:true, childList:true});
})();
</script>

<!-- Mapper Actions Bar: light/transparent background + tidy layout -->
<style id="dash-mapper-actions-skin">
  :root{
    --dash-blue: var(--brand-blue, #173b64);
    --dash-text: var(--text-900, #0b2942);
    --mapper-bg: var(--dash-bg-light, #f5f9ff);
  }
  .dash-mapper-modal .mapper-actions,
  .dash-mapper-modal .footer,
  .dash-mapper-modal .modal-footer,
  .dash-mapper-modal .actions{
    background: transparent !important;
    border: 0 !important;
    box-shadow: none !important;
    padding-top: 12px !important;
    display: flex !important;
    gap: 8px !important;
    justify-content: flex-end !important;
    align-items: center !important;
  }
  /* If any library forces a dark background on a wrapper, neutralize it */
  .dash-mapper-modal [class*="footer"],
  .dash-mapper-modal [class*="actions"],
  .dash-mapper-modal [class*="bar"]{
    background: transparent !important;
    border: 0 !important;
    box-shadow: none !important;
  }
</style>
<script>
(function(){
  function luminance(rgb){
    const m = rgb && rgb.match(/rgba?\\((\\d+),(\\d+),(\\d+)/i);
    if(!m) return 255;
    const r=+m[1], g=+m[2], b=+m[3];
    return 0.2126*r + 0.7152*g + 0.0722*b;
  }
  function tagActionsBar(){
    const modal = document.querySelector('.dash-mapper-modal, [role="dialog"]');
    if(!modal) return;

    // Find the three known buttons by text
    const btns = Array.from(modal.querySelectorAll('button, a, .btn'));
    const texts = b => (b.textContent||'').trim().toLowerCase();
    const clearBtn  = btns.find(b => texts(b) === 'clear saved mapping');
    const cancelBtn = btns.find(b => texts(b) === 'cancel');
    const useBtn    = btns.find(b => texts(b) === 'use mapping');

    function commonAncestor(a, b){
      if(!a || !b) return null;
      const A=[]; let n=a; while(n){ A.push(n); n=n.parentElement; }
      let m=b; while(m){ if (A.includes(m)) return m; m=m.parentElement; }
      return null;
    }

    // Determine the action bar container
    let container = null;
    if (clearBtn && cancelBtn) container = commonAncestor(clearBtn, cancelBtn);
    if (container && useBtn) container = commonAncestor(container, useBtn) || container;

    // Fallback: pick a likely footer/actions node near the bottom
    if (!container){
      const footers = Array.from(modal.querySelectorAll('.footer, .modal-footer, .actions, [class*="footer"], [class*="actions"]'));
      container = footers.reverse().find(el => el.offsetTop > (modal.offsetHeight * 0.5)) || footers.pop();
    }

    if (container && !container.dataset.mapperActionsTagged){
      container.dataset.mapperActionsTagged = '1';
      container.classList.add('mapper-actions');
      // Neutralize any dark background forced inline
      const bg = getComputedStyle(container).backgroundColor;
      if (bg && bg !== 'transparent' && luminance(bg) < 160){
        container.style.background = 'transparent';
      }
      // If there's a wrapping bar with dark bg, clear it too
      const wrap = container.parentElement;
      if (wrap){
        const wbg = getComputedStyle(wrap).backgroundColor;
        if (wbg && wbg !== 'transparent' && luminance(wbg) < 160){
          wrap.style.background = 'transparent';
          wrap.style.boxShadow = 'none';
          wrap.style.border = '0';
        }
      }
    }
  }

  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', tagActionsBar); } else { tagActionsBar(); }
  new MutationObserver(tagActionsBar).observe(document.body, {subtree:true, childList:true});
})();
</script>

<!-- Strong override for mapper action bar background -->
<style id="dash-mapper-actions-skin-strong">
  :root{
    --dash-blue: var(--brand-blue, #173b64);
    --dash-text: var(--text-900, #0b2942);
    --dash-panel: var(--dash-light, var(--dash-bg-light, #E6F1FF));
    --mapper-bg: var(--dash-panel);
  }
  /* Force common action/footer containers to the light panel bg */
  .dash-mapper-modal .mapper-actions,
  .dash-mapper-modal .footer,
  .dash-mapper-modal .modal-footer,
  .dash-mapper-modal .actions,
  .dash-mapper-modal footer,
  .dash-mapper-modal .ant-modal-footer,
  .dash-mapper-modal .chakra-modal__footer,
  .dash-mapper-modal [class*="footer"],
  .dash-mapper-modal [class*="actions"],
  .dash-mapper-modal [class*="bar"],
  .dash-mapper-modal [class*="bottom"]{
    background: var(--mapper-bg) !important;
    background-image: none !important;
    border: 0 !important;
    box-shadow: none !important;
  }
</style>
<script>
(function(){
  function luminance(rgb){
    const m = rgb && rgb.match(/rgba?\\((\\d+),(\\d+),(\\d+)/i);
    if(!m) return 255;
    const r=+m[1], g=+m[2], b=+m[3];
    return 0.2126*r + 0.7152*g + 0.0722*b;
  }
  function panelBg(){
    // Use modal's background or fall back to body/dash token
    const modal = document.querySelector('.dash-mapper-modal') || document.body;
    const cs = getComputedStyle(modal);
    const bg = cs.getPropertyValue('--mapper-bg') || cs.getPropertyValue('--dash-panel') || cs.backgroundColor;
    return (bg && bg.trim()) || '#E6F1FF';
  }
  function fixActions(){
    const modal = document.querySelector('.dash-mapper-modal, [role="dialog"]');
    if(!modal) return;
    const btns = Array.from(modal.querySelectorAll('button, a, .btn'));
    const text = el => (el.textContent||'').trim().toLowerCase();
    const clearBtn = btns.find(b => text(b) === 'clear saved mapping');
    const cancelBtn= btns.find(b => text(b) === 'cancel');
    const useBtn   = btns.find(b => text(b) === 'use mapping');

    function commonAncestor(a,b){
      if(!a||!b) return null;
      const seen = new Set(); let n=a; while(n){ seen.add(n); n=n.parentElement; }
      n=b; while(n){ if(seen.has(n)) return n; n=n.parentElement; }
      return null;
    }

    let container = null;
    if (clearBtn && cancelBtn) container = commonAncestor(clearBtn, cancelBtn);
    if (container && useBtn) container = commonAncestor(container, useBtn) || container;
    // Fallback: pick the lowest footer-like element
    if (!container){
      const candidates = Array.from(modal.querySelectorAll('.footer, .modal-footer, .actions, footer, [class*="footer"], [class*="actions"], [class*="bar"], [class*="bottom"]'));
      container = candidates.reverse().find(el => el.offsetTop > modal.offsetHeight * 0.5) || candidates.pop();
    }
    if (!container) return;

    // Climb up from container to modal and clear any dark backgrounds along the path
    const bgColor = panelBg();
    let node = container;
    while(node && node !== modal.parentElement){
      const cs = getComputedStyle(node);
      const bg = cs.backgroundColor;
      if (bg && bg !== 'transparent' && luminance(bg) < 180){
        node.style.background = bgColor;
        node.style.backgroundImage = 'none';
        node.style.border = '0';
        node.style.boxShadow = 'none';
      }
      if (node === modal) break;
      node = node.parentElement;
    }

    // Finally, mark the determined container as the action bar for our CSS hook
    container.classList.add('mapper-actions');
  }

  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', fixActions); } else { fixActions(); }
  new MutationObserver(fixActions).observe(document.body, {subtree:true, childList:true});
})();
</script>

<!-- Mapper header/footer: non-sticky (scroll with content) -->
<style id="dash-mapper-non-sticky">
  /* Common header/footer containers inside the mapper modal */
  .dash-mapper-modal .modal-header,
  .dash-mapper-modal .ant-modal-header,
  .dash-mapper-modal .chakra-modal__header,
  .dash-mapper-modal header,
  .dash-mapper-modal [class*="header"],
  .dash-mapper-modal .mapper-actions,
  .dash-mapper-modal .footer,
  .dash-mapper-modal .modal-footer,
  .dash-mapper-modal .ant-modal-footer,
  .dash-mapper-modal .chakra-modal__footer,
  .dash-mapper-modal .actions,
  .dash-mapper-modal [class*="footer"],
  .dash-mapper-modal [class*="actions"],
  .dash-mapper-modal [class*="bar"],
  .dash-mapper-modal [class*="bottom"]{
    position: static !important;
    top: auto !important;
    bottom: auto !important;
    inset: auto !important;
    z-index: auto !important;
    /* keep the light vibe; no fixed bars */
    box-shadow: none !important;
    border: 0 !important;
    background-attachment: scroll !important;
  }
  /* Ensure the modal body can scroll naturally and isn't sized assuming sticky bars */
  .dash-mapper-modal{
    overflow: auto !important;
    padding-bottom: 16px !important;
    padding-top: 16px !important;
  }
</style>
<script>
(function(){
  // Strip inline sticky/fixed styles that some UI libs set at runtime
  function unstick(){
    const modal = document.querySelector('.dash-mapper-modal, [role="dialog"]');
    if(!modal) return;
    const selectors = [
      '.modal-header','.ant-modal-header','.chakra-modal__header','header','[class*="header"]',
      '.mapper-actions','.footer','.modal-footer','.ant-modal-footer','.chakra-modal__footer','.actions','[class*="footer"]','[class*="actions"]','[class*="bar"]','[class*="bottom"]'
    ];
    const nodes = selectors.flatMap(sel => Array.from(modal.querySelectorAll(sel)));
    nodes.forEach(n => {
      const st = n.style;
      if (!st) return;
      ['position','top','bottom','inset','zIndex','boxShadow','border','backgroundAttachment'].forEach(k => { st[k] = ''; });
      // Some frameworks set data attributes that trigger sticky; neutralize common flags
      if (n.dataset) {
        delete n.dataset.sticky;
        delete n.dataset.affix;
        delete n.dataset.fixed;
      }
      // Ensure layout flow spacing feels natural
      if (getComputedStyle(n).position !== 'static'){
        n.style.position = 'static';
      }
    });
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', unstick); } else { unstick(); }
  new MutationObserver(unstick).observe(document.body, {subtree:true, childList:true});
})();
</script>

<!-- Strong non-sticky override for the mapping actions section -->
<style id="dash-mapper-actions-nonsticky-strong">
  .dash-mapper-modal .mapper-actions-fixed-killer{
    position: static !important;
    top: auto !important;
    bottom: auto !important;
    inset: auto !important;
    z-index: auto !important;
    box-shadow: none !important;
    border: 0 !important;
    background: var(--mapper-bg, transparent) !important;
    backdrop-filter: none !important;
  }
</style>
<script>
(function(){
  function commonAncestor(a,b){
    if(!a||!b) return null;
    const seen=new Set(); let n=a; while(n){ seen.add(n); n=n.parentElement; }
    n=b; while(n){ if(seen.has(n)) return n; n=n.parentElement; }
    return null;
  }
  function findActionsContainer(modal){
    const btns = Array.from(modal.querySelectorAll('button, a, .btn'));
    const t = el => (el.textContent||'').trim().toLowerCase();
    const clearBtn = btns.find(b=> t(b)==='clear saved mapping');
    const cancelBtn= btns.find(b=> t(b)==='cancel');
    const useBtn   = btns.find(b=> t(b)==='use mapping');
    let container = null;
    if (clearBtn && cancelBtn) container = commonAncestor(clearBtn, cancelBtn);
    if (container && useBtn) container = commonAncestor(container, useBtn) || container;
    if (!container){
      // fallback to last footer-like node near bottom
      const cands = Array.from(modal.querySelectorAll('.footer, .modal-footer, .actions, footer, [class*="footer"], [class*="actions"], [class*="bar"], [class*="bottom"]'));
      container = cands.reverse().find(el => el.offsetTop > modal.offsetHeight * 0.4) || cands.pop() || modal.lastElementChild;
    }
    return container || modal;
  }
  function unstick(){
    const modal = document.querySelector('.dash-mapper-modal, [role="dialog"]');
    if(!modal) return;
    const container = findActionsContainer(modal);
    if (!container) return;

    // Mark target + parents to ensure CSS !important wins
    let node = container;
    while(node && node !== modal.parentElement){
      node.classList.add('mapper-actions-fixed-killer');
      // Force inline styles with !important (beats most libs)
      node.style.setProperty('position','static','important');
      node.style.setProperty('top','auto','important');
      node.style.setProperty('bottom','auto','important');
      node.style.setProperty('inset','auto','important');
      node.style.setProperty('z-index','auto','important');
      node.style.setProperty('box-shadow','none','important');
      node.style.setProperty('border','0','important');
      node.style.setProperty('background','var(--mapper-bg, transparent)','important');
      node.style.setProperty('backdrop-filter','none','important');

      // Remove common sticky/fixed class hints
      ['sticky','fixed','affix','footer-fixed','ant-modal-footer','chakra-modal__footer'].forEach(c=>{
        if (node.classList.contains(c)) node.classList.remove(c);
      });
      node = node.parentElement;
      if (node === modal) { node.classList.add('mapper-actions-fixed-killer'); }
    }
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', unstick); } else { unstick(); }
  new MutationObserver(unstick).observe(document.body, {subtree:true, childList:true});
})();
</script>

<!-- Mapper main title: larger font, no background -->
<style id="dash-mapper-main-title-skin">
  .dash-mapper-modal .mapper-main-title{
    background: transparent !important;
    box-shadow: none !important;
    border: 0 !important;
    padding: 0 !important;
    margin: 0 0 6px 0 !important;
    color: var(--dash-blue, #173b64) !important;
    font-weight: 800 !important;
    font-size: 22px !important;
    line-height: 1.25 !important;
    letter-spacing: .2px !important;
  }
</style>
<script>
(function(){
  function markMainTitle(){
    const modal = document.querySelector('.dash-mapper-modal, [role="dialog"]');
    if(!modal) return;
    const nodes = modal.querySelectorAll('h1,h2,.title');
    nodes.forEach(n => {
      const t = (n.textContent || '').trim().toLowerCase();
      if (t === 'map your columns'){
        n.classList.add('mapper-main-title');
      }
    });
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', markMainTitle); } else { markMainTitle(); }
  new MutationObserver(markMainTitle).observe(document.body, {subtree:true, childList:true});
})();
</script>

<!-- Make the top-left "Map your columns" label plain (no background), larger font -->
<style id="dash-mapper-title-plain">
  .dash-mapper-modal .mapper-title-plain{
    background: transparent !important;
    box-shadow: none !important;
    border: 0 !important;
    padding: 0 !important;
    margin: 0 0 8px 0 !important;
    display: block !important;
    color: var(--dash-blue, #173b64) !important;
    font-weight: 800 !important;
    font-size: 22px !important;
    line-height: 1.25 !important;
    letter-spacing: .2px !important;
  }
</style>
<script>
(function(){
  function normalize(s){ return (s||'').replace(/\s+/g,' ').trim().toLowerCase(); }
  function plainify(){
    // Look for any element whose exact text is "Map your columns" inside the mapper modal
    const modal = document.querySelector('.dash-mapper-modal, [role="dialog"]');
    if(!modal) return;
    const all = modal.querySelectorAll('*');
    for (const el of all){
      const t = normalize(el.textContent);
      if (t === 'map your columns'){
        // Remove pill/section styles if present
        el.classList.remove('section-title','title','pill');
        // Add our plain title class
        el.classList.add('mapper-title-plain');
        // Kill inline backgrounds that may be set by the UI lib
        el.style.setProperty('background','transparent','important');
        el.style.setProperty('box-shadow','none','important');
        el.style.setProperty('border','0','important');
        el.style.setProperty('padding','0','important');
        // Done after first match
        break;
      }
    }
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', plainify); } else { plainify(); }
  new MutationObserver(plainify).observe(document.body, {subtree:true, childList:true});
})();
</script>
